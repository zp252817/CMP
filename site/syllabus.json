{
  "project": "CMP框架知识地图",
  "generated_at": "2026-02-12 12:04:07",
  "source_root": "/Users/zhangpanmac/.codex/skills/cmp-knowledge-map-builder/assets",
  "source_file_count": 13,
  "split_mode": "auto",
  "modules": [
    {
      "module_id": "module-10877e53",
      "title": "流水线问题处理",
      "source_path": "environment-setup/流水线问题处理.docx",
      "source_file_hash": "10877e5307049b4ece01f39a59dcce13596fa64c",
      "split_mode": "auto",
      "render_version": 11,
      "difficulty": 1,
      "summary": "流水线问题处理 开发者提交Pull Request后，评论\"start build\"会触发门禁校验，系统将自动检查，在此期间可能会遇到一些问题，本文档介绍流水线的常见问题及解...",
      "sections": [
        {
          "section_id": "5d0b07aea4",
          "title": "流水线问题处理",
          "summary": "流水线问题处理 开发者提交Pull Request后，评论\"start build\"会触发门禁校验，系统将自动检查，在此期间可能会遇到一些问题，本文档介绍流水线的常见问题及解...",
          "key_points": [
            "流水线问题处理",
            "开发者提交Pull Request后，评论\"start build\"会触发门禁校验，系统将自动检查，在此期间可能会遇到一些问题，本文档介绍流水线的常见问题及解决方法。",
            "一、DCO校验异常处理",
            "未签署DCO协议"
          ],
          "estimated_minutes": 2,
          "content": "流水线问题处理\n\n开发者提交Pull Request后，评论\"start build\"会触发门禁校验，系统将自动检查，在此期间可能会遇到一些问题，本文档介绍流水线的常见问题及解决方法。\n\n一、DCO校验异常处理\n\n未签署DCO协议\n\n校验失败原因：PR提交者未通过官方指定渠道完成DCO协议签署，或签署过程中使用的邮箱与代码提交账号绑定的邮箱不一致，导致系统无法匹配校验信息，最终触发校验失败。\n\n解决办法：https://dco.openharmony.cn/sign点击链接签署，注意签署的邮箱必须和提交代码的账号的邮箱一致，然后评论区评论check dco即可。\n\nCommits中未包含Signed-off-by信息\n\n校验失败原因：代码提交时，未在Commit描述信息中添加`Signed-off-by`声明，或声明格式不符合系统校验规范（如用户名/邮箱错误、缺少关键格式符号等），导致系统无法识别校验信息，进而触发失败。\n\n解决办法：首先通过Git工具重置分支至校验异常前状态 需将当前分支回退至未触发DCO校验异常的代码版本，操作如下：\n\n然后重新提交，并且加上自己的signed-off-by信息，格式为user.name <user.email>",
          "content_html": "<h1>流水线问题处理</h1>\n<p>开发者提交Pull Request后，评论\"start build\"会触发门禁校验，系统将自动检查，在此期间可能会遇到一些问题，本文档介绍流水线的常见问题及解决方法。</p>\n<h2>一、DCO校验异常处理</h2>\n<ol>\n<li>未签署DCO协议</li>\n</ol>\n<ul>\n<li><em>校验失败原因：PR提交者未通过官方指定渠道完成DCO协议签署，或签署过程中使用的邮箱与代码提交账号绑定的邮箱不一致，导致系统无法匹配校验信息，最终触发校验失败。</em></li>\n<li><em>解决办法：</em>https://dco.openharmony.cn/sign点击链接签署，注意签署的邮箱必须和提交代码的账号的邮箱一致，然后评论区评论<em>check dco即可。</em><br/></li>\n</ul>\n<figure class=\"doc-figure\"><img src=\"../knowledge-map-assets/module-10877e53-4a74c8f717.png\" alt=\"流水线问题处理 图示\" /></figure>\n<ol>\n<li>Commits中未包含Signed-off-by信息</li>\n</ol>\n<ul>\n<li><em>校验失败原因：代码提交时，未在Commit描述信息中添加`Signed-off-by`声明，或声明格式不符合系统校验规范（如用户名/邮箱错误、缺少关键格式符号等），导致系统无法识别校验信息，进而触发失败。</em></li>\n<li><em>解决办法：首先通过Git工具重置分支至校验异常前状态 需将当前分支回退至未触发DCO校验异常的代码版本，操作如下： </em></li>\n</ul>\n<figure class=\"doc-figure\"><img src=\"../knowledge-map-assets/module-10877e53-21767bf8c9.png\" alt=\"流水线问题处理 图示\" /></figure>\n<figure class=\"doc-figure\"><img src=\"../knowledge-map-assets/module-10877e53-70d8762a85.png\" alt=\"流水线问题处理 图示\" /></figure>\n<p>然后重新提交，并且加上自己的signed-off-by信息，格式为<em>user.name &lt;user.email&gt;</em></p>\n<figure class=\"doc-figure\"><img src=\"../knowledge-map-assets/module-10877e53-538cc84cb2.png\" alt=\"流水线问题处理 图示\" /></figure>"
        }
      ],
      "estimated_minutes": 2
    },
    {
      "module_id": "cmp-2b736961",
      "title": "CMP相关产物依赖层级关系",
      "source_path": "environment-setup/CMP相关产物依赖层级关系.docx",
      "source_file_hash": "2b736961a5c9307e8beda9618a8a263b0d175388",
      "split_mode": "auto",
      "render_version": 11,
      "difficulty": 1,
      "summary": "CMP相关产物依赖层级关系 一、核心产物版本号修改规范（按依赖优先级排序） 1.",
      "sections": [
        {
          "section_id": "bc665bf2b3",
          "title": "CMP相关产物依赖层级关系",
          "summary": "CMP相关产物依赖层级关系 一、核心产物版本号修改规范（按依赖优先级排序） 1.",
          "key_points": [
            "skiko 产物（基础依赖）",
            "kotlinx.atomicfu 产物（基础依赖）",
            "compose-multiplatform-core 产物（核心依赖层）",
            "compose-multiplatform 产物（上层产物层）"
          ],
          "estimated_minutes": 8,
          "content": "CMP相关产物依赖层级关系\n\n一、核心产物版本号修改规范（按依赖优先级排序）\n\n1. skiko 产物（基础依赖）\n\n版本号修改：编辑文件 skiko/gradle.properties，修改 deploy.version 字段值\n\n依赖说明：\n\n编辑文件samples/SkiaMultiplatformSample/build.gradle.kts，修改var version 字段值；\n\n编辑文件samples/SkiaMultiplatformSample/gradle.properties，修改skiko.version字段值；\n\n发布命令：${skiko工程路径}/skiko/build-with-local-skia.sh\n\n2. kotlinx.atomicfu 产物（基础依赖）\n\n版本号修改：编辑根目录 gradle.properties，修改 version 字段值\n\n修改atomicfu/build.gradle文件的version 字段值\n\n依赖说明：无前置依赖，为独立基础产物\n\n发布命令：./gradlew publish\n\n3. compose-multiplatform-core 产物（核心依赖层）\n\n版本号修改：编辑 libraryversions.toml 文件，修改 COMPOSE 字段值\n\n依赖说明：需同步关联基础产物版本，需编辑 gradle/libs.versions.toml 文件，更新 atomicFu 和 skiko 的版本号（必须与两者本地已发布版本一致）\n\n发布命令：./gradlew :mpp:publishComposeJbToMavenLocal -Pcompose.platforms=android,ohosArm64\n\n4. compose-multiplatform 产物（上层产物层）\n\n版本号修改：\n\n编辑 gradle-plugins/gradle.properties文件，修改 compose.version 和deploy.version的字段值；\n\n编辑 components/gradle.properties文件，修改 compose.version 和deploy.version的字段值；\n\n编辑compose/scripts/publishComponentsToMavenLocal和\n\ncompose/scripts/publishGradlePluginToMavenLocal文件，修改COMPOSE_CUSTOM_VERSION字段值\n\n依赖说明：需与 compose-multiplatform-core 产物版本保持一致性\n\n发布命令：\n\n插件发布：\n\n./compose/scripts/publishGradlePluginToMavenLocal\n\n组件发布：\n\n./compose/scripts/publishComponentsToMavenLocal\n\n5. Compose-sample 产物（示例应用层）\n\n版本号修改：编辑 gradle/libs.versions.toml 文件，更新 atomicFu、compose、compose-multiplatform 三个字段值（必须与三者本地已发布版本一致）\n\n依赖说明：依赖全部上游产物，需确保基础层、核心层、上层产物均已本地发布\n\n发布命令：./gradlew publishReleaseBinariesToHarmonyApp\n\n依赖层级关系表\n\nSkiko\n\n发布\n\nskiko/gradle.properties\n\ndeploy.version\n\nSkiko\n\n内部依赖\n\nsamples/SkiaMultiplatformSample/build.gradle.kts\n\nvar version\n\nSkiko\n\n内部依赖\n\nsamples/SkiaMultiplatformSample/gradle.properties\n\nskiko.version\n\nAtomicFu\n\n发布\n\ngradle.properties\n\nversion\n\nAtomicFu\n\n发布（备用）\n\natomicfu/build.gradle\n\nversion\n\ncompose-multiplatform-core\n\n依赖 Skiko\n\ngradle/libs.versions.toml\n\n[versions] -> skiko\n\ncompose-multiplatform-core\n\n依赖 AtomicFu\n\ngradle/libs.versions.toml\n\n[versions] -> atomicFu\n\ncompose-multiplatform-core\n\n发布\n\nlibraryversions.toml\n\n[versions] -> COMPOSE\n\nSample\n\n依赖 Core\n\ngradle/libs.versions.toml\n\n[versions] -> compose\n\nSample\n\n依赖 Core\n\ngradle/libs.versions.toml\n\n[versions] -> compose-multiplatform\n\ncompose-multiplatform\n\n发布 Component\n\ncomponents/gradle.properties\n\ncompose.version / deploy.version\n\ncompose/scripts/publishComponentsToMavenLocal\n\nCOMPOSE_CUSTOM_VERSION\n\ncompose-multiplatform\n\n发布 Plugin\n\ngradle-plugins/gradle.properties\n\ncompose.version / deploy.version\n\ncompose/scripts/publishGradlePluginToMavenLocal\n\nCOMPOSE_CUSTOM_VERSION\n\n依赖层级逻辑图",
          "content_html": "<h1><strong>CMP相关产物依赖层级关系</strong></h1>\n<h2><strong>一、核心产物版本号修改规范（按依赖优先级排序）</strong></h2>\n<h3><strong>1. skiko 产物（基础依赖）</strong></h3>\n<p><strong>版本号修改：</strong><strong>编辑文件 skiko/gradle.properties，修改 deploy.version 字段值</strong></p>\n<ul>\n<li><strong>依赖说明：</strong></li>\n<li><strong>编辑文件</strong><em>samples/SkiaMultiplatformSample/build.gradle.kts</em><strong>，修改</strong><em>var version</em><strong> 字段值；</strong></li>\n<li><strong>编辑文件</strong><em>samples/SkiaMultiplatformSample/gradle.properties</em><strong>，修改</strong><em>skiko.version</em><strong>字段值；</strong></li>\n</ul>\n<p><strong>发布命令：</strong><strong>${skiko工程路径}/skiko/build-with-local-skia.sh</strong></p>\n<h3><strong>2. kotlinx.atomicfu 产物（基础依赖）</strong></h3>\n<p><strong>版本号修改：</strong><strong>编辑根目录 gradle.properties，修改 version 字段值</strong></p>\n<p><strong>修改atomicfu/build.gradle文件的</strong><strong>version 字段值</strong></p>\n<p><strong>依赖说明：</strong><strong>无前置依赖，为独立基础产物</strong></p>\n<p><strong>发布命令：</strong><strong>./gradlew publish</strong></p>\n<h3><strong>3. compose-multiplatform-core 产物（核心依赖层）</strong></h3>\n<p><strong>版本号修改：</strong><strong>编辑 libraryversions.toml 文件，修改 COMPOSE 字段值</strong></p>\n<p><strong>依赖说明：</strong><strong>需同步关联基础产物版本，需编辑 gradle/libs.versions.toml 文件，更新 atomicFu 和 skiko 的版本号（必须与两者本地已发布版本一致）</strong></p>\n<p><strong>发布命令：</strong><strong>./gradlew :mpp:publishComposeJbToMavenLocal -Pcompose.platforms=android,ohosArm64</strong></p>\n<h3><strong>4. compose-multiplatform 产物（上层产物层）</strong></h3>\n<ul>\n<li><strong>版本号修改：</strong></li>\n<li><strong>编辑 gradle-plugins/gradle.properties文件，修改 </strong><em>compose.version</em><strong> </strong><strong>和</strong><em>deploy.version</em><em>的</em><strong>字段值</strong><strong>；</strong></li>\n<li><strong>编辑 </strong><em>components/gradle.properties</em><strong>文件，修改 </strong><em>compose.version</em><strong> 和</strong><em>deploy.version</em><em>的</em><strong>字段值；</strong></li>\n<li><strong>编辑</strong><em>compose/scripts/publishComponentsToMavenLocal</em><em>和</em></li>\n</ul>\n<p><em>compose/scripts/publishGradlePluginToMavenLocal</em><em>文件，修改</em><em>COMPOSE_CUSTOM_VERSION</em><em>字段值</em></p>\n<p><strong>依赖说明：</strong><strong>需与 compose-multiplatform-core 产物版本保持一致性</strong></p>\n<p><strong>发布命令：</strong></p>\n<p><strong>插件发布：</strong></p>\n<p><strong>./compose/scripts/publishGradlePluginToMavenLocal</strong></p>\n<p><strong>组件发布：</strong></p>\n<p><strong>./compose/scripts/publishComponentsToMavenLocal</strong></p>\n<h3><strong>5. Compose-sample 产物（示例应用层）</strong></h3>\n<p><strong>版本号修改：</strong><strong>编辑 gradle/libs.versions.toml 文件，更新 atomicFu、compose、compose-multiplatform 三个字段值（必须与三者本地已发布版本一致）</strong></p>\n<p><strong>依赖说明：</strong><strong>依赖全部上游产物，需确保基础层、核心层、上层产物均已本地发布</strong></p>\n<p><strong>发布命令：</strong><strong>./gradlew publishReleaseBinariesToHarmonyApp</strong></p>\n<ul>\n<li><strong>依赖层级关系表</strong></li>\n</ul>\n<div class=\"doc-table-wrap\"><table class=\"doc-table\"><thead><tr><th>Skiko</th><th>发布</th><th>skiko/gradle.properties</th><th>deploy.version</th></tr></thead><tbody><tr><td>Skiko</td><td>内部依赖</td><td>samples/SkiaMultiplatformSample/build.gradle.kts</td><td>var version</td></tr><tr><td>Skiko</td><td>内部依赖</td><td>samples/SkiaMultiplatformSample/gradle.properties</td><td>skiko.version</td></tr><tr><td>AtomicFu</td><td>发布</td><td>gradle.properties</td><td>version</td></tr><tr><td>AtomicFu</td><td>发布（备用）</td><td>atomicfu/build.gradle</td><td>version</td></tr><tr><td>compose-multiplatform-core</td><td>依赖 Skiko</td><td>gradle/libs.versions.toml</td><td>[versions] -&gt; skiko</td></tr><tr><td>compose-multiplatform-core</td><td>依赖 AtomicFu</td><td>gradle/libs.versions.toml</td><td>[versions] -&gt; atomicFu</td></tr><tr><td>compose-multiplatform-core</td><td>发布</td><td>libraryversions.toml</td><td>[versions] -&gt; COMPOSE</td></tr><tr><td>Sample</td><td>依赖 Core</td><td>gradle/libs.versions.toml</td><td>[versions] -&gt; compose</td></tr><tr><td>Sample</td><td>依赖 Core</td><td>gradle/libs.versions.toml</td><td>[versions] -&gt; compose-multiplatform</td></tr><tr><td>compose-multiplatform</td><td>发布 Component</td><td>components/gradle.properties</td><td>compose.version / deploy.version</td></tr><tr><td></td><td></td><td>compose/scripts/publishComponentsToMavenLocal</td><td>COMPOSE_CUSTOM_VERSION</td></tr><tr><td>compose-multiplatform</td><td>发布 Plugin</td><td>gradle-plugins/gradle.properties</td><td>compose.version / deploy.version</td></tr><tr><td></td><td></td><td>compose/scripts/publishGradlePluginToMavenLocal</td><td>COMPOSE_CUSTOM_VERSION</td></tr></tbody></table></div>\n<ul>\n<li><strong>依赖层级逻辑图</strong></li>\n</ul>\n<figure class=\"doc-figure\"><img src=\"../knowledge-map-assets/cmp-2b736961-56995c6fa0.png\" alt=\"CMP相关产物依赖层级关系 图示\" /></figure>"
        }
      ],
      "estimated_minutes": 8
    },
    {
      "module_id": "compose-ohos-28606dae",
      "title": "Compose 语义系统梳理与 OHOS 无障碍适配",
      "source_path": "principle-analysis/Compose 语义系统梳理与 OHOS 无障碍适配.docx",
      "source_file_hash": "28606dae7584d349b4f55763aa19062758d0be5e",
      "split_mode": "auto",
      "render_version": 11,
      "difficulty": 1,
      "summary": "Compose 语义系统梳理与 OHOS 无障碍适配 一、Compose 语义系统梳理 1.",
      "sections": [
        {
          "section_id": "6a9d4c5330",
          "title": "Compose 语义系统梳理与 OHOS 无障碍适配",
          "summary": "Compose 语义系统梳理与 OHOS 无障碍适配 一、Compose 语义系统梳理 1.",
          "key_points": [
            "CMP公共语义模型概览",
            "SemanticsProperties.kt 关键类型细化",
            "语义树树状结构",
            "当前OHOS 平台桥接实现"
          ],
          "estimated_minutes": 25,
          "content": "Compose 语义系统梳理与 OHOS 无障碍适配\n\n一、Compose 语义系统梳理\n\n1. CMP公共语义模型概览\n\n文件\n\n核心职责\n\n适配意义\n\nSemanticsConfiguration.kt\n\n单节点语义配置容器，支持合并( mergeChild )与覆写( collapsePeer )策略\n\n平台桥接层按配置生成原生节点数据\n\nSemanticsProperties.kt\n\n定义语义属性、动作及辅助类型（详见第 2 节）\n\n统一属性/动作枚举，便于不同平台复用\n\nSemanticsNode.kt\n\n语义树节点结构（父子关系、bounds、 isFake 等）\n\n平台遍历语义树的直接数据来源\n\nSemanticsOwner.kt\n\n语义树根节点管理，提供 onSemanticsChange 、 getAllSemanticsNodes\n\n平台监听语义树变化\n\nSemanticsModifier.kt\n\n将 Modifier.semantics {} 中的设置写入 SemanticsConfiguration\n\n业务层语义入口\n\nSemanticKeys.kt\n\nSemanticsPropertyKey 、 AccessibilityKey 等基础设施\n\n规范自定义语义键\n\nSemanticsSort.kt\n\n节点排序工具（焦点顺序）\n\n保证跨平台遍历一致性\n\n2. SemanticsProperties.kt 关键类型细化\n\n类型/对象\n\n代表成员\n\n说明\n\nobject SemanticsProperties\n\nContentDescription 、 Text 、 EditableText 、 Role 、 LiveRegion 、 TraversalIndex 、 CustomActions 等\n\n所有语义属性键，默认通过 AccessibilityKey 定义合并策略\n\nobject SemanticsActions\n\nOnClick 、 OnLongClick 、 ScrollBy 、 ScrollToIndex 、 SetText 、 CopyText 、 PasteText 、 SetSelection 、 CustomActions 、 PageUp …\n\n语义动作键，描述节点可执行操作\n\n辅助类与枚举\n\n类型\n\n关键字段\n\n用途\n\nSemanticsPropertyKey<T>\n\nname 、 mergePolicy 、 isImportantForAccessibility 、 merge()\n\n属性键基类，自定义语义需从此类派生\n\nAccessibilityAction<T>\n\nlabel 、 action\n\n标准无障碍操作容器\n\nCustomAccessibilityAction\n\nlabel 、 action\n\n自定义操作包装\n\nProgressBarRangeInfo\n\ncurrent 、 range 、 steps 、 Indeterminate\n\n描述可范围控件状态\n\nCollectionInfo\n\nrowCount 、 columnCount\n\n列表/表格信息\n\nCollectionItemInfo\n\nrowIndex 、 rowSpan 、 columnIndex 、 columnSpan\n\n子项网格范围\n\nScrollAxisRange\n\nvalue() 、 maxValue() 、 reverseScrolling\n\n滚动位置状态\n\nRole (value class)\n\nButton 、 Checkbox 、 Switch 、 RadioButton 、 Tab 、 Image 、 DropdownList\n\n控件角色声明\n\nLiveRegionMode (value class)\n\nPolite 、 Assertive\n\n实时区域播报模式\n\nSemanticsPropertyReceiver\n\nset(key, value)\n\nModifier.semantics 作用域写入接口\n\n3. 语义树树状结构\n\nSemanticsOwner └─ RootSemanticsNode (id=0) ├─ SemanticsNode(id=1) // 例如：Scaffold 根容器 │ ├─ SemanticsNode(id=2) // 顶部 AppBar │ │ ├─ SemanticsNode(id=5) │ │ │ • BoundsInWindow = [16,16 - 88,88] │ │ │ • Role = Button │ │ │ • ContentDescription = \"返回\" │ │ │ • SemanticsActions.OnClick │ │ │ • Focused = false │ │ │ • TraversalIndex = 0f │ │ └─ SemanticsNode(id=6) // 标题文本 (Text + ContentDescription) │ └─ SemanticsNode(id=3) // 页面主体内容 │ ├─ SemanticsNode(id=7) // 列表容器 (Scrollable) │ │ ├─ SemanticsNode(id=8) │ │ │ • BoundsInWindow = [0,144 - 1080,360] │ │ │ • CollectionItemInfo(rowIndex=0, columnIndex=0) │ │ │ • Text = \"列表项 1\" │ │ │ • ContentDescription = \"列表项 1\" │ │ │ • SemanticsActions.OnClick │ │ └─ SemanticsNode(id=9) // 列表项 2 │ └─ SemanticsNode(id=10) // 浮动按钮 (OnClick + Role.Button) └─ SemanticsNode(id=4) // 底部导航 ├─ SemanticsNode(id=11) // 导航项 A (Selected=true) └─ SemanticsNode(id=12) // 导航项 B\n\n4. 当前OHOS 平台桥接实现\n\n文件\n\n功能\n\n重点逻辑\n\nAccessibility.kt\n\nArkUI NDK 接口 Kotlin/Native 封装 ( setAccessibilityText 、 setOperationActions 等)\n\n简化 ArkUI 节点/事件构造\n\nSemanticsUtils.ohos.kt\n\n收集可见节点，计算 SemanticsNodeWithAdjustedBounds\n\n处理 fake node bounds、BFS 遍历\n\nAccessibilityMediator.ohos.kt\n\n将 SemanticsNode 转换为 ArkUI_AccessibilityElementInfo\n\n读取 SemanticsProperties ，设置文本、可见性、动作等\n\nArkUIXComponentAccessibility.ohos.kt\n\n注册 ArkUI_AccessibilityProviderCallbacks ，维护 SemanticsOwner → AccessibilityMediator 映射\n\n通过 OH_NativeXComponent_GetNativeAccessibilityProvider OH_NodeHandle_GetNativeAccessibilityProvider（6.1新增） 拿 provider，并转发回调\n\n5. OHOS 接口示例表\n\nKotlin 封装函数（示例）\n\n对应 ArkUI API\n\n说明\n\nArkUIAccessibilityElementInfo()\n\nOH_ArkUI_CreateAccessibilityElementInfo\n\n创建节点对象\n\ninfo.setComponentType(type)\n\nOH_ArkUI_AccessibilityElementInfoSetComponentType\n\n设置控件类型\n\ninfo.setChildNodeIds(count, ids)\n\nOH_ArkUI_AccessibilityElementInfoSetChildNodeIds\n\n注册子节点列表\n\ninfo.setOperationActions(actions)\n\nOH_ArkUI_AccessibilityElementInfoSetOperationActions\n\n绑定操作动作\n\ninfo.setScreenRect(rect)\n\nOH_ArkUI_AccessibilityElementInfoSetScreenRect\n\n设置屏幕区域\n\nevent.setEventType(type)\n\nOH_ArkUI_AccessibilityEventSetEventType\n\n指定事件类型\n\nevent.setTextAnnouncedForAccessibility(text)\n\nOH_ArkUI_AccessibilityEventSetTextAnnouncedForAccessibility\n\n设置播报文本\n\narguments[key]\n\nOH_ArkUI_FindAccessibilityActionArgumentByKey\n\n获取动作参数\n\n二、主要功能点\n\n1. 无障碍状态感知\n\n在 ComposeSceneMediator.ohos.kt 创建 SemanticsOwnerListenerImpl，其构造中向 ArkUI 注册 Provider 回调。系统开启无障碍后，ArkUI 才会调用这些回调（如 findAccessibilityNodeInfosById、executeAccessibilityAction），CMP 侧由此被动感知无障碍处于开启状态；关闭时相应回调也不会触发。\n\n如果需要“主动感知/订阅”无障碍开关，建议在 cinterop 层评估 ArkUI 是否提供状态监听或查询 API；没有的话，可通过系统设置观察者或在首次回调触发时设置启用标志，并按 Flutter 的做法在状态变更时节流/上报事件。\n\n2. 语义树对接\n\n2.1 监听 Compose 语义树\n\nComposeSceneMediator.ohos 在初始化时构造 SemanticsOwnerListenerImpl，并通过 PlatformContext 把它挂到 SemanticsOwner 上。\n\n每当 Compose 语义树发生变化（节点增删、属性更新），SemanticsOwnerListenerImpl.onSemanticsChange 会被调用，用于通知桥接层语义树需要刷新。\n\n代码位置：compose/ui/ui/src/ohosArm64Main/kotlin/androidx/compose/ui/scene/ComposeSceneMediator.ohos.kt、androidx/compose/ui/platform/accessibility/SemanticsOwnerListenerImpl.\n\n2.2 缓存并转换语义节点\n\n核心逻辑在 AccessibilityMediator.ohos.kt 中：\n\ngetAllHierarchicalTraversalSemanticsNodesToMap() 会把当前 SemanticsOwner 的树结构转换成一个 Map<Int, SemanticsNodeWithAdjustedBounds>，缓存所有节点（包括 bounds、子节点关系、语义属性）。\n\n当 ArkUI 发起查询时，AccessibilityMediator.createNodeInfo() 会拿到对应的 Compose SemanticsNode，并调用 SemanticsNode.populateArkUIAccessibilityElementInfo(info) 将其属性映射到 ArkUI 的 ArkUIAccessibilityElementInfo。\n\n重点映射包括：id、父子关系、屏幕坐标(rect)、文本/描述、角色、可见性、可用/选中状态，以及 SemanticsActions 转换成 ArkUI 的 Action 列表。\n\n代码位置：compose/ui/ui/src/ohosArm64Main/kotlin/androidx/compose/ui/platform/accessibility/AccessibilityMediator.ohos.kt.\n\n2.3 ArkUI Provider 回调\n\nSemanticsOwnerListenerImpl 构造时会调用 OH_NativeXComponent_GetNativeAccessibilityProvider 获取 ArkUI Provider，并使用 OH_ArkUI_AccessibilityProviderRegisterCallback 注册查询回调。\n\nArkUI 在 TalkBack 等服务请求语义树时，会触发诸如 findAccessibilityNodeInfosById 等回调；SemanticsOwnerListenerImpl 再把这些请求转给 AccessibilityMediator 处理，返回构建好的 ArkUIAccessibilityElementInfo。\n\nsequenceDiagram participant Compose as Compose 层 participant Semantics as SemanticsOwner/Node participant Mediator as AccessibilityMediator participant Provider as ArkUI_AccessibilityProvider participant ArkUI as ArkUI 无障碍服务 participant AT as 屏幕朗读 Compose->>Semantics: Modifier.semantics 写入配置 Semantics->>Mediator: onSemanticsChange() Mediator->>Provider: 填充 ArkUI 节点/事件 Provider->>ArkUI: send event / 注册回调 ArkUI->>Provider: findNode / performAction Provider->>Mediator: 调用 findAccessibilityNodeInfosById 等 Mediator->>Semantics: 查找 SemanticsNode 信息 Mediator-->>ArkUI: 返回节点/动作结果 ArkUI-->>AT: 播报、焦点移动、操作反馈\n\n3. 语义树更新\n\nCompose 语义节点更新时，通过 SemanticsOwner 通知监听器。\n\nSemanticsOwnerListenerImpl 标记 AccessibilityMediator 的语义缓存失效。\n\n当 ArkUI 发起查询回调，AccessibilityMediator 再次向 SemanticsOwner 获取最新语义树，生成 ArkUI_AccessibilityElementInfo 返回给 ArkUI，即实现“按需同步”。\n\nsequenceDiagram participant Compose as Compose UI 节点 participant SemanticsOwner as SemanticsOwner participant Listener as SemanticsOwnerListenerImpl participant Mediator as AccessibilityMediator participant ArkUI as ArkUI Provider 回调 Compose->>SemanticsOwner: 语义节点属性/子树发生变化 SemanticsOwner->>Listener: onSemanticsChange(semanticsOwner) Listener->>Mediator: 调用 onSemanticsChange()<br/>标记缓存失效 ArkUI->>Listener: 触发 findAccessibilityNodeInfosById 等回调 Listener->>Mediator: 转交 ArkUI 查询请求 Mediator->>SemanticsOwner: getAllHierarchicalTraversalSemanticsNodesToMap() SemanticsOwner-->>Mediator: 返回最新 SemanticsNode 映射 Mediator->>ArkUI: createNodeInfo() → 填充 ArkUI_AccessibilityElementInfo ArkUI-->>Listener: 返回查询结果 → 完成同步\n\n4. 事件分发\n\n状态监听\n\n在 AccessibilityMediator 或 SemanticsOwnerListenerImpl 中，除了标记节点缓存失效，还需要感知哪些语义属性发生了关键变化，如：\n\nSemanticsActions.OnClick 被触发 → 需要发送 CLICKED 事件。\n\n焦点切换（SemanticsProperties.Focused） → ACCESSIBILITY_FOCUSED 或 FOCUS_NODE_UPDATE。\n\n可滚动组件的滚动值变化（ScrollAxisRange） → SCROLLED。\n\n选中状态（Selected/ToggleableState）变化 → SELECTED。\n\n文本内容变更、光标位置变化等 → TEXT_UPDATE、SET_CURSOR_POSITION。\n\n事件构造\n\n结合 ArkUI NDK 接口，在 AccessibilityMediator 中新增事件分发逻辑：\n\n使用 OH_ArkUI_CreateAccessibilityEventInfo() 创建事件对象。\n\n填充 OH_ArkUI_AccessibilityEventSetElementInfo / SetEventType 等信息。\n\n若有附加数据（播报文本、请求焦点 id 等），补充对应字段。\n\n三、腾讯版本现状\n\n屏幕朗读功能\n\n支持部分控件播报（Button、Checkbox）；\n\n不支持事件传递；\n\n绿框绘制没有关联路由跳转；\n\n四、适配方向\n\n使用新接口OH_NodeHandle_GetNativeAccessibilityProvider（26年Q2）获取ArkUI_AccessibilityProvider实例；\n\n对接除了Button、Checkbox之外的语义树节点\n\n添加事件分发逻辑；\n\n融合渲染最新的实现是页面加载时RenderNode很少，没有特殊情况只有一个，需要考虑无障碍能否满足",
          "content_html": "<h1>Compose 语义系统梳理与 OHOS 无障碍适配</h1>\n<hr />\n<h1>一、Compose 语义系统梳理</h1>\n<h2>1. CMP公共语义模型概览</h2>\n<div class=\"doc-table-wrap\"><table class=\"doc-table\"><thead><tr><th>文件</th><th>核心职责</th><th>适配意义</th></tr></thead><tbody><tr><td>SemanticsConfiguration.kt</td><td>单节点语义配置容器，支持合并( mergeChild )与覆写( collapsePeer )策略</td><td>平台桥接层按配置生成原生节点数据</td></tr><tr><td>SemanticsProperties.kt</td><td>定义语义属性、动作及辅助类型（详见第 2 节）</td><td>统一属性/动作枚举，便于不同平台复用</td></tr><tr><td>SemanticsNode.kt</td><td>语义树节点结构（父子关系、bounds、 isFake 等）</td><td>平台遍历语义树的直接数据来源</td></tr><tr><td>SemanticsOwner.kt</td><td>语义树根节点管理，提供 onSemanticsChange 、 getAllSemanticsNodes</td><td>平台监听语义树变化</td></tr><tr><td>SemanticsModifier.kt</td><td>将 Modifier.semantics {} 中的设置写入 SemanticsConfiguration</td><td>业务层语义入口</td></tr><tr><td>SemanticKeys.kt</td><td>SemanticsPropertyKey 、 AccessibilityKey 等基础设施</td><td>规范自定义语义键</td></tr><tr><td>SemanticsSort.kt</td><td>节点排序工具（焦点顺序）</td><td>保证跨平台遍历一致性</td></tr></tbody></table></div>\n<hr />\n<h2>2. SemanticsProperties.kt 关键类型细化</h2>\n<div class=\"doc-table-wrap\"><table class=\"doc-table\"><thead><tr><th>类型/对象</th><th>代表成员</th><th>说明</th></tr></thead><tbody><tr><td>object SemanticsProperties</td><td>ContentDescription 、 Text 、 EditableText 、 Role 、 LiveRegion 、 TraversalIndex 、 CustomActions 等</td><td>所有语义属性键，默认通过 AccessibilityKey 定义合并策略</td></tr><tr><td>object SemanticsActions</td><td>OnClick 、 OnLongClick 、 ScrollBy 、 ScrollToIndex 、 SetText 、 CopyText 、 PasteText 、 SetSelection 、 CustomActions 、 PageUp …</td><td>语义动作键，描述节点可执行操作</td></tr><tr><td></td><td></td><td></td></tr></tbody></table></div>\n<h3>辅助类与枚举</h3>\n<div class=\"doc-table-wrap\"><table class=\"doc-table\"><thead><tr><th>类型</th><th>关键字段</th><th>用途</th></tr></thead><tbody><tr><td>SemanticsPropertyKey&lt;T&gt;</td><td>name 、 mergePolicy 、 isImportantForAccessibility 、 merge()</td><td>属性键基类，自定义语义需从此类派生</td></tr><tr><td>AccessibilityAction&lt;T&gt;</td><td>label 、 action</td><td>标准无障碍操作容器</td></tr><tr><td>CustomAccessibilityAction</td><td>label 、 action</td><td>自定义操作包装</td></tr><tr><td>ProgressBarRangeInfo</td><td>current 、 range 、 steps 、 Indeterminate</td><td>描述可范围控件状态</td></tr><tr><td>CollectionInfo</td><td>rowCount 、 columnCount</td><td>列表/表格信息</td></tr><tr><td>CollectionItemInfo</td><td>rowIndex 、 rowSpan 、 columnIndex 、 columnSpan</td><td>子项网格范围</td></tr><tr><td>ScrollAxisRange</td><td>value() 、 maxValue() 、 reverseScrolling</td><td>滚动位置状态</td></tr><tr><td>Role (value class)</td><td>Button 、 Checkbox 、 Switch 、 RadioButton 、 Tab 、 Image 、 DropdownList</td><td>控件角色声明</td></tr><tr><td>LiveRegionMode (value class)</td><td>Polite 、 Assertive</td><td>实时区域播报模式</td></tr><tr><td>SemanticsPropertyReceiver</td><td>set(key, value)</td><td>Modifier.semantics 作用域写入接口</td></tr></tbody></table></div>\n<hr />\n<h2>3. 语义树树状结构</h2>\n<pre><code>SemanticsOwner\n└─ RootSemanticsNode (id=0)\n├─ SemanticsNode(id=1) // 例如：Scaffold 根容器\n│ ├─ SemanticsNode(id=2) // 顶部 AppBar\n│ │ ├─ SemanticsNode(id=5)\n│ │ │ • BoundsInWindow = [16,16 - 88,88]\n│ │ │ • Role = Button\n│ │ │ • ContentDescription = \"返回\"\n│ │ │ • SemanticsActions.OnClick\n│ │ │ • Focused = false\n│ │ │ • TraversalIndex = 0f\n│ │ └─ SemanticsNode(id=6) // 标题文本 (Text + ContentDescription)\n│ └─ SemanticsNode(id=3) // 页面主体内容\n│ ├─ SemanticsNode(id=7) // 列表容器 (Scrollable)\n│ │ ├─ SemanticsNode(id=8)\n│ │ │ • BoundsInWindow = [0,144 - 1080,360]\n│ │ │ • CollectionItemInfo(rowIndex=0, columnIndex=0)\n│ │ │ • Text = \"列表项 1\"\n│ │ │ • ContentDescription = \"列表项 1\"\n│ │ │ • SemanticsActions.OnClick\n│ │ └─ SemanticsNode(id=9) // 列表项 2\n│ └─ SemanticsNode(id=10) // 浮动按钮 (OnClick + Role.Button)\n└─ SemanticsNode(id=4) // 底部导航\n├─ SemanticsNode(id=11) // 导航项 A (Selected=true)\n└─ SemanticsNode(id=12) // 导航项 B</code></pre>\n<hr />\n<h2>4. 当前OHOS 平台桥接实现</h2>\n<div class=\"doc-table-wrap\"><table class=\"doc-table\"><thead><tr><th>文件</th><th>功能</th><th>重点逻辑</th></tr></thead><tbody><tr><td>Accessibility.kt</td><td>ArkUI NDK 接口 Kotlin/Native 封装 ( setAccessibilityText 、 setOperationActions 等)</td><td>简化 ArkUI 节点/事件构造</td></tr><tr><td>SemanticsUtils.ohos.kt</td><td>收集可见节点，计算 SemanticsNodeWithAdjustedBounds</td><td>处理 fake node bounds、BFS 遍历</td></tr><tr><td>AccessibilityMediator.ohos.kt</td><td>将 SemanticsNode 转换为 ArkUI_AccessibilityElementInfo</td><td>读取 SemanticsProperties ，设置文本、可见性、动作等</td></tr><tr><td>ArkUIXComponentAccessibility.ohos.kt</td><td>注册 ArkUI_AccessibilityProviderCallbacks ，维护 SemanticsOwner → AccessibilityMediator 映射</td><td>通过 OH_NativeXComponent_GetNativeAccessibilityProvider OH_NodeHandle_GetNativeAccessibilityProvider（6.1新增） 拿 provider，并转发回调</td></tr></tbody></table></div>\n<hr />\n<h2>5. OHOS 接口示例表</h2>\n<div class=\"doc-table-wrap\"><table class=\"doc-table\"><thead><tr><th>Kotlin 封装函数（示例）</th><th>对应 ArkUI API</th><th>说明</th></tr></thead><tbody><tr><td>ArkUIAccessibilityElementInfo()</td><td>OH_ArkUI_CreateAccessibilityElementInfo</td><td>创建节点对象</td></tr><tr><td>info.setComponentType(type)</td><td>OH_ArkUI_AccessibilityElementInfoSetComponentType</td><td>设置控件类型</td></tr><tr><td>info.setChildNodeIds(count, ids)</td><td>OH_ArkUI_AccessibilityElementInfoSetChildNodeIds</td><td>注册子节点列表</td></tr><tr><td>info.setOperationActions(actions)</td><td>OH_ArkUI_AccessibilityElementInfoSetOperationActions</td><td>绑定操作动作</td></tr><tr><td>info.setScreenRect(rect)</td><td>OH_ArkUI_AccessibilityElementInfoSetScreenRect</td><td>设置屏幕区域</td></tr><tr><td>event.setEventType(type)</td><td>OH_ArkUI_AccessibilityEventSetEventType</td><td>指定事件类型</td></tr><tr><td>event.setTextAnnouncedForAccessibility(text)</td><td>OH_ArkUI_AccessibilityEventSetTextAnnouncedForAccessibility</td><td>设置播报文本</td></tr><tr><td>arguments[key]</td><td>OH_ArkUI_FindAccessibilityActionArgumentByKey</td><td>获取动作参数</td></tr></tbody></table></div>\n<hr />\n<h1>二、主要功能点</h1>\n<h2>1. 无障碍状态感知</h2>\n<p>在 ComposeSceneMediator.ohos.kt 创建 SemanticsOwnerListenerImpl，其构造中向 ArkUI 注册 Provider 回调。系统开启无障碍后，ArkUI 才会调用这些回调（如 findAccessibilityNodeInfosById、executeAccessibilityAction），CMP 侧由此被动感知无障碍处于开启状态；关闭时相应回调也不会触发。</p>\n<p>如果需要“主动感知/订阅”无障碍开关，建议在 cinterop 层评估 ArkUI 是否提供状态监听或查询 API；没有的话，可通过系统设置观察者或在首次回调触发时设置启用标志，并按 Flutter 的做法在状态变更时节流/上报事件。</p>\n<h2>2. 语义树对接</h2>\n<p>2.1 监听 Compose 语义树</p>\n<ul>\n<li>ComposeSceneMediator.ohos 在初始化时构造 SemanticsOwnerListenerImpl，并通过 PlatformContext 把它挂到 SemanticsOwner 上。</li>\n<li>每当 Compose 语义树发生变化（节点增删、属性更新），SemanticsOwnerListenerImpl.onSemanticsChange 会被调用，用于通知桥接层语义树需要刷新。</li>\n</ul>\n<p>代码位置：compose/ui/ui/src/ohosArm64Main/kotlin/androidx/compose/ui/scene/ComposeSceneMediator.ohos.kt、androidx/compose/ui/platform/accessibility/SemanticsOwnerListenerImpl.</p>\n<p>2.2 缓存并转换语义节点</p>\n<ul>\n<li>核心逻辑在 AccessibilityMediator.ohos.kt 中：</li>\n<li>getAllHierarchicalTraversalSemanticsNodesToMap() 会把当前 SemanticsOwner 的树结构转换成一个 Map&lt;Int, SemanticsNodeWithAdjustedBounds&gt;，缓存所有节点（包括 bounds、子节点关系、语义属性）。</li>\n<li>当 ArkUI 发起查询时，AccessibilityMediator.createNodeInfo() 会拿到对应的 Compose SemanticsNode，并调用 SemanticsNode.populateArkUIAccessibilityElementInfo(info) 将其属性映射到 ArkUI 的 ArkUIAccessibilityElementInfo。</li>\n</ul>\n<p>重点映射包括：id、父子关系、屏幕坐标(rect)、文本/描述、角色、可见性、可用/选中状态，以及 SemanticsActions 转换成 ArkUI 的 Action 列表。</p>\n<p>代码位置：compose/ui/ui/src/ohosArm64Main/kotlin/androidx/compose/ui/platform/accessibility/AccessibilityMediator.ohos.kt.</p>\n<p>2.3 ArkUI Provider 回调</p>\n<ul>\n<li>SemanticsOwnerListenerImpl 构造时会调用 OH_NativeXComponent_GetNativeAccessibilityProvider 获取 ArkUI Provider，并使用 OH_ArkUI_AccessibilityProviderRegisterCallback 注册查询回调。</li>\n<li>ArkUI 在 TalkBack 等服务请求语义树时，会触发诸如 findAccessibilityNodeInfosById 等回调；SemanticsOwnerListenerImpl 再把这些请求转给 AccessibilityMediator 处理，返回构建好的 ArkUIAccessibilityElementInfo。</li>\n</ul>\n<pre><code>sequenceDiagram\nparticipant Compose as Compose 层\nparticipant Semantics as SemanticsOwner/Node\nparticipant Mediator as AccessibilityMediator\nparticipant Provider as ArkUI_AccessibilityProvider\nparticipant ArkUI as ArkUI 无障碍服务\nparticipant AT as 屏幕朗读\nCompose-&gt;&gt;Semantics: Modifier.semantics 写入配置\nSemantics-&gt;&gt;Mediator: onSemanticsChange()\nMediator-&gt;&gt;Provider: 填充 ArkUI 节点/事件\nProvider-&gt;&gt;ArkUI: send event / 注册回调\nArkUI-&gt;&gt;Provider: findNode / performAction\nProvider-&gt;&gt;Mediator: 调用 findAccessibilityNodeInfosById 等\nMediator-&gt;&gt;Semantics: 查找 SemanticsNode 信息\nMediator--&gt;&gt;ArkUI: 返回节点/动作结果\nArkUI--&gt;&gt;AT: 播报、焦点移动、操作反馈</code></pre>\n<h2>3. 语义树更新</h2>\n<ul>\n<li>Compose 语义节点更新时，通过 SemanticsOwner 通知监听器。</li>\n<li>SemanticsOwnerListenerImpl 标记 AccessibilityMediator 的语义缓存失效。</li>\n<li>当 ArkUI 发起查询回调，AccessibilityMediator 再次向 SemanticsOwner 获取最新语义树，生成 ArkUI_AccessibilityElementInfo 返回给 ArkUI，即实现“按需同步”。</li>\n</ul>\n<pre><code>sequenceDiagram\nparticipant Compose as Compose UI 节点\nparticipant SemanticsOwner as SemanticsOwner\nparticipant Listener as SemanticsOwnerListenerImpl\nparticipant Mediator as AccessibilityMediator\nparticipant ArkUI as ArkUI Provider 回调\nCompose-&gt;&gt;SemanticsOwner: 语义节点属性/子树发生变化\nSemanticsOwner-&gt;&gt;Listener: onSemanticsChange(semanticsOwner)\nListener-&gt;&gt;Mediator: 调用 onSemanticsChange()&lt;br/&gt;标记缓存失效\nArkUI-&gt;&gt;Listener: 触发 findAccessibilityNodeInfosById 等回调\nListener-&gt;&gt;Mediator: 转交 ArkUI 查询请求\nMediator-&gt;&gt;SemanticsOwner: getAllHierarchicalTraversalSemanticsNodesToMap()\nSemanticsOwner--&gt;&gt;Mediator: 返回最新 SemanticsNode 映射\nMediator-&gt;&gt;ArkUI: createNodeInfo() → 填充 ArkUI_AccessibilityElementInfo\nArkUI--&gt;&gt;Listener: 返回查询结果 → 完成同步</code></pre>\n<h2>4. 事件分发</h2>\n<ol>\n<li><strong>状态监听</strong></li>\n</ol>\n<p>在 AccessibilityMediator 或 SemanticsOwnerListenerImpl 中，除了标记节点缓存失效，还需要感知哪些语义属性发生了关键变化，如：</p>\n<ul>\n<li>SemanticsActions.OnClick 被触发 → 需要发送 CLICKED 事件。</li>\n<li>焦点切换（SemanticsProperties.Focused） → ACCESSIBILITY_FOCUSED 或 FOCUS_NODE_UPDATE。</li>\n<li>可滚动组件的滚动值变化（ScrollAxisRange） → SCROLLED。</li>\n<li>选中状态（Selected/ToggleableState）变化 → SELECTED。</li>\n<li>文本内容变更、光标位置变化等 → TEXT_UPDATE、SET_CURSOR_POSITION。</li>\n</ul>\n<ol>\n<li><strong>事件构造</strong></li>\n</ol>\n<p>结合 ArkUI NDK 接口，在 AccessibilityMediator 中新增事件分发逻辑：</p>\n<ul>\n<li>使用 OH_ArkUI_CreateAccessibilityEventInfo() 创建事件对象。</li>\n<li>填充 OH_ArkUI_AccessibilityEventSetElementInfo / SetEventType 等信息。</li>\n<li>若有附加数据（播报文本、请求焦点 id 等），补充对应字段。</li>\n</ul>\n<h1>三、腾讯版本现状</h1>\n<p>屏幕朗读功能</p>\n<ol>\n<li>支持部分控件播报（Button、Checkbox）；</li>\n<li>不支持事件传递；</li>\n<li>绿框绘制没有关联路由跳转；</li>\n</ol>\n<h1>四、适配方向</h1>\n<ol>\n<li>使用新接口OH_NodeHandle_GetNativeAccessibilityProvider（26年Q2）获取ArkUI_AccessibilityProvider实例；</li>\n<li>对接除了Button、Checkbox之外的语义树节点</li>\n<li>添加事件分发逻辑；</li>\n<li>融合渲染最新的实现是页面加载时RenderNode很少，没有特殊情况只有一个，需要考虑无障碍能否满足</li>\n</ol>"
        }
      ],
      "estimated_minutes": 25
    },
    {
      "module_id": "cmp-for-ohos-cc7f01f0",
      "title": "CMP For OHOS知识地图",
      "source_path": "principle-analysis/CMP For OHOS知识地图.xmind",
      "source_file_hash": "cc7f01f0195f78bb9a0abd18f6100c659d3c8094",
      "split_mode": "auto",
      "render_version": 11,
      "difficulty": 2,
      "summary": "导图原图展示。",
      "sections": [
        {
          "section_id": "fe96798679",
          "title": "CMP For OHOS知识地图",
          "summary": "导图原图展示。",
          "key_points": [],
          "estimated_minutes": 2,
          "content": "# CMP For OHOS知识地图\n\n来源工作表: 知识地图\n\n导图原图展示。",
          "content_html": "<figure class=\"doc-figure xmind-figure\"><img src=\"../knowledge-map-assets/cmp-for-ohos-cc7f01f0-xmind-map-45e67b81d5.svg\" alt=\"CMP For OHOS知识地图 导图\" loading=\"lazy\" referrerpolicy=\"no-referrer\" data-origin-src=\"../knowledge-map-assets/cmp-for-ohos-cc7f01f0-xmind-map-45e67b81d5.svg\" /><figcaption>CMP For OHOS知识地图（导图图片）</figcaption></figure>"
        }
      ],
      "estimated_minutes": 2
    },
    {
      "module_id": "demo-3ef46c0b",
      "title": "融合渲染demo打通流程",
      "source_path": "environment-setup/融合渲染demo打通流程.docx",
      "source_file_hash": "3ef46c0baa6fe6f31bf8dd4d1b2ae0f6b4e85f03",
      "split_mode": "auto",
      "render_version": 11,
      "difficulty": 2,
      "summary": "融合渲染demo打通流程 本文档侧重于OHRender系列工程的构建，通用的可以参考 CMP相关产物依赖层级关系 CMP产物列表 注1：以下项目均从git上拉取 不使用本地仓...",
      "sections": [
        {
          "section_id": "8c422a8dcf",
          "title": "融合渲染demo打通流程",
          "summary": "融合渲染demo打通流程 本文档侧重于OHRender系列工程的构建，通用的可以参考 CMP相关产物依赖层级关系 CMP产物列表 注1：以下项目均从git上拉取 不使用本地仓...",
          "key_points": [
            "融合渲染demo打通流程",
            "本文档侧重于OHRender系列工程的构建，通用的可以参考 CMP相关产物依赖层级关系",
            "CMP产物列表",
            "注1：以下项目均从git上拉取 不使用本地仓库"
          ],
          "estimated_minutes": 15,
          "content": "融合渲染demo打通流程\n\n本文档侧重于OHRender系列工程的构建，通用的可以参考 CMP相关产物依赖层级关系\n\nCMP产物列表\n\n注1：以下项目均从git上拉取 不使用本地仓库\n\n注2：以下操作均在Mac上进行\n\n注3：追加以下环境变量到~/.zshrc文件，比如\n\nexport JAVA_HOME=\"/Library/Java/JavaVirtualMachines/zulu-17.jdk/Contents/Home\" export ANDROID_HOME=/Users/ohos/Library/Android/sdk export PATH=\"/Applications/DevEco-Studio.app/Contents/sdk/default/openharmony/toolchains:$PATH\"\n\n主体流程\n\nOHRender\n\ngit clone https://gitcode.com/gaodisec/OHRender.git\n\nclone到本地留到第2步使用，应用此pacth确保编译可以通过\n\ngit apply 添加本地_expat_依赖.patch （patch是附件txt，下载到工程同级目录，文件后缀需要改成.patch）\n\n添加本地_expat_依赖.txt\n\nSkiko_OHRender\n\ngit clone https://gitcode.com/wangxhhh/skiko-ohrender.git\n\n修改点：\n\n/Users/huawei/DevEcoStudioProjects/skiko-ohrender/skiko/build-with-local-skia.sh\n\n大概 90行位置的gradle 命令需要修改Pskia.dir参数为自己本地的OHRender仓库\n\nPS：OHRender有两层，需要设置为内层OHRender目录！！！\n\n控制台执行bash\n\n${skiko-ohrender工程路径}/skiko/build-with-local-skia.sh\n\n产物路径：～/.m2/repository/org/jetbrains/skiko/skiko-ohosarm64/0.7.97-WXH-002\n\nkotlinx.atomicfu\n\ngit clone https://github.com/Kotlin/kotlinx.atomicfu.git cd kotlinx.atomicfu git checkout -b v0.23.2 0.23.2 git apply ../atomicfu_本地修改.patch （patch是附件txt，下载到工程同级目录，文件后缀需要改成.patch）\n\natomicfu_本地修改.txt\n\n应用patch之后执行\n\n./gradlew publish\n\n发布本地kotlinx.atomicfu版本供 ovCompose-multiplatform-core-ohrender仓库依 赖调用\n\n产物路径：/Users/huawei/.m2/repository/org/jetbrains/kotlinx/atomicfu一系列\n\novCompose-multiplatform-core-ohrender\n\ngit clone https://gitcode.com/wangxhhh/ovCompose-multiplatform-core-ohrender.git\n\n修改点：\n\n${ovCompose-multiplatform-core-ohrender工程路径}/gradle.properties\n\n注释或删除kotlin.native.home字段\n\n${ovCompose-multiplatform-core-ohrender工程路径}/gradle/libs.versions.toml\n\n修改kotlinNative和kotlin依赖的版本为腾讯已经发布的依赖2.0.21-KBA-001\n\n确认kotlinx.atomicfu产物编完之后回到ovCompose-multiplatform-core-ohrender看情况修改/Users/huawei/DevEcoStudioProjects/ovCompose-multiplatform-core-ohrender/gradle/libs.versions.toml中的atomicFu依赖版本，与本地构建版本一致\n\n控制台执行命令\n\n./gradlew :mpp:publishComposeJbToMavenLocal -Pcompose.platforms=android,ohosArm64\n\n发布本地版本\n\n发布成功之后接着使用 DevEco-Studio 打开 `compose/ui/ui-arkui/src/ohosArm64Main/cpp/composeApp` 目录下的 composeApp 项目，控制台执行命令生成compose.har包。\n\n/Applications/DevEco-Studio.app/Contents/tools/hvigor/bin/hvigorw --mode module -p product -p module=compose assembleHar\n\n成功后显示BUILD SUCCESSFUL\n\ncompose-multiplatform\n\nclone JetBrains/compose-multiplatform仓库代码，并切到e8459e19\n\ngit clone \\tdfe -10 \\tdlt text \\tdlf FromInput \\tdsub normalLink \\tdkey pv5d8x \\https://github.com/JetBrains/compose-multiplatform.git cd compose-multiplatform git checkout e8459e19\n\n使用此patchcompose-multiplatform适配.txt\n\ngit apply ../compose-multiplatform适配.patch （patch是附件txt，下载到工程同级目录，文件后缀需要改成.patch）\n\nPS：直接执行apply命令控制台返回存在warning但是可以不用理会，不会对结果造成影响\n\n添加ANDROID_HOME\n\nexport ANDROID_HOME=$HOME/Library/Android/sdk\n\n修改compose/scripts目录下的，publishComponentsToMavenLocal、publishGradlePluginToMavenLocal两个文件，在cd \"$(dirname \"$0\")\"下一行增加一行代码\n\nCOMPOSE_CUSTOM_VERSION=1.6.1-dev-wxh\n\n编译命令，注意需要按顺序执行（components依赖gradleplugin）\n\n./compose/scripts/publishGradlePluginToMavenLocal ./compose/scripts/publishComponentsToMavenLocal\n\novCompose-sample-ohrender\n\ngit clone https://gitcode.com/wangxhhh/ovCompose-sample-ohrender.git\n\n复制ovCompose-multiplatform-core仓编译的compose.har到项目harmonyApp/entry/libs目录下\n\n编译compose.har成功之后在\n\n/Users/huawei/DevEcoStudioProjects/ovCompose-multiplatform-core-ohrender/compose/ui/ui-arkui/src/ohosArm64Main/cpp/compose/build/default/outputs/default/compose.har获取产物，替换ovCompose-sample-ohrender工程路径中的\n\n/Users/huawei/DevEcoStudioProjects/ovCompose-sample-ohrender/harmonyApp/entry/libs/compose.har\n\ncp ../ovCompose-multiplatform-core-ohrender/compose/ui/ui-arkui/src/ohosArm64Main/cpp/compose/build/default/outputs/default/compose.har harmonyApp/entry/libs\n\n替换compose.har之后一定要删除旧的ohmodule目录并且重新同步harmony工程！！！\n\n修改gradle.properties，注释或删除kotlin.native.home字段\n\nkotlin = \"2.0.21-KBA-001\"\n\n编译命令，此命令会有两个产物，libkn.so和libkn_api.h，并且复制到对应目录下\n\n./gradlew publishReleaseBinariesToHarmonyApp\n\n之后签名编译entry退包查看sample demo的组件树，如果不存在XComponent节点则使用OHRender 渲染的demo验证成功\n\n踩坑点\n\n缺少依赖\n\nkotlin-native-prebuilt-2.0.21-KBA-001-macos-x86_64.tar.gz\n\n根因：使用了zulu官网下载jdk zulu17，名称带有macosx_x64字样\n\n导致gradle脚本运行拼接插件拼错去找，此文件在腾讯库中不存在\n\n办法：使用brew install zulu@17命令安装jdk，配置JAVA_HOME环境变量路径为/Library/Java/JavaVirtualMachines/zulu-17.jdk/Contents/Home\n\n缺少java8\n\n办法：\n\n如果没有本地没有java8，通过此命令安装\n\nbrew install corretto@8\n\n报错修改\n\n执行命令/Applications/DevEco-Studio.app/Contents/tools/hvigor/bin/hvigorw --mode module -p product -p module=compose assembleHar\n\n若出现以下报错\n\n需要在终端打开新窗口后再执行命令/Applications/DevEco-Studio.app/Contents/tools/hvigor/bin/hvigorw --mode module -p product -p module=compose assembleHar\n\n执行命令后出现如下报错：\n\n解决方法如下需要删除指定内容：\n\n删除后的内容应为：\n\nSDK location not found问题\n\n解决办法：在 compose-multiplatform/components 目录下创建 local.properties 文件，然后在该文件中添加如下内容（将路径替换为你实际的 Android SDK 存放路径）：sdk.dir=/Users/z30079976/Desktop/android\n\nPlease check signingConfigs in root project file 签名问题\n\n解决办法：找到项目中的 build-profile.json5 文件，将其中 signingConfigs 相关的内容删除，确保文件中不再包含签名配置相关的条目。\n\n关系图",
          "content_html": "<h1>融合渲染demo打通流程</h1>\n<p>本文档侧重于OHRender系列工程的构建，通用的可以参考<br/>CMP相关产物依赖层级关系</p>\n<p>CMP产物列表</p>\n<p>注1：以下项目均从git上拉取 不使用本地仓库</p>\n<p>注2：以下操作均在Mac上进行&emsp;</p>\n<p>注3：追加以下环境变量到~<em>/.zshrc</em><em>文件，比如</em></p>\n<figure class=\"doc-figure\"><img src=\"../knowledge-map-assets/demo-3ef46c0b-dbbe12307f.png\" alt=\"融合渲染demo打通流程 图示\" /></figure>\n<hr />\n<pre><code>export JAVA_HOME=\"/Library/Java/JavaVirtualMachines/zulu-17.jdk/Contents/Home\"\nexport ANDROID_HOME=/Users/ohos/Library/Android/sdk\nexport PATH=\"/Applications/DevEco-Studio.app/Contents/sdk/default/openharmony/toolchains:$PATH\"</code></pre>\n<h1>主体流程</h1>\n<ol>\n<li>OHRender</li>\n</ol>\n<pre><code>git clone https://gitcode.com/gaodisec/OHRender.git</code></pre>\n<p>clone到本地留到第2步使用，应用此pacth确保编译可以通过</p>\n<pre><code>git apply 添加本地_expat_依赖.patch\n（patch是附件txt，下载到工程同级目录，文件后缀需要改成.patch）</code></pre>\n<p>添加本地_expat_依赖.txt</p>\n<ol>\n<li>Skiko_OHRender</li>\n</ol>\n<pre><code>git clone https://gitcode.com/wangxhhh/skiko-ohrender.git</code></pre>\n<p>修改点：</p>\n<p><em>/Users/huawei/DevEcoStudioProjects/skiko-ohrender/skiko/</em><em>build-with-local-skia.sh</em></p>\n<p><em>大概 90行位置的gradle 命令需要修改</em><em>Pskia.dir</em><em>参数为自己本地的OHRender仓库</em></p>\n<p><em>PS：OHRender有两层，需要设置为内层OHRender目录！！！</em></p>\n<figure class=\"doc-figure\"><img src=\"../knowledge-map-assets/demo-3ef46c0b-39c46b2cf8.png\" alt=\"融合渲染demo打通流程 图示\" /></figure>\n<p><em>控制台执行</em><em>bash</em><em> </em></p>\n<p><em>$</em><em>{</em><em>skiko-ohrender</em><em>工程路径}</em><em>/skik</em><em>o/build-with-local-skia.sh</em></p>\n<p><em>产物路径：</em><em>～</em><em>/.m2/repository/org/jetbrains/skiko/skiko-ohosarm64/</em><em>0.7.97-WXH-002</em></p>\n<hr />\n<figure class=\"doc-figure\"><img src=\"../knowledge-map-assets/demo-3ef46c0b-8b8808fe6a.png\" alt=\"融合渲染demo打通流程 图示\" /></figure>\n<ol>\n<li>kotlinx.atomicfu</li>\n</ol>\n<pre><code>git clone https://github.com/Kotlin/kotlinx.atomicfu.git\ncd kotlinx.atomicfu\ngit checkout -b v0.23.2 0.23.2\ngit apply ../atomicfu_本地修改.patch\n（patch是附件txt，下载到工程同级目录，文件后缀需要改成.patch）</code></pre>\n<ul>\n<li><em>atomicfu_本地修改.txt</em></li>\n<li><em>应用patch之后执行</em></li>\n</ul>\n<pre><code>./gradlew publish</code></pre>\n<ul>\n<li><em>发布本地kotlinx.atomicfu版本供 </em><em>ovCompose-multiplatform-core-ohrender</em><em>仓库</em><em>依</em><em>&emsp;</em><em>赖</em><em>调用</em></li>\n<li><em>产物路径：</em><em>/Users/huawei/.m2/repository/org/jetbrains/kotlinx/atomicfu</em><em>一系列</em></li>\n</ul>\n<hr />\n<figure class=\"doc-figure\"><img src=\"../knowledge-map-assets/demo-3ef46c0b-71a66e5d1c.png\" alt=\"融合渲染demo打通流程 图示\" /></figure>\n<ol>\n<li>ovCompose-multiplatform-core-ohrender</li>\n</ol>\n<pre><code>git clone https://gitcode.com/wangxhhh/ovCompose-multiplatform-core-ohrender.git</code></pre>\n<ul>\n<li><em>修改点：</em></li>\n<li><em>${</em><em>ovCompose-multiplatform-core-ohrender</em><em>工程路径}</em><em>/gradle.properties</em></li>\n<li><em>注释或删除</em><em>kotlin.native.home</em><em>字段</em></li>\n<li><em>${</em><em>ovCompose-multiplatform-core-ohrender</em><em>工程路径}</em><em>/gradle/libs.versions.toml</em></li>\n<li><em>修改</em><em>kotlinNative</em><em>和</em><em>kotlin</em><em>依赖的版本为腾讯已经发布的依赖</em><em>2.0.21-KBA-001</em></li>\n</ul>\n<figure class=\"doc-figure\"><img src=\"../knowledge-map-assets/demo-3ef46c0b-c22f66af96.png\" alt=\"融合渲染demo打通流程 图示\" /></figure>\n<p><em>确认kotlinx.atomicfu产物编完之后回到</em><em>ovCompose-multiplatform-core-ohrender</em><em>看情况修改</em><em>/Users/huawei/DevEcoStudioProjects/ovCompose-multiplatform-core-ohrender/gradle/libs.versions.tom</em><em>l中的atomicFu依赖版本，与本地构建版本一致</em></p>\n<hr />\n<figure class=\"doc-figure\"><img src=\"../knowledge-map-assets/demo-3ef46c0b-9f1cfa4ea3.png\" alt=\"融合渲染demo打通流程 图示\" /></figure>\n<p><em>控制台执行命令</em></p>\n<pre><code>./gradlew :mpp:publishComposeJbToMavenLocal -Pcompose.platforms=android,ohosArm64</code></pre>\n<p><em>发布本地版本</em></p>\n<figure class=\"doc-figure\"><img src=\"../knowledge-map-assets/demo-3ef46c0b-55694b1858.png\" alt=\"融合渲染demo打通流程 图示\" /></figure>\n<p><em>发布成功之后接着使用 DevEco-Studio 打开 `compose/ui/ui-arkui/src/ohosArm64Main/cpp/composeApp` 目录下的 composeApp 项目，控制台执行命令</em><em>生成compose.har包。</em></p>\n<hr />\n<pre><code>/Applications/DevEco-Studio.app/Contents/tools/hvigor/bin/hvigorw --mode module -p product -p module=compose assembleHar</code></pre>\n<p><em>成功后显示BUILD SUCCESSFUL</em></p>\n<figure class=\"doc-figure\"><img src=\"../knowledge-map-assets/demo-3ef46c0b-6e14ee7916.png\" alt=\"融合渲染demo打通流程 图示\" /></figure>\n<ol>\n<li>compose-multiplatform</li>\n</ol>\n<ul>\n<li>clone <em>JetBrains/compose-multiplatform</em><em>仓库代码，并切到</em>e8459e19</li>\n</ul>\n<pre><code>git clone \\tdfe -10 \\tdlt text \\tdlf FromInput \\tdsub normalLink \\tdkey pv5d8x \\https://github.com/JetBrains/compose-multiplatform.git\ncd compose-multiplatform\ngit checkout e8459e19</code></pre>\n<ul>\n<li>使用此patchcompose-multiplatform适配.txt</li>\n</ul>\n<pre><code>git apply ../compose-multiplatform适配.patch\n（patch是附件txt，下载到工程同级目录，文件后缀需要改成.patch）</code></pre>\n<p>PS：直接执行apply命令控制台返回存在warning但是可以不用理会，不会对结果造成影响</p>\n<figure class=\"doc-figure\"><img src=\"../knowledge-map-assets/demo-3ef46c0b-8e406e33f8.png\" alt=\"融合渲染demo打通流程 图示\" /></figure>\n<ul>\n<li>添加ANDROID_HOME</li>\n</ul>\n<hr />\n<pre><code>export ANDROID_HOME=$HOME/Library/Android/sdk</code></pre>\n<ul>\n<li>修改<em>compose/scripts</em><em>目录下的，</em><em>publishComponentsToMavenLocal、publishGradlePluginToMavenLocal</em><em>两</em><em>个文件，在</em><em>cd \"$(dirname \"$0\")\"</em><em>下一行增加一行代码</em></li>\n</ul>\n<p><em>COMPOSE_CUSTOM_VERSION=1.6.1-dev-wxh</em></p>\n<hr />\n<figure class=\"doc-figure\"><img src=\"../knowledge-map-assets/demo-3ef46c0b-ecc1305e9f.png\" alt=\"融合渲染demo打通流程 图示\" /></figure>\n<ul>\n<li>编译命令，注意需要按顺序执行（components依赖gradleplugin）</li>\n</ul>\n<hr />\n<pre><code>./compose/scripts/publishGradlePluginToMavenLocal\n./compose/scripts/publishComponentsToMavenLocal</code></pre>\n<ol>\n<li>ovCompose-sample-ohrender</li>\n</ol>\n<pre><code>git clone https://gitcode.com/wangxhhh/ovCompose-sample-ohrender.git</code></pre>\n<ul>\n<li>复制<em><strong>ovCompose-multiplatform-core</strong></em><em>仓编译的compose.har到项目</em><em>harmonyApp/entry/libs</em><em>目录下</em></li>\n<li><em>编译compose.har成功之后在</em></li>\n<li><em>/Users/huawei/DevEcoStudioProjects/ovCompose-multiplatform-core-ohrender/compose/ui/ui-arkui/src/ohosArm64Main/cpp/compose/build/default/outputs/default/</em><em>compose.har</em><em>获取产物，替换</em><em>ovCompose-sample-ohrender</em><em>工程路径中的</em></li>\n<li><em>/Users/huawei/DevEcoStudioProjects/ovCompose-sample-ohrender/harmonyApp/entry/libs/compose.har</em></li>\n</ul>\n<pre><code>cp ../ovCompose-multiplatform-core-ohrender/compose/ui/ui-arkui/src/ohosArm64Main/cpp/compose/build/default/outputs/default/compose.har harmonyApp/entry/libs</code></pre>\n<ul>\n<li><strong><code>替换compose.har之后</code></strong><strong><code>一定要删除旧的ohmodule</code></strong><strong><code>目录并且重新同步harmony工程</code></strong><strong><code>！！！</code></strong></li>\n<li><em>修改</em><em>gradle.properties</em><em>，</em><em>注释或删除</em><em>kotlin.native.home</em><em>字段</em></li>\n</ul>\n<hr />\n<figure class=\"doc-figure\"><img src=\"../knowledge-map-assets/demo-3ef46c0b-5b549b01b2.png\" alt=\"融合渲染demo打通流程 图示\" /></figure>\n<pre><code>kotlin = \"2.0.21-KBA-001\"</code></pre>\n<ul>\n<li>编译命令，此命令会有两个产物，libkn.so和libkn_api.h，并且复制到对应目录下</li>\n</ul>\n<hr />\n<pre><code>./gradlew publishReleaseBinariesToHarmonyApp</code></pre>\n<hr />\n<figure class=\"doc-figure\"><img src=\"../knowledge-map-assets/demo-3ef46c0b-9bb98a566f.png\" alt=\"融合渲染demo打通流程 图示\" /></figure>\n<p><em>之后签名编译entry退包查看sample demo的组件树，如果</em><em>不存在XComponent节点</em><em>则使用OHRender 渲染的demo验证成功</em></p>\n<hr />\n<figure class=\"doc-figure\"><img src=\"../knowledge-map-assets/demo-3ef46c0b-f6b3c260e1.png\" alt=\"融合渲染demo打通流程 图示\" /></figure>\n<h1>踩坑点</h1>\n<ol>\n<li>缺少依赖</li>\n</ol>\n<p>kotlin-native-prebuilt-2.0.21-KBA-001-macos-x86_64.tar.gz</p>\n<figure class=\"doc-figure\"><img src=\"../knowledge-map-assets/demo-3ef46c0b-ba32108396.png\" alt=\"融合渲染demo打通流程 图示\" /></figure>\n<ul>\n<li>根因：使用了zulu官网下载jdk zulu17，名称带有<em>macosx_x64</em><em>字样</em></li>\n</ul>\n<figure class=\"doc-figure\"><img src=\"../knowledge-map-assets/demo-3ef46c0b-d0ca59099b.png\" alt=\"融合渲染demo打通流程 图示\" /></figure>\n<p>导致gradle脚本运行拼接插件拼错去找<em>，此文件在腾讯库中不存在</em></p>\n<ul>\n<li><em>办法：使用brew install zulu@17命令安装jdk，配置</em><em>JAVA_HOM</em><em>E环境变量路径为</em><em>/Library/Java/JavaVirtualMachines/zulu-17.jdk/Contents/Home</em></li>\n</ul>\n<figure class=\"doc-figure\"><img src=\"../knowledge-map-assets/demo-3ef46c0b-0916793bb5.png\" alt=\"融合渲染demo打通流程 图示\" /></figure>\n<ol>\n<li>缺少java8</li>\n</ol>\n<figure class=\"doc-figure\"><img src=\"../knowledge-map-assets/demo-3ef46c0b-93f4ea09a0.png\" alt=\"融合渲染demo打通流程 图示\" /></figure>\n<ul>\n<li>办法：</li>\n</ul>\n<p>如果没有本地没有java8，通过此命令安装</p>\n<pre><code>brew install corretto@8</code></pre>\n<ol>\n<li>报错修改</li>\n</ol>\n<ul>\n<li><em>执行命令</em><code>/</code><code>Applications</code><code>/</code><code>DevEco</code><code>-</code><code>Studio.app</code><code>/</code><code>Contents</code><code>/</code><code>tools</code><code>/</code><code>hvigor</code><code>/</code><code>bin</code><code>/</code><code>hvigorw </code><code>--</code><code>mode </code>module<code> </code><code>-</code><code>p product </code><code>-</code><code>p </code>module<code>=</code><code>compose assembleHar</code></li>\n<li><em>若出现以下报错</em></li>\n</ul>\n<figure class=\"doc-figure\"><img src=\"../knowledge-map-assets/demo-3ef46c0b-cb6adfbf56.png\" alt=\"融合渲染demo打通流程 图示\" /></figure>\n<ul>\n<li><em>需要在终端打开新窗口后再执行命令</em><code>/</code><code>Applications</code><code>/</code><code>DevEco</code><code>-</code><code>Studio.app</code><code>/</code><code>Contents</code><code>/</code><code>tools</code><code>/</code><code>hvigor</code><code>/</code><code>bin</code><code>/</code><code>hvigorw </code><code>--</code><code>mode </code>module<code> </code><code>-</code><code>p product </code><code>-</code><code>p </code>module<code>=</code><code>compose assembleHar</code></li>\n</ul>\n<figure class=\"doc-figure\"><img src=\"../knowledge-map-assets/demo-3ef46c0b-a3eb84f8fc.png\" alt=\"融合渲染demo打通流程 图示\" /></figure>\n<ul>\n<li>执行命令后出现如下报错：</li>\n</ul>\n<figure class=\"doc-figure\"><img src=\"../knowledge-map-assets/demo-3ef46c0b-422fd453cc.png\" alt=\"融合渲染demo打通流程 图示\" /></figure>\n<ul>\n<li>解决方法如下需要删除指定内容：</li>\n</ul>\n<figure class=\"doc-figure\"><img src=\"../knowledge-map-assets/demo-3ef46c0b-dfc2640b88.png\" alt=\"融合渲染demo打通流程 图示\" /></figure>\n<ul>\n<li>删除后的内容应为：</li>\n</ul>\n<figure class=\"doc-figure\"><img src=\"../knowledge-map-assets/demo-3ef46c0b-a6f9922ebe.png\" alt=\"融合渲染demo打通流程 图示\" /></figure>\n<ol>\n<li>SDK location not found问题</li>\n</ol>\n<figure class=\"doc-figure\"><img src=\"../knowledge-map-assets/demo-3ef46c0b-a677c81399.png\" alt=\"融合渲染demo打通流程 图示\" /></figure>\n<p><em>解决办法</em><em>：</em><em>在 compose-multiplatform/components 目录下创建 local.properties 文件，然后在该文件中添加如下内容（将路径替换为你实际的 Android SDK 存放路径）：</em><em>sdk.dir=/Users/z30079976/Desktop/android</em><em>                                 </em></p>\n<ol>\n<li><em>Please check signingConfigs in root project file</em><em> </em>签名问题</li>\n</ol>\n<figure class=\"doc-figure\"><img src=\"../knowledge-map-assets/demo-3ef46c0b-7a441aeafb.png\" alt=\"融合渲染demo打通流程 图示\" /></figure>\n<p>解决办法：<em><strong>找到项目中的 </strong></em><em><strong>build-profile.json5</strong></em><em><strong> 文件，将其中 </strong></em><em><strong>signingConfigs</strong></em><em><strong> 相关的内容删除，确保文件中不再包含签名配置相关的条目。</strong></em></p>\n<figure class=\"doc-figure\"><img src=\"../knowledge-map-assets/demo-3ef46c0b-76f6d212a9.png\" alt=\"融合渲染demo打通流程 图示\" /></figure>\n<h1>关系<strong>图</strong></h1>\n<figure class=\"doc-figure\"><img src=\"../knowledge-map-assets/demo-3ef46c0b-04532908ef.png\" alt=\"融合渲染demo打通流程 图示\" /></figure>"
        }
      ],
      "estimated_minutes": 15
    },
    {
      "module_id": "ohrendernode-rendernodelayer-aae602d5",
      "title": "OHRenderNode 与 RenderNodeLayer 录制协作机制详解",
      "source_path": "principle-analysis/OHRenderNode 与 RenderNodeLayer 录制协作机制详解.docx",
      "source_file_hash": "aae602d59ccd19335f5bf330f6215ce5f82dd217",
      "split_mode": "auto",
      "render_version": 11,
      "difficulty": 3,
      "summary": "OHRenderNode 与 RenderNodeLayer 录制协作机制详解 本文档由浅入深地解析了 Root 节点（OHRenderNode::doRedraw）与 La...",
      "sections": [
        {
          "section_id": "8e74c3a13a",
          "title": "OHRenderNode 与 RenderNodeLayer 录制协作机制详解",
          "summary": "OHRenderNode 与 RenderNodeLayer 录制协作机制详解 本文档由浅入深地解析了 Root 节点（OHRenderNode::doRedraw）与 La...",
          "key_points": [
            "引言：渲染的双重循环",
            "宏观视角：导演与分镜",
            "录制流程详解",
            "核心协作机制：drawPicture 的双重含义"
          ],
          "estimated_minutes": 14,
          "content": "OHRenderNode 与 RenderNodeLayer 录制协作机制详解\n\n本文档由浅入深地解析了 Root 节点（OHRenderNode::doRedraw）与 Layer 节点（RenderNodeLayer）在录制流程中的关系与协作机制，并深入探讨了 Picture 缓存与节点树构建的本质。\n\n1. 引言：渲染的双重循环\n\n在融合渲染架构中，渲染并非一次性的线性过程，而是由两个层级的录制循环交织而成：\n\nRoot 循环：由 C++ 层的 OHRenderNode 驱动，负责构建整棵渲染树的主干。\n\nLayer 循环：由 Kotlin 层的 RenderNodeLayer 驱动，负责构建独立的子树。\n\n理解这两个循环如何通过 drawPicture 握手，是理解整个架构的关键。\n\n2. 宏观视角：导演与分镜\n\n如果把一帧画面的绘制比作拍摄一部电影：\n\nRoot (OHRenderNode::doRedraw) 是总导演。他负责掌控整部电影的拍摄流程，喊 \"Action\"（beginRecording）开始，喊 \"Cut\"（finishRecordingAsPicture）结束。\n\nLayer (RenderNodeLayer) 是第二摄制组（分镜导演）。当总导演拍到某个特效场景（比如需要独立透明度、裁剪或变换的组件）时，会把任务交给分镜导演。\n\n协作方式：分镜导演在一个独立的摄影棚里拍摄自己的片段（beginRecording -> draw -> finish），拍完后把胶卷（Picture）交给总导演。总导演把这段胶卷剪辑进主电影里（drawPicture）。\n\n3. 录制流程详解\n\n3.1 Root 的主战场：OHRenderNode::doRedraw\n\n在 C++ 层 (OHRenderNode.cpp)，Root 节点是整个渲染树的根，它驱动了每一帧的更新。\n\n核心流程：\n\n准备录制器材 (beginRecording)：创建一个 SkPictureRecorder，并调用 beginRecording 获取一个 SkCanvas。这个 Canvas 是“主画布”。\n\n发号施令 (fCallback)：调用 Kotlin/ArkTS 层的回调函数。这相当于告诉 Compose UI：“请把你们所有的 UI 组件都画到这个主画布上。”\n\n封箱存档 (finishRecordingAsPicture)：当 Kotlin 层画完所有内容后，调用 finishRecordingAsPicture。这会将刚才所有的绘制指令打包成一个 SkPicture（在本项目中，它实际上构建了一棵 OHRenderNode 树）。\n\n// OHRenderNode.cpp (简化伪代码) void OHRenderNode::doRedraw() { // 1. 开始录制，拿到主画布 SkCanvas* canvas = fRecorder->beginRecording(bounds); // 2. 调用 Kotlin 回调，遍历 Compose UI 树进行绘制 if (fCallback) { fCallback(canvas); } // 3. 结束录制，生成包含整个帧内容的 Picture fPicture = fRecorder->finishRecordingAsPicture(); }\n\n3.2 Layer 的独立行动：RenderNodeLayer\n\n在 Kotlin 层 (RenderNodeLayer.skiko.kt)，当 Compose 遇到 Modifier.graphicsLayer 时，会创建一个 RenderNodeLayer。它需要独立于父节点进行某些操作（如设置透明度、矩阵变换），因此它有自己的录制流程。\n\n核心流程：\n\n开启小灶 (beginRecording)：Layer 拥有自己的 pictureRecorder。它调用 beginRecording 创建一个临时的、独立的 Canvas。\n\n绘制子内容 (performDrawLayer)：Layer 将它的子组件（Children）绘制到这个独立的 Canvas 上，而不是直接画到 Root 的主画布上。\n\n打包成果 (finishRecordingAsPicture)：调用 finishRecordingAsPicture，将子组件的绘制结果打包成一个子 Picture。\n\n上交作业 (drawPicture) —— 关键协作点：Layer 拿到子 Picture 后，立即调用 父 Canvas（即 Root 传下来的那个 Canvas）的 drawPicture 方法。\n\n// RenderNodeLayer.skiko.kt (简化伪代码) override fun drawLayer(canvas: Canvas) { // 1. 开启子录制，拿到子画布 val layerCanvas = pictureRecorder.beginRecording(bounds) // 2. 在子画布上绘制子组件 drawChildren(layerCanvas) // 3. 结束子录制，生成子 Picture val layerPicture = pictureRecorder.finishRecordingAsPicture() // 4. 【关键】将子 Picture 画到父 Canvas 上 canvas.drawPicture(layerPicture) }\n\n4. 核心协作机制：drawPicture 的双重含义\n\n它们是如何协作的？秘密就在于 canvas.drawPicture(layerPicture)。\n\n在普通的 Skia 渲染中，drawPicture 只是把像素画上去。但在本项目的融合渲染架构中（基于 OHRenderNode），SkPictureRecorder 被赋予了特殊的含义：构建节点树。\n\nRoot 录制时：它正在构建一棵 C++ 的 OHRenderNode 树的主干。\n\nLayer 录制时：它构建了一棵子树（Sub-tree）。\n\ndrawPicture 时：\n\nKotlin 层调用 canvas.drawPicture(layerPicture)。\n\nC++ 层拦截到这个指令。\n\n它不会立即光栅化像素，而是将 layerPicture 对应的 C++ OHRenderNode 挂载到 Root OHRenderNode 的子节点列表中。\n\n结论：beginRecording 和 finishRecordingAsPicture 在 Root 和 Layer 中成对出现，形成了递归嵌套的录制结构。\n\n5. 进阶机制：Picture 缓存与性能优化\n\n在 RenderNodeLayer 中，Picture 不仅仅是传输工具，它还充当了 渲染缓存（Display List Cache） 的角色。\n\n5.1 为什么要缓存？\n\nCompose 的 UI 树可能非常复杂。如果每一帧都重新执行 Kotlin 层的绘制代码（遍历组件树、计算布局、执行 draw 指令），开销会很大。如果一个 Layer 的内容（Children）没有发生变化，仅仅是位置移动了（Translation）或者透明度变了（Alpha），我们完全没有必要重新录制一遍它的内容。\n\n5.2 缓存工作流\n\nRenderNodeLayer 内部维护了一个 private var picture: Picture? = null 变量。\n\n缓存失效 (Cache Miss)：\n\n当 Layer 初始化，或者内容发生变化（调用 invalidate()）时，picture 被置为 null。\n\n此时调用 drawLayer，会触发 录制流程（beginRecording -> drawBlock -> finishRecordingAsPicture），生成新的 Picture 并赋值给变量。\n\n缓存命中 (Cache Hit)：\n\n当 Layer 内容未变，但父节点触发重绘（例如 Layer 正在做平移动画）时，picture 不为空。\n\n此时直接复用现有的 Picture，跳过繁重的 drawBlock 执行，直接调用 canvas.drawPicture(picture)。\n\n5.3 关键问题：为什么缓存命中时仍需调用 drawPicture？\n\n这是一个非常核心的问题。既然缓存命中了，为什么不能直接“跳过”所有操作？\n\n答案：即使不用重新录制（执行 drawBlock），也必须调用 drawPicture。\n\n因为 drawPicture 在这个架构中扮演了两个关键角色，缺一不可：\n\n视觉上的“绘制”：虽然 Layer 的内容（子组件的绘制指令）已经打包在 Picture 里了，但这个 Picture 只是一个“数据包”。如果不调用 drawPicture，这个数据包就不会被画到父节点的 Canvas 上，屏幕上这块区域就是空的。\n\n类比：你拍好了一段胶卷（Picture），如果不把它放进放映机（Canvas）里播放，观众是看不到画面的。\n\n逻辑上的“挂载”（更重要）：在 OHRender 的融合渲染架构中，drawPicture 是构建节点树的关键指令。\n\nRoot 节点每一帧都在重新构建一棵 C++ 的 OHRenderNode 树。\n\n当 Root 录制到一半，需要包含 Layer 的内容时，必须通过 drawPicture 告诉底层：“把 Layer 对应的那个子节点（OHRenderNode），挂载到当前 Root 节点的子节点列表中。”\n\n如果不调用 drawPicture，底层的 C++ 节点树就会丢失这个分支，导致 Layer 及其子节点在后续的渲染流程（如光栅化、属性同步）中完全消失。\n\n总结：\n\n省去的是：drawBlock 的执行成本（即遍历 Kotlin 组件树、计算布局、生成绘制指令的 CPU 开销）。\n\n不能省的是：drawPicture 的调用（即“上交作业”和“挂载节点”的动作）。\n\n6. 完整协作时序图\n\n下图展示了包含缓存机制的完整调用链路。\n\n7. 总结\n\n特性\n\nRoot ( OHRenderNode::doRedraw )\n\nLayer ( RenderNodeLayer )\n\n触发时机\n\n每一帧刷新信号 (Vsync)\n\n父节点遍历到该 Layer 时\n\n录制对象\n\n整个窗口/页面\n\n局部 UI 组件子树\n\nCanvas 来源\n\nfRecorder->beginRecording (C++)\n\npictureRecorder.beginRecording (Kotlin)\n\n产物\n\n完整的帧 SkPicture (Root Node)\n\n局部的 SkPicture (Child Node)\n\n关系\n\n容器/调用者\n\n内容/被调用者\n\n连接方式\n\n通过 fCallback 触发 Layer 绘制\n\n通过 drawPicture 将自己挂载回 Root\n\n它们通过 递归录制 和 drawPicture 挂载 的方式，共同完成了一棵完整的渲染节点树的构建。",
          "content_html": "<h1>OHRenderNode 与 RenderNodeLayer 录制协作机制详解</h1>\n<p>本文档由浅入深地解析了 Root 节点（<code>OHRenderNode::doRedraw</code>）与 Layer 节点（<code>RenderNodeLayer</code>）在录制流程中的关系与协作机制，并深入探讨了 Picture 缓存与节点树构建的本质。</p>\n<h2><strong>1. 引言：渲染的双重循环</strong></h2>\n<p>在融合渲染架构中，渲染并非一次性的线性过程，而是由两个层级的录制循环交织而成：</p>\n<ol>\n<li><strong>Root 循环</strong>：由 C++ 层的 <code>OHRenderNode</code> 驱动，负责构建整棵渲染树的主干。</li>\n<li><strong>Layer 循环</strong>：由 Kotlin 层的 <code>RenderNodeLayer</code> 驱动，负责构建独立的子树。</li>\n</ol>\n<p>理解这两个循环如何通过 <code>drawPicture</code> 握手，是理解整个架构的关键。</p>\n<hr />\n<h2><strong>2. 宏观视角：导演与分镜</strong></h2>\n<p>如果把一帧画面的绘制比作拍摄一部电影：</p>\n<ul>\n<li><strong>Root (</strong><strong><code>OHRenderNode::doRedraw</code></strong><strong>)</strong> 是<strong>总导演</strong>。他负责掌控整部电影的拍摄流程，喊 \"Action\"（<code>beginRecording</code>）开始，喊 \"Cut\"（<code>finishRecordingAsPicture</code>）结束。</li>\n<li><strong>Layer (</strong><strong><code>RenderNodeLayer</code></strong><strong>)</strong> 是<strong>第二摄制组（分镜导演）</strong>。当总导演拍到某个特效场景（比如需要独立透明度、裁剪或变换的组件）时，会把任务交给分镜导演。</li>\n<li><strong>协作方式</strong>：分镜导演在一个独立的摄影棚里拍摄自己的片段（<code>beginRecording</code> -&gt; <code>draw</code> -&gt; <code>finish</code>），拍完后把胶卷（<code>Picture</code>）交给总导演。总导演把这段胶卷剪辑进主电影里（<code>drawPicture</code>）。</li>\n</ul>\n<hr />\n<h2><strong>3. 录制流程详解</strong></h2>\n<h3><strong>3.1 Root 的主战场：</strong><strong><code>OHRenderNode::doRedraw</code></strong></h3>\n<p>在 C++ 层 (<code>OHRenderNode.cpp</code>)，Root 节点是整个渲染树的根，它驱动了每一帧的更新。</p>\n<p><strong>核心流程：</strong></p>\n<ol>\n<li><strong>准备录制器材 (</strong><strong><code>beginRecording</code></strong><strong>)</strong>：创建一个 <code>SkPictureRecorder</code>，并调用 <code>beginRecording</code> 获取一个 <code>SkCanvas</code>。这个 Canvas 是“主画布”。</li>\n<li><strong>发号施令 (</strong><strong><code>fCallback</code></strong><strong>)</strong>：调用 Kotlin/ArkTS 层的回调函数。这相当于告诉 Compose UI：“请把你们所有的 UI 组件都画到这个主画布上。”</li>\n<li><strong>封箱存档 (</strong><strong><code>finishRecordingAsPicture</code></strong><strong>)</strong>：当 Kotlin 层画完所有内容后，调用 <code>finishRecordingAsPicture</code>。这会将刚才所有的绘制指令打包成一个 <code>SkPicture</code>（在本项目中，它实际上构建了一棵 <code>OHRenderNode</code> 树）。</li>\n</ol>\n<pre><code>// OHRenderNode.cpp (简化伪代码)\nvoid OHRenderNode::doRedraw() {\n// 1. 开始录制，拿到主画布\nSkCanvas* canvas = fRecorder-&gt;beginRecording(bounds);\n// 2. 调用 Kotlin 回调，遍历 Compose UI 树进行绘制\nif (fCallback) {\nfCallback(canvas);\n}\n// 3. 结束录制，生成包含整个帧内容的 Picture\nfPicture = fRecorder-&gt;finishRecordingAsPicture();\n}</code></pre>\n<h3><strong>3.2 Layer 的独立行动：</strong><strong><code>RenderNodeLayer</code></strong></h3>\n<p>在 Kotlin 层 (<code>RenderNodeLayer.skiko.kt</code>)，当 Compose 遇到 <code>Modifier.graphicsLayer</code> 时，会创建一个 <code>RenderNodeLayer</code>。它需要独立于父节点进行某些操作（如设置透明度、矩阵变换），因此它有自己的录制流程。</p>\n<p><strong>核心流程：</strong></p>\n<ol>\n<li><strong>开启小灶 (</strong><strong><code>beginRecording</code></strong><strong>)</strong>：Layer 拥有自己的 <code>pictureRecorder</code>。它调用 <code>beginRecording</code> 创建一个临时的、独立的 Canvas。</li>\n<li><strong>绘制子内容 (</strong><strong><code>performDrawLayer</code></strong><strong>)</strong>：Layer 将它的子组件（Children）绘制到这个独立的 Canvas 上，而不是直接画到 Root 的主画布上。</li>\n<li><strong>打包成果 (</strong><strong><code>finishRecordingAsPicture</code></strong><strong>)</strong>：调用 <code>finishRecordingAsPicture</code>，将子组件的绘制结果打包成一个子 <code>Picture</code>。</li>\n<li><strong>上交作业 (</strong><strong><code>drawPicture</code></strong><strong>) —— 关键协作点</strong>：Layer 拿到子 <code>Picture</code> 后，立即调用 <strong>父 Canvas</strong>（即 Root 传下来的那个 Canvas）的 <code>drawPicture</code> 方法。</li>\n</ol>\n<pre><code>// RenderNodeLayer.skiko.kt (简化伪代码)\noverride fun drawLayer(canvas: Canvas) {\n// 1. 开启子录制，拿到子画布\nval layerCanvas = pictureRecorder.beginRecording(bounds)\n// 2. 在子画布上绘制子组件\ndrawChildren(layerCanvas)\n// 3. 结束子录制，生成子 Picture\nval layerPicture = pictureRecorder.finishRecordingAsPicture()\n// 4. 【关键】将子 Picture 画到父 Canvas 上\ncanvas.drawPicture(layerPicture)\n}</code></pre>\n<hr />\n<h2><strong>4. 核心协作机制：</strong><strong><code>drawPicture</code></strong><strong> 的双重含义</strong></h2>\n<p>它们是如何协作的？秘密就在于 <strong><code>canvas.drawPicture(layerPicture)</code></strong>。</p>\n<p>在普通的 Skia 渲染中，<code>drawPicture</code> 只是把像素画上去。但在本项目的融合渲染架构中（基于 <code>OHRenderNode</code>），<code>SkPictureRecorder</code> 被赋予了特殊的含义：<strong>构建节点树</strong>。</p>\n<ol>\n<li><strong>Root 录制时</strong>：它正在构建一棵 C++ 的 <code>OHRenderNode</code> 树的主干。</li>\n<li><strong>Layer 录制时</strong>：它构建了一棵子树（Sub-tree）。</li>\n<li><strong><code>drawPicture</code></strong><strong> 时</strong>：</li>\n</ol>\n<ul>\n<li>Kotlin 层调用 <code>canvas.drawPicture(layerPicture)</code>。</li>\n<li>C++ 层拦截到这个指令。</li>\n<li>它<strong>不会</strong>立即光栅化像素，而是将 <code>layerPicture</code> 对应的 <strong>C++ OHRenderNode</strong> 挂载到 <strong>Root OHRenderNode</strong> 的子节点列表中。</li>\n</ul>\n<p><strong>结论</strong>：<code>beginRecording</code> 和 <code>finishRecordingAsPicture</code> 在 Root 和 Layer 中成对出现，形成了<strong>递归嵌套</strong>的录制结构。</p>\n<hr />\n<h2><strong>5. 进阶机制：Picture 缓存与性能优化</strong></h2>\n<p>在 <code>RenderNodeLayer</code> 中，<code>Picture</code> 不仅仅是传输工具，它还充当了 <strong>渲染缓存（Display List Cache）</strong> 的角色。</p>\n<h3><strong>5.1 为什么要缓存？</strong></h3>\n<p>Compose 的 UI 树可能非常复杂。如果每一帧都重新执行 Kotlin 层的绘制代码（遍历组件树、计算布局、执行 <code>draw</code> 指令），开销会很大。如果一个 Layer 的内容（Children）没有发生变化，仅仅是位置移动了（Translation）或者透明度变了（Alpha），我们完全没有必要重新录制一遍它的内容。</p>\n<h3><strong>5.2 缓存工作流</strong></h3>\n<p><code>RenderNodeLayer</code> 内部维护了一个 <code>private var picture: Picture? = null</code> 变量。</p>\n<ol>\n<li><strong>缓存失效 (Cache Miss)</strong>：</li>\n</ol>\n<ul>\n<li>当 Layer 初始化，或者内容发生变化（调用 <code>invalidate()</code>）时，<code>picture</code> 被置为 <code>null</code>。</li>\n<li>此时调用 <code>drawLayer</code>，会触发 <strong>录制流程</strong>（<code>beginRecording</code> -&gt; <code>drawBlock</code> -&gt; <code>finishRecordingAsPicture</code>），生成新的 <code>Picture</code> 并赋值给变量。</li>\n</ul>\n<ol>\n<li><strong>缓存命中 (Cache Hit)</strong>：</li>\n</ol>\n<ul>\n<li>当 Layer 内容未变，但父节点触发重绘（例如 Layer 正在做平移动画）时，<code>picture</code> 不为空。</li>\n<li>此时直接复用现有的 <code>Picture</code>，跳过繁重的 <code>drawBlock</code> 执行，直接调用 <code>canvas.drawPicture(picture)</code>。</li>\n</ul>\n<h3><strong>5.3 关键问题：为什么缓存命中时仍需调用 </strong><strong><code>drawPicture</code></strong><strong>？</strong></h3>\n<p>这是一个非常核心的问题。既然缓存命中了，为什么不能直接“跳过”所有操作？</p>\n<p><strong>答案：即使不用重新录制（执行 </strong><strong><code>drawBlock</code></strong><strong>），也必须调用 </strong><strong><code>drawPicture</code></strong><strong>。</strong></p>\n<p>因为 <code>drawPicture</code> 在这个架构中扮演了两个关键角色，缺一不可：</p>\n<ol>\n<li><strong>视觉上的“绘制”</strong>：虽然 Layer 的内容（子组件的绘制指令）已经打包在 <code>Picture</code> 里了，但这个 <code>Picture</code> 只是一个“数据包”。如果不调用 <code>drawPicture</code>，这个数据包就不会被画到父节点的 Canvas 上，屏幕上这块区域就是空的。</li>\n</ol>\n<ul>\n<li><em>类比</em>：你拍好了一段胶卷（Picture），如果不把它放进放映机（Canvas）里播放，观众是看不到画面的。</li>\n</ul>\n<ol>\n<li><strong>逻辑上的“挂载”</strong>（更重要）：在 OHRender 的融合渲染架构中，<code>drawPicture</code> 是<strong>构建节点树</strong>的关键指令。</li>\n</ol>\n<ul>\n<li>Root 节点每一帧都在重新构建一棵 C++ 的 <code>OHRenderNode</code> 树。</li>\n<li>当 Root 录制到一半，需要包含 Layer 的内容时，必须通过 <code>drawPicture</code> 告诉底层：“把 Layer 对应的那个子节点（OHRenderNode），挂载到当前 Root 节点的子节点列表中。”</li>\n<li>如果不调用 <code>drawPicture</code>，底层的 C++ 节点树就会丢失这个分支，导致 Layer 及其子节点在后续的渲染流程（如光栅化、属性同步）中完全消失。</li>\n</ul>\n<p><strong>总结</strong>：</p>\n<ul>\n<li><strong>省去的是</strong>：<code>drawBlock</code> 的执行成本（即遍历 Kotlin 组件树、计算布局、生成绘制指令的 CPU 开销）。</li>\n<li><strong>不能省的是</strong>：<code>drawPicture</code> 的调用（即“上交作业”和“挂载节点”的动作）。</li>\n</ul>\n<hr />\n<h2><strong>6. 完整协作时序图</strong></h2>\n<p>下图展示了包含缓存机制的完整调用链路。</p>\n<figure class=\"doc-figure\"><img src=\"../knowledge-map-assets/ohrendernode-rendernodelayer-aae602d5-ee86e4fbe7.png\" alt=\"OHRenderNode 与 RenderNodeLayer 录制协作机制详解 图示\" /></figure>\n<h2><strong>7. 总结</strong></h2>\n<div class=\"doc-table-wrap\"><table class=\"doc-table\"><thead><tr><th>特性</th><th>Root ( OHRenderNode::doRedraw )</th><th>Layer ( RenderNodeLayer )</th></tr></thead><tbody><tr><td>触发时机</td><td>每一帧刷新信号 (Vsync)</td><td>父节点遍历到该 Layer 时</td></tr><tr><td>录制对象</td><td>整个窗口/页面</td><td>局部 UI 组件子树</td></tr><tr><td>Canvas 来源</td><td>fRecorder-&gt;beginRecording (C++)</td><td>pictureRecorder.beginRecording (Kotlin)</td></tr><tr><td>产物</td><td>完整的帧 SkPicture (Root Node)</td><td>局部的 SkPicture (Child Node)</td></tr><tr><td>关系</td><td>容器/调用者</td><td>内容/被调用者</td></tr><tr><td>连接方式</td><td>通过 fCallback 触发 Layer 绘制</td><td>通过 drawPicture 将自己挂载回 Root</td></tr></tbody></table></div>\n<p>它们通过 <strong>递归录制</strong> 和 <strong><code>drawPicture</code></strong><strong> 挂载</strong> 的方式，共同完成了一棵完整的渲染节点树的构建。</p>"
        }
      ],
      "estimated_minutes": 14
    },
    {
      "module_id": "module-f09e99ae",
      "title": "非三明治混排原理",
      "source_path": "principle-analysis/非三明治混排原理.docx",
      "source_file_hash": "f09e99ae216da6ff1ce6fc67311ec6add2326dd7",
      "split_mode": "auto",
      "render_version": 11,
      "difficulty": 3,
      "summary": "混排原理 ArkUIView Compose 混排原理与示例说明 本文梳理 androidx.compose.ui.interop.ArkUIView.ohos.kt 中 I...",
      "sections": [
        {
          "section_id": "9d3398a6ad",
          "title": "非三明治混排原理",
          "summary": "混排原理 ArkUIView Compose 混排原理与示例说明 本文梳理 androidx.compose.ui.interop.ArkUIView.ohos.kt 中 I...",
          "key_points": [
            "InternalArkUIViewV2 结构概览（Kotlin 层）",
            "VideoPlayer Demo（Compose 用法）",
            "混排要点与最佳实践",
            "Native / C++ 侧对应逻辑"
          ],
          "estimated_minutes": 16,
          "content": "混排原理\n\nArkUIView Compose 混排原理与示例说明\n\n本文梳理 androidx.compose.ui.interop.ArkUIView.ohos.kt 中 InternalArkUIViewV2 的关键流程，并结合\n\ncomposeApp/src/ohosArm64Main/kotlin/com/tencent/compose/sample/video/VideoPlayer.kt 演示 ArkUI 视图与 Compose 内容混排的使用方式。\n\n1. InternalArkUIViewV2 结构概览（Kotlin 层）\n\n源文件：compose/ui/ui/src/ohosArm64Main/kotlin/androidx/compose/ui/interop/ArkUIView.ohos.kt\n\n核心入口：@Composable internal fun InternalArkUIViewV2(...)（127-307 行）\n\n1.1 主要步骤\n\n初始化 interop 上下文\n\nval interopContext = LocalArkUIInteropContext.current val embeddedInteropComponent = remember { EmbeddedInteropForArkUINode(...) }\n\nEmbeddedInteropForArkUINode 负责管理 ArkUI 的 wrappingView/baseView、生命周期与更新逻辑。\n\nPlace + MeasurePolicy\n\n使用 Place（Compose 自定义布局容器）包装 ArkUI 组件。\n\nmeasurePolicy 中会：\n\n将 Compose 的 Constraints 转成 ArkUI 识别的尺寸；\n\n通过 component.measure() 获取 ArkUI 测量结果；\n\n对 wrap content / adaptive 高度做约束；\n\n更新 componentSize 以记录当前布局大小。\n\n全局坐标与指针同步\n\nModifier.onGloballyPositioned：计算 ArkUI 视图在 Root 中的 Offset，用于指针事件偏移。\n\npointerInteropFilterV2(container, lastOffset)：使用扩展的指针过滤器，将 Compose 触摸事件转发到 ArkUI。\n\n绘制层\n\ndrawLayer 中调用 AdaptiveCanvas.drawInteropLayer(baseRenderNode, wrappingViewHandle, density)，把 ArkUI RenderNode 绘制到 Compose Canvas。\n\n生命周期管理\n\nDisposableEffect 内创建 ArkUIView 并设置 onCreate/onRelease：\n\nembeddedInteropComponent.ensureWrappingView() 懒创建 ArkUI native 视图；\n\ninteropContext.deferAction(VIEW_ADDED) / VIEW_REMOVED 负责将 native 节点挂载/卸载到 ArkUI 树。\n\nLaunchedEffect(background)、LaunchedEffect(parameter) 分别更新背景色与参数。\n\nSideEffect 更新 updater，保证在每次重组后仍能同步 Compose 属性到 ArkUI。\n\n测量回流机制\n\nArkUIView 的 onMeasured 回调若检测到 ArkUI 侧尺寸变化，会 layoutKey++ 触发 Compose 重测，确保两侧尺寸一致。\n\n1.2 关键数据流\n\n参数\n\n作用\n\nname\n\nArkUI 组件名，对应 ArkTS/ArkUI 端的注册组件\n\nparameter\n\nJsObject ，用于向 ArkTS 组件传递属性\n\nupdater / composeParameterUpdater\n\nCompose -> ArkUI 属性同步\n\nadaptiveParams\n\n控制最大高度、translate 等适配策略\n\nembeddedInteropComponent\n\n封装 ArkUI View、RenderNode、LayoutNode 等桥接逻辑\n\n2. VideoPlayer Demo（Compose 用法）\n\n文件：composeApp/src/ohosArm64Main/kotlin/com/tencent/compose/sample/video/VideoPlayer.kt\n\npackage com.tencent.compose.video import androidx.compose.runtime.Composable import androidx.compose.ui.Modifier import androidx.compose.ui.interop.ArkUIView import androidx.compose.ui.napi.js @Composable actual fun VideoPlayer( modifier: Modifier, url: String ) { ArkUIView( name = \"video\", modifier = modifier, parameter = js { \"src\"(url) \"autoplay\"(true) \"controls\"(true) } ) }\n\n说明：\n\n通过 ArkUIView 高阶 API（实际内部会选择 InternalArkUIViewV2），直接在 Compose 中声明一个 ArkUI “video” 组件。\n\nparameter = js { ... } 使用 kotlinx.js 构造 JsObject，传入视频源、自动播放、控制条等参数。\n\n配合 Compose 的 modifier，即可在布局中自由摆放 ArkUI video 视图，实现混排。\n\n3. 混排要点与最佳实践\n\n保证 ArkUIView 名称与 ArkTS 注册一致：name = \"video\" 需要在 ArkTS 侧有对应 Builder。\n\n参数更新：parameter 变化会触发 LaunchedEffect(parameter) 重新下发；复杂场景可以自定义 update / updater。\n\n尺寸同步：若 ArkUI 组件内部自适应尺寸，务必实现 onMeasured 并在尺寸变化时刷新 Compose 布局。\n\n指针/触摸：pointerInteropFilterV2 会带上 Offset，保证 Compose 坐标到 ArkUI 坐标的转换正确，必要时在 ArkTS 侧也要处理 offsetTouchEventLocalPosition。\n\n性能建议：避免频繁创建/销毁 ArkUIView，可通过 remember 对象复用；同时注意在 DisposableEffect 中释放 native 资源。\n\n4. Native / C++ 侧对应逻辑\n\n4.1 目录与角色\n\n路径：compose/ui/ui-arkui/src/ohosArm64Main/cpp/compose/src/main/cpp/compose/interop\n\n文件\n\n作用\n\noh_native_interop_wrap_node.{h,cpp}\n\nInteropWrapView ，负责 ArkUI mixed node 创建、attach/detach、背景色/布局同步\n\noh_interop_touch_event_handler.{h,cpp}\n\nCompose → ArkUI 指针事件处理器，支持多节点转发、坐标校准\n\n4.2 InteropWrapView 细节\n\n创建：通过 FFI 函数 androidx_compose_ui_arkui_utils_create_mixed_view_with_js 调用 InteropWrapView::CreateMixedNode，一次性获得 wrapping node、base render node、JS ArkUIView 引用。\n\n生命周期管理：\n\nAttachToParent() 调用 ArkUI NativeNodeApi::addChild 将 wrapping node 加入自定义节点树。\n\nDetachFromParent() 从父节点移除；若 PictureRecorder 仍持有 render node，会交给 OHRenderNodeManager::DestroyMixedNode 做延迟销毁。\n\nOHRenderNodeManager 维护 m_interopWrapViews、m_pendingDestroyViews，与 Compose 层的 add/remove/hierarchy 事件对应。\n\n绘制：OHNativeCanvasProxy::drawInteropLayer 会把 BaseRenderNode 绘制到 Compose Canvas，并根据 wrapView->markRecordedInPicture 处理 PictureRecorder 的引用。\n\n属性更新：背景色等接口通过 androidx_compose_ui_arkui_utils_set_background_color 等 FFI 暴露，Kotlin 层 EmbeddedInteropForArkUINode 调用。\n\n4.3 指针事件链路\n\npointerInteropFilterV2(embeddedInteropComponent.container, lastOffset) → Kotlin 端 ArkUIViewContainer.dispatchTouchEventV2。\n\nNative oh_interop_touch_event_handler 维护一个或多个 InteropWrapView，dispatchTouchEventV2 会根据提供的 offset 进行事件分发。\n\nArkTS (ArkUIView.ets) 中 onTouchEventV2(e, x, y) 将 Compose 的 root 坐标转换为本地坐标（offsetTouchEventLocalPosition(event, { x: -x, y: -y })），然后 postTouchEvent 到 ArkUI builder。\n\n4.4 其它配套组件\n\nFFI & RenderManager：oh_native_canvas_export.{h,cpp} 暴露 drawInteropLayer、attach/detach 等 C 接口，供 Kotlin 使用；OHRenderNodeManager 负责 mixed node 的注册、销毁、env 获取。\n\nPictureRecorder / Canvas：在 Compose → ArkUI 绘制时，需要同步 RenderNode 在 PictureRecorder 中的生命周期（markRecordedInPicture 等），避免被过早释放。\n\nArkTSBridge：提供 dpi/scale、window metrics、JS binding 等信息，供 touch/布局等逻辑使用。\n\n5. 参考文件\n\nKotlin 层：androidx/compose/ui/interop/ArkUIView.ohos.kt\n\nC++ 层：compose/ui/ui-arkui/.../compose/interop/*.cpp\n\nDemo：composeApp/src/ohosArm64Main/kotlin/com/tencent/compose/sample/video/VideoPlayer.kt\n\n通过 Kotlin + Native 两侧的协作，Compose 可以嵌入 ArkUI 原生组件，实现绘制 指针 生命周期的完整混排链路，同时复用 Compose 的状态与布局体系。",
          "content_html": "<h1><strong>混排原理</strong></h1>\n<h1><strong>ArkUIView Compose 混排原理与示例说明</strong></h1>\n<p>本文梳理 <code>androidx.compose.ui.interop.ArkUIView.ohos.kt</code> 中 <code>InternalArkUIViewV2</code> 的关键流程，并结合</p>\n<p><code>composeApp/src/ohosArm64Main/kotlin/com/tencent/compose/sample/video/VideoPlayer.kt</code> 演示 ArkUI 视图与 Compose 内容混排的使用方式。</p>\n<figure class=\"doc-figure\"><img src=\"../knowledge-map-assets/module-f09e99ae-05f31352d7.png\" alt=\"非三明治混排原理 图示\" /></figure>\n<hr />\n<h2><strong>1. </strong><strong><code>InternalArkUIViewV2</code></strong><strong> 结构概览（Kotlin 层）</strong></h2>\n<p>源文件：<code>compose/ui/ui/src/ohosArm64Main/kotlin/androidx/compose/ui/interop/ArkUIView.ohos.kt</code></p>\n<p>核心入口：<code>@Composable internal fun InternalArkUIViewV2(...)</code>（127-307 行）</p>\n<h3><strong>1.1 主要步骤</strong></h3>\n<ol>\n<li><strong>初始化 interop 上下文</strong></li>\n</ol>\n<pre><code>val interopContext = LocalArkUIInteropContext.current\nval embeddedInteropComponent = remember { EmbeddedInteropForArkUINode(...) }</code></pre>\n<p><code>EmbeddedInteropForArkUINode</code> 负责管理 ArkUI 的 <code>wrappingView/baseView</code>、生命周期与更新逻辑。</p>\n<ol>\n<li><strong>Place + MeasurePolicy</strong></li>\n</ol>\n<ul>\n<li>使用 <code>Place</code>（Compose 自定义布局容器）包装 ArkUI 组件。</li>\n<li><code>measurePolicy</code> 中会：</li>\n<li>将 Compose 的 <code>Constraints</code> 转成 ArkUI 识别的尺寸；</li>\n<li>通过 <code>component.measure()</code> 获取 ArkUI 测量结果；</li>\n<li>对 wrap content / adaptive 高度做约束；</li>\n<li>更新 <code>componentSize</code> 以记录当前布局大小。</li>\n</ul>\n<ol>\n<li><strong>全局坐标与指针同步</strong></li>\n</ol>\n<ul>\n<li><code>Modifier.onGloballyPositioned</code>：计算 ArkUI 视图在 Root 中的 <code>Offset</code>，用于指针事件偏移。</li>\n<li><code>pointerInteropFilterV2(container, lastOffset)</code>：使用扩展的指针过滤器，将 Compose 触摸事件转发到 ArkUI。</li>\n</ul>\n<ol>\n<li><strong>绘制层</strong></li>\n</ol>\n<ul>\n<li><code>drawLayer</code> 中调用 <code>AdaptiveCanvas.drawInteropLayer(baseRenderNode, wrappingViewHandle, density)</code>，把 ArkUI RenderNode 绘制到 Compose Canvas。</li>\n</ul>\n<ol>\n<li><strong>生命周期管理</strong></li>\n</ol>\n<ul>\n<li><code>DisposableEffect</code> 内创建 <code>ArkUIView</code> 并设置 <code>onCreate</code>/<code>onRelease</code>：</li>\n<li><code>embeddedInteropComponent.ensureWrappingView()</code> 懒创建 ArkUI native 视图；</li>\n<li><code>interopContext.deferAction(VIEW_ADDED)</code> / <code>VIEW_REMOVED</code> 负责将 native 节点挂载/卸载到 ArkUI 树。</li>\n<li><code>LaunchedEffect(background)</code>、<code>LaunchedEffect(parameter)</code> 分别更新背景色与参数。</li>\n<li><code>SideEffect</code> 更新 <code>updater</code>，保证在每次重组后仍能同步 Compose 属性到 ArkUI。</li>\n</ul>\n<ol>\n<li><strong>测量回流机制</strong></li>\n</ol>\n<ul>\n<li><code>ArkUIView</code> 的 <code>onMeasured</code> 回调若检测到 ArkUI 侧尺寸变化，会 <code>layoutKey++</code> 触发 Compose 重测，确保两侧尺寸一致。</li>\n</ul>\n<h3><strong>1.2 关键数据流</strong></h3>\n<div class=\"doc-table-wrap\"><table class=\"doc-table\"><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>name</td><td>ArkUI 组件名，对应 ArkTS/ArkUI 端的注册组件</td></tr><tr><td>parameter</td><td>JsObject ，用于向 ArkTS 组件传递属性</td></tr><tr><td>updater / composeParameterUpdater</td><td>Compose -&gt; ArkUI 属性同步</td></tr><tr><td>adaptiveParams</td><td>控制最大高度、translate 等适配策略</td></tr><tr><td>embeddedInteropComponent</td><td>封装 ArkUI View、RenderNode、LayoutNode 等桥接逻辑</td></tr></tbody></table></div>\n<hr />\n<h2><strong>2. </strong><strong><code>VideoPlayer</code></strong><strong> Demo（Compose 用法）</strong></h2>\n<p>文件：<code>composeApp/src/ohosArm64Main/kotlin/com/tencent/compose/sample/video/VideoPlayer.kt</code></p>\n<pre><code>package com.tencent.compose.video\nimport androidx.compose.runtime.Composable\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.interop.ArkUIView\nimport androidx.compose.ui.napi.js\n@Composable\nactual fun VideoPlayer(\nmodifier: Modifier,\nurl: String\n) {\nArkUIView(\nname = \"video\",\nmodifier = modifier,\nparameter = js {\n\"src\"(url)\n\"autoplay\"(true)\n\"controls\"(true)\n}\n)\n}</code></pre>\n<p>说明：</p>\n<ul>\n<li>通过 <code>ArkUIView</code> 高阶 API（实际内部会选择 <code>InternalArkUIViewV2</code>），直接在 Compose 中声明一个 ArkUI “video” 组件。</li>\n<li><code>parameter = js { ... }</code> 使用 <code>kotlinx.js</code> 构造 <code>JsObject</code>，传入视频源、自动播放、控制条等参数。</li>\n<li>配合 Compose 的 <code>modifier</code>，即可在布局中自由摆放 ArkUI video 视图，实现混排。</li>\n</ul>\n<hr />\n<h2><strong>3. 混排要点与最佳实践</strong></h2>\n<ol>\n<li><strong>保证 ArkUIView 名称与 ArkTS 注册一致</strong>：<code>name = \"video\"</code> 需要在 ArkTS 侧有对应 Builder。</li>\n<li><strong>参数更新</strong>：<code>parameter</code> 变化会触发 <code>LaunchedEffect(parameter)</code> 重新下发；复杂场景可以自定义 <code>update</code> / <code>updater</code>。</li>\n<li><strong>尺寸同步</strong>：若 ArkUI 组件内部自适应尺寸，务必实现 <code>onMeasured</code> 并在尺寸变化时刷新 Compose 布局。</li>\n<li><strong>指针/触摸</strong>：<code>pointerInteropFilterV2</code> 会带上 <code>Offset</code>，保证 Compose 坐标到 ArkUI 坐标的转换正确，必要时在 ArkTS 侧也要处理 <code>offsetTouchEventLocalPosition</code>。</li>\n<li><strong>性能建议</strong>：避免频繁创建/销毁 <code>ArkUIView</code>，可通过 <code>remember</code> 对象复用；同时注意在 <code>DisposableEffect</code> 中释放 native 资源。</li>\n</ol>\n<hr />\n<h2><strong>4. Native / C++ 侧对应逻辑</strong></h2>\n<h3><strong>4.1 目录与角色</strong></h3>\n<p>路径：<code>compose/ui/ui-arkui/src/ohosArm64Main/cpp/compose/src/main/cpp/compose/interop</code></p>\n<div class=\"doc-table-wrap\"><table class=\"doc-table\"><thead><tr><th>文件</th><th>作用</th></tr></thead><tbody><tr><td>oh_native_interop_wrap_node.{h,cpp}</td><td>InteropWrapView ，负责 ArkUI mixed node 创建、attach/detach、背景色/布局同步</td></tr><tr><td>oh_interop_touch_event_handler.{h,cpp}</td><td>Compose → ArkUI 指针事件处理器，支持多节点转发、坐标校准</td></tr></tbody></table></div>\n<h3><strong>4.2 </strong><strong><code>InteropWrapView</code></strong><strong> 细节</strong></h3>\n<ul>\n<li><strong>创建</strong>：通过 FFI 函数 <code>androidx_compose_ui_arkui_utils_create_mixed_view_with_js</code> 调用 <code>InteropWrapView::CreateMixedNode</code>，一次性获得 wrapping node、base render node、JS ArkUIView 引用。</li>\n<li><strong>生命周期管理</strong>：</li>\n<li><code>AttachToParent()</code> 调用 ArkUI <code>NativeNodeApi::addChild</code> 将 wrapping node 加入自定义节点树。</li>\n<li><code>DetachFromParent()</code> 从父节点移除；若 PictureRecorder 仍持有 render node，会交给 <code>OHRenderNodeManager::DestroyMixedNode</code> 做延迟销毁。</li>\n<li><code>OHRenderNodeManager</code> 维护 <code>m_interopWrapViews</code>、<code>m_pendingDestroyViews</code>，与 Compose 层的 add/remove/hierarchy 事件对应。</li>\n<li><strong>绘制</strong>：<code>OHNativeCanvasProxy::drawInteropLayer</code> 会把 <code>BaseRenderNode</code> 绘制到 Compose Canvas，并根据 <code>wrapView-&gt;markRecordedInPicture</code> 处理 PictureRecorder 的引用。</li>\n<li><strong>属性更新</strong>：背景色等接口通过 <code>androidx_compose_ui_arkui_utils_set_background_color</code> 等 FFI 暴露，Kotlin 层 <code>EmbeddedInteropForArkUINode</code> 调用。</li>\n</ul>\n<h3><strong>4.3 指针事件链路</strong></h3>\n<ol>\n<li><code>pointerInteropFilterV2(embeddedInteropComponent.container, lastOffset)</code> → Kotlin 端 <code>ArkUIViewContainer.dispatchTouchEventV2</code>。</li>\n<li>Native <code>oh_interop_touch_event_handler</code> 维护一个或多个 <code>InteropWrapView</code>，<code>dispatchTouchEventV2</code> 会根据提供的 offset 进行事件分发。</li>\n<li>ArkTS (<code>ArkUIView.ets</code>) 中 <code>onTouchEventV2(e, x, y)</code> 将 Compose 的 root 坐标转换为本地坐标（<code>offsetTouchEventLocalPosition(event, { x: -x, y: -y })</code>），然后 <code>postTouchEvent</code> 到 ArkUI builder。</li>\n</ol>\n<h3><strong>4.4 其它配套组件</strong></h3>\n<ul>\n<li><strong>FFI &amp; RenderManager</strong>：<code>oh_native_canvas_export.{h,cpp}</code> 暴露 <code>drawInteropLayer</code>、<code>attach/detach</code> 等 C 接口，供 Kotlin 使用；<code>OHRenderNodeManager</code> 负责 mixed node 的注册、销毁、env 获取。</li>\n<li><strong>PictureRecorder / Canvas</strong>：在 Compose → ArkUI 绘制时，需要同步 RenderNode 在 PictureRecorder 中的生命周期（<code>markRecordedInPicture</code> 等），避免被过早释放。</li>\n<li><strong>ArkTSBridge</strong>：提供 dpi/scale、window metrics、JS binding 等信息，供 touch/布局等逻辑使用。</li>\n</ul>\n<hr />\n<h2><strong>5. 参考文件</strong></h2>\n<ul>\n<li>Kotlin 层：<code>androidx/compose/ui/interop/ArkUIView.ohos.kt</code></li>\n<li>C++ 层：<code>compose/ui/ui-arkui/.../compose/interop/*.cpp</code></li>\n<li>Demo：<code>composeApp/src/ohosArm64Main/kotlin/com/tencent/compose/sample/video/VideoPlayer.kt</code></li>\n</ul>\n<p>通过 Kotlin + Native 两侧的协作，Compose 可以嵌入 ArkUI 原生组件，实现绘制 指针 生命周期的完整混排链路，同时复用 Compose 的状态与布局体系。</p>"
        }
      ],
      "estimated_minutes": 16
    },
    {
      "module_id": "vsync-5b772145",
      "title": "VSYNC空跑问题根因分析与解决方案",
      "source_path": "principle-analysis/VSYNC空跑问题根因分析与解决方案.docx",
      "source_file_hash": "5b772145355cc113f4745762cf263147118ef52f",
      "split_mode": "auto",
      "render_version": 11,
      "difficulty": 3,
      "summary": "VSYNC空跑问题根因分析与解决方案 VSYNC 空跑问题根因分析与解决方案 问题概述 问题现象 在性能分析工具（Profiler Frame）中观察到以下现象： VSYNC...",
      "sections": [
        {
          "section_id": "21f698f500",
          "title": "VSYNC空跑问题根因分析与解决方案",
          "summary": "VSYNC空跑问题根因分析与解决方案 VSYNC 空跑问题根因分析与解决方案 问题概述 问题现象 在性能分析工具（Profiler Frame）中观察到以下现象： VSYNC...",
          "key_points": [
            "willDraw 回调的触发时机",
            "形成死循环",
            "notifyRedraw() 的作用",
            "为什么会导致空跑？"
          ],
          "estimated_minutes": 21,
          "content": "VSYNC空跑问题根因分析与解决方案\n\nVSYNC 空跑问题根因分析与解决方案\n\n问题概述\n\n问题现象\n\n在性能分析工具（Profiler Frame）中观察到以下现象：\n\nVSYNC 信号持续到达：顶部的绿色垂直线表示 VSYNC 信号以固定频率持续到达\n\nComposition 工作几乎为空：（Composition 重组工作）在大部分时间内为空或只有极小的活动\n\nHandling 工作持续进行：（渲染处理工作）在每个 VSYNC 信号时都有活动，形成重复的节律模式\n\n关键问题：系统在每个 VSYNC 时都执行渲染处理工作，即使 Compose 层没有新的 UI 组合工作。\n\n性能影响\n\nCPU 资源浪费：无意义的渲染处理占用 CPU 资源\n\n功耗增加：持续的空跑导致不必要的功耗消耗\n\n性能下降：影响其他任务的执行，降低整体性能\n\n根因分析\n\n问题代码位置\n\n文件：compose/ui/ui-arkui/src/ohosArm64Main/cpp/compose/src/main/ets/compose/CanvasNode.ets\n\n问题代码（第 68-70 行）：\n\nthis.context.getUIObserver().on(\"willDraw\", () => { this.notifyRedraw() })\n\n根因详解\n\n1. willDraw 回调的触发时机\n\nwillDraw 是 ArkUI 框架在每次绘制前触发的回调。这意味着：\n\n每次 VSYNC 信号到达时，ArkUI 准备绘制一帧\n\n在绘制前，willDraw 回调被触发\n\n回调中调用 notifyRedraw()，请求下一次重绘\n\n2. 形成死循环\n\nVSYNC 信号到达 ↓ ArkUI 准备绘制（willDraw 触发） ↓ willDraw 回调执行：notifyRedraw() ↓ 请求下一次重绘 ↓ 下一次 VSYNC 信号到达 ↓ （循环继续...）\n\n关键问题：\n\nwillDraw 回调无条件调用 notifyRedraw()\n\n即使没有实际的 UI 变化，也会触发重绘请求\n\n导致每个 VSYNC 都会执行渲染处理，形成”空跑”\n\n3. notifyRedraw() 的作用\n\n查看 CanvasNode.ets 第 83-89 行：\n\nnotifyRedraw() { if (!this.nodeIsDrawing) { this.nodeIsDrawing = true; this.controller?.notifyRedrawC(this.id) // ← 通知 C++ 层重绘 this.context.postFrameCallback(new RenderFrameCallback(this)); } }\n\n执行流程：\n\n调用 notifyRedrawC(id) 通知 C++ 层\n\n通过 NAPI 调用到 ArkUIViewController.notifyRedraw()\n\n最终触发 invalidate() → 请求 VSYNC → 触发渲染处理\n\n4. 为什么会导致空跑？\n\n正常流程应该是：\n\nUI 状态变化 ↓ invalidate() 被调用 ↓ 请求 VSYNC ↓ VSYNC 到达 ↓ 执行渲染\n\n结果：\n\n即使 Compose 没有新的组合工作\n\n渲染处理工作仍然在每个 VSYNC 时执行\n\n这就是”VSYNC 空跑”的根本原因\n\n解决方案\n\n解决思路\n\n核心原则：按需请求 VSYNC，而不是无条件请求。\n\n策略：\n\n删除 willDraw 回调中的 notifyRedraw() 调用\n\n避免每次绘制前都触发重绘请求\n\n打破死循环\n\n在 invalidate() 中按需请求 VSYNC\n\n只有当 Compose 层真正需要更新时才请求 VSYNC\n\n确保 VSYNC 请求与实际 UI 变化同步\n\n代码变更\n\n变更 1：删除 willDraw 回调\n\n文件：compose/ui/ui-arkui/src/ohosArm64Main/cpp/compose/src/main/ets/compose/CanvasNode.ets\n\n变更前（第 67-71 行）：\n\nthis.frameRate = displaySync.create(); this.context.getUIObserver().on(\"willDraw\", () => { this.notifyRedraw() }) this.frameRate.setExpectedFrameRateRange({expected: 120, min: 0, max: 120});\n\n变更后：\n\nthis.frameRate = displaySync.create(); // 删除 willDraw 回调，避免无条件触发重绘 // this.context.getUIObserver().on(\"willDraw\", () => { // this.notifyRedraw() // }) this.frameRate.setExpectedFrameRateRange({expected: 120, min: 0, max: 120});\n\n原因：\n\nwillDraw 回调在每次绘制前都会触发\n\n无条件调用 notifyRedraw()\n\n删除后，重绘请求只在真正需要时（通过 invalidate()）触发\n\n变更 2：在 invalidate() 中按需请求 VSYNC\n\n文件：compose/ui/ui/src/ohosArm64Main/kotlin/androidx/compose/ui/arkui/ArkUIViewController.kt\n\n变更前（第 212-219 行）：\n\noverride fun invalidate() { OhosTrace.traceSync(\"xxx test invalidate\") { invalid = true Canvas.notifyRedraw(id.takeLast(1).toInt()) // ← 直接通知重绘 frameController?.requireFrameCallback() } }\n\n变更后：\n\noverride fun invalidate() { OhosTrace.traceSync(\"xxx test invalidate\") { invalid = true Canvas.requestComposeVsyncAndNotify(id.takeLast(1).toInt()) // ← 通过 VSYNC 请求重绘 //Canvas.notifyRedraw(id.takeLast(1).toInt()) // ← 已废弃，避免直接触发 frameController?.requireFrameCallback() } }\n\n关键改进：\n\n使用 requestComposeVsyncAndNotify() 替代 notifyRedraw()\n\nrequestComposeVsyncAndNotify() 会请求 VSYNC，并在 VSYNC 回调中触发 notifyRedraw()\n\n确保重绘与 VSYNC 信号对齐，避免不必要的中间帧\n\n变更后的调用链（正确）\n\nCompose 状态变化 ↓ invalidate() 被调用 ↓ Canvas.requestComposeVsyncAndNotify() // ← 请求 VSYNC，但不立即触发 ↓ 等待下一个 VSYNC 信号 ↓ VSYNC 回调触发 notifyRedraw() ↓ 执行渲染处理（H... 轨道） ↓ 如果没有新的 invalidate()，不再请求 VSYNC ↓ 后续 VSYNC 信号到达时，没有渲染处理（H... 轨道为空）\n\n优势：\n\n只有在 invalidate() 被调用时（有实际的 UI 变化）才请求 VSYNC\n\nVSYNC 回调中触发重绘，确保与帧信号对齐\n\n没有 UI 变化时，不会执行渲染处理，避免”空跑”\n\n技术细节\n\nrequestComposeVsyncAndNotify() 的实现\n\n位置：OHRender/OHRender/src/oh/RenderNodeImplC.cpp\n\n实现逻辑：\n\nvoid RootRenderNodeManager::RequestComposeVsyncAndNotify(int32_t id) { RequestVsyncForNotify(id); } static void RequestVsyncForNotify(int32_t id) { OH_NativeVSync_RequestFrame(g_vsync_handle, OnNativeVsync, reinterpret_cast<void*>(static_cast<intptr_t>(id))); } static void OnNativeVsync(long long timestamp, void *data) { int32_t id = static_cast<int32_t>(reinterpret_cast<intptr_t>(data)); if (id >= 0) { RootRenderNodeManager::Instance().NotifyRedraw(id); // ← 在 VSYNC 回调中触发 } }\n\n关键点：\n\nrequestComposeVsyncAndNotify() 不会立即触发重绘\n\n而是注册一个 VSYNC 回调\n\n当 VSYNC 信号到达时，回调中才调用 NotifyRedraw()\n\n确保重绘与 VSYNC 信号对齐\n\ninvalidate() 的触发时机\n\ninvalidate() 在以下情况下被调用：\n\nCompose 状态变化：\n\nmutableStateOf 的值变化\n\nremember 的状态更新\n\n触发重组\n\n布局变化：\n\n组件大小变化\n\n布局约束变化\n\n输入事件：\n\n触摸事件\n\n键盘事件\n\n动画：\n\n动画值更新\n\n动画状态变化\n\n关键：这些都是真正的 UI 变化，需要更新界面，因此应该请求 VSYNC。\n\n验证方法\n\n1. 性能分析工具验证\n\n使用 HarmonyOS Profiler 或类似工具：\n\n验证指标：\n\nVSYNC 信号：应该持续到达（这是正常的）\n\nComposition 工作（C… 轨道）：\n\n有 UI 变化时：应该有活动\n\n没有 UI 变化时：应该为空\n\nHandling 工作（H… 轨道）：\n\n有 UI 变化时：应该有活动\n\n没有 UI 变化时：应该为空（这是修复后的效果）\n\n修复前：\n\n即使没有 UI 变化，轨道在每个 VSYNC 时都有活动\n\n形成”空跑”模式\n\n修复后：\n\n没有 UI 变化时UI轨道应该为空\n\n只有在 invalidate() 被调用时，UI轨道才有活动\n\n2. 日志验证\n\n添加日志来跟踪 VSYNC 请求和重绘触发：\n\n// 在 invalidate() 中添加日志 override fun invalidate() { println(\"[VSYNC] invalidate() called, requesting VSYNC\") Canvas.requestComposeVsyncAndNotify(id.takeLast(1).toInt()) frameController?.requireFrameCallback() } // 在 VSYNC 回调中添加日志 static void OnNativeVsync(long long timestamp, void *data) { int32_t id = static_cast<int32_t>(reinterpret_cast<intptr_t>(data)); OH_LOG_Print(LOG_APP, LOG_DEBUG, LOG_DOMAIN, \"cmp\", \"OnNativeVsync: timestamp=%lld, id=%d\", timestamp, id); if (id >= 0) { RootRenderNodeManager::Instance().NotifyRedraw(id); } }\n\n预期结果：\n\n没有 UI 变化时：不应该看到 invalidate() 的日志\n\n有 UI 变化时：应该看到 invalidate() → OnNativeVsync → NotifyRedraw 的日志序列\n\n3. CPU 使用率验证\n\n修复前：\n\nCPU 使用率持续较高（即使没有 UI 变化）\n\n因为每个 VSYNC 都在执行渲染处理\n\n修复后：\n\n没有 UI 变化时：CPU 使用率应该明显降低\n\n有 UI 变化时：CPU 使用率正常（执行必要的渲染工作）\n\n4. 功耗验证\n\n修复前：\n\n功耗持续较高（即使屏幕静止）\n\n修复后：\n\n没有 UI 变化时：功耗应该明显降低\n\n有 UI 变化时：功耗正常\n\n性能优化效果\n\n预期改进\n\nCPU 使用率降低\n\n没有 UI 变化时，CPU 使用率应该降低\n\n避免了无意义的渲染处理\n\n功耗降低\n\n屏幕静止时，功耗应该降低\n\n减少了不必要的 GPU/CPU 工作\n\n帧率稳定性提升\n\n避免了不必要的渲染工作干扰\n\n帧率更加稳定\n\n响应性提升\n\n真正的 UI 变化时，响应更快\n\n因为系统资源没有被”空跑”消耗\n\n相关代码位置\n\n关键文件\n\nCanvasNode.ets\n\n路径：compose/ui/ui-arkui/src/ohosArm64Main/cpp/compose/src/main/ets/compose/CanvasNode.ets\n\n变更：删除 willDraw 回调中的 notifyRedraw() 调用\n\nArkUIViewController.kt\n\n路径：compose/ui/ui/src/ohosArm64Main/kotlin/androidx/compose/ui/arkui/ArkUIViewController.kt\n\n变更：在 invalidate() 中使用 requestComposeVsyncAndNotify() 替代 notifyRedraw()\n\nRenderNodeImplC.cpp\n\n路径：OHRender/OHRender/src/oh/RenderNodeImplC.cpp\n\n相关：RequestComposeVsyncAndNotify() 和 OnNativeVsync() 的实现\n\n相关 API\n\nwillDraw 回调\n\nArkUI 框架提供的绘制前回调\n\n在每次绘制前触发\n\nnotifyRedraw()\n\n直接触发重绘（不等待 VSYNC）\n\n已废弃，应该使用 VSYNC 驱动的方式\n\nrequestComposeVsyncAndNotify()\n\n请求 VSYNC，在 VSYNC 回调中触发重绘\n\n确保重绘与帧信号对齐\n\ninvalidate()\n\nCompose 层通知需要更新的接口\n\n应该在真正需要更新时调用\n\n注意事项\n\n1. VSYNC 驱动的重绘机制\n\n理解要点：\n\nVSYNC 信号是显示器的刷新信号，不是 UI 更新的信号\n\nUI 更新应该响应状态变化，而不是响应 VSYNC\n\nVSYNC 只是用来对齐渲染时机，确保渲染与显示同步\n\n正确流程：\n\nUI 状态变化 → invalidate() → 请求 VSYNC → VSYNC 到达 → 执行渲染\n\n错误流程：\n\nVSYNC 到达 → willDraw → notifyRedraw() → 执行渲染（即使没有 UI 变化）\n\n总结\n\n问题根因\n\nCanvasNode.ets 中的 willDraw 回调无条件调用 notifyRedraw()，导致：\n\n每次 VSYNC 信号到达时都会触发重绘请求\n\n即使没有实际的 UI 变化，也会执行渲染处理\n\n形成”VSYNC 空跑”问题\n\n解决方案\n\n删除 willDraw 回调中的 notifyRedraw() 调用\n\n避免无条件触发重绘请求\n\n打破死循环\n\n在 invalidate() 中按需请求 VSYNC\n\n使用 requestComposeVsyncAndNotify() 替代 notifyRedraw()\n\n确保重绘与 VSYNC 信号对齐\n\n只在真正需要更新时才请求 VSYNC",
          "content_html": "<h1>VSYNC空跑问题根因分析与解决方案</h1>\n<h1><strong>VSYNC 空跑问题根因分析与解决方案</strong></h1>\n<h2><strong>问题概述</strong></h2>\n<h3><strong>问题现象</strong></h3>\n<p>在性能分析工具（Profiler Frame）中观察到以下现象：</p>\n<ol>\n<li><strong>VSYNC 信号持续到达</strong>：顶部的绿色垂直线表示 VSYNC 信号以固定频率持续到达</li>\n<li><strong>Composition 工作几乎为空</strong>：（Composition 重组工作）在大部分时间内为空或只有极小的活动</li>\n<li><strong>Handling 工作持续进行</strong>：（渲染处理工作）在每个 VSYNC 信号时都有活动，形成重复的节律模式</li>\n</ol>\n<p><strong>关键问题</strong>：系统在每个 VSYNC 时都执行渲染处理工作，即使 Compose 层没有新的 UI 组合工作。</p>\n<figure class=\"doc-figure\"><img src=\"../knowledge-map-assets/vsync-5b772145-c751b39721.png\" alt=\"VSYNC空跑问题根因分析与解决方案 图示\" /></figure>\n<h3><strong>性能影响</strong></h3>\n<ul>\n<li><strong>CPU 资源浪费</strong>：无意义的渲染处理占用 CPU 资源</li>\n<li><strong>功耗增加</strong>：持续的空跑导致不必要的功耗消耗</li>\n<li><strong>性能下降</strong>：影响其他任务的执行，降低整体性能</li>\n</ul>\n<hr />\n<h2><strong>根因分析</strong></h2>\n<h3><strong>问题代码位置</strong></h3>\n<p><strong>文件</strong>：<code>compose/ui/ui-arkui/src/ohosArm64Main/cpp/compose/src/main/ets/compose/CanvasNode.ets</code></p>\n<p><strong>问题代码</strong>（第 68-70 行）：</p>\n<pre><code>this.context.getUIObserver().on(\"willDraw\", () =&gt; {\nthis.notifyRedraw()\n})</code></pre>\n<h3><strong>根因详解</strong></h3>\n<h3><strong>1. </strong><strong><code>willDraw</code></strong><strong> 回调的触发时机</strong></h3>\n<p><code>willDraw</code> 是 ArkUI 框架在<strong>每次绘制前</strong>触发的回调。这意味着：</p>\n<ul>\n<li><strong>每次 VSYNC 信号到达时</strong>，ArkUI 准备绘制一帧</li>\n<li><strong>在绘制前</strong>，<code>willDraw</code> 回调被触发</li>\n<li><strong>回调中调用 </strong><strong><code>notifyRedraw()</code></strong>，请求下一次重绘</li>\n</ul>\n<h3><strong>2. 形成死循环</strong></h3>\n<pre><code>VSYNC 信号到达\n↓\nArkUI 准备绘制（willDraw 触发）\n↓\nwillDraw 回调执行：notifyRedraw()\n↓\n请求下一次重绘\n↓\n下一次 VSYNC 信号到达\n↓\n（循环继续...）</code></pre>\n<p><strong>关键问题</strong>：</p>\n<ul>\n<li><code>willDraw</code> 回调<strong>无条件</strong>调用 <code>notifyRedraw()</code></li>\n<li>即使<strong>没有实际的 UI 变化</strong>，也会触发重绘请求</li>\n<li>导致<strong>每个 VSYNC 都会执行渲染处理</strong>，形成”空跑”</li>\n</ul>\n<h3><strong>3. </strong><strong><code>notifyRedraw()</code></strong><strong> 的作用</strong></h3>\n<p>查看 <code>CanvasNode.ets</code> 第 83-89 行：</p>\n<pre><code>notifyRedraw() {\nif (!this.nodeIsDrawing) {\nthis.nodeIsDrawing = true;\nthis.controller?.notifyRedrawC(this.id) // ← 通知 C++ 层重绘\nthis.context.postFrameCallback(new RenderFrameCallback(this));\n}\n}</code></pre>\n<p><strong>执行流程</strong>：</p>\n<ol>\n<li>调用 <code>notifyRedrawC(id)</code> 通知 C++ 层</li>\n<li>通过 NAPI 调用到 <code>ArkUIViewController.notifyRedraw()</code></li>\n<li>最终触发 <code>invalidate()</code> → 请求 VSYNC → 触发渲染处理</li>\n</ol>\n<h3><strong>4. 为什么会导致空跑？</strong></h3>\n<p><strong>正常流程应该是</strong>：</p>\n<pre><code>UI 状态变化\n↓\ninvalidate() 被调用\n↓\n请求 VSYNC\n↓\nVSYNC 到达\n↓\n执行渲染</code></pre>\n<p><strong>结果</strong>：</p>\n<ul>\n<li>即使 Compose 没有新的组合工作</li>\n<li>渲染处理工作仍然在每个 VSYNC 时执行</li>\n<li>这就是”VSYNC 空跑”的根本原因</li>\n</ul>\n<hr />\n<h2><strong>解决方案</strong></h2>\n<h3><strong>解决思路</strong></h3>\n<p><strong>核心原则</strong>：<strong>按需请求 VSYNC</strong>，而不是无条件请求。</p>\n<p><strong>策略</strong>：</p>\n<ol>\n<li><strong>删除 </strong><strong><code>willDraw</code></strong><strong> 回调中的 </strong><strong><code>notifyRedraw()</code></strong><strong> 调用</strong></li>\n</ol>\n<ul>\n<li>避免每次绘制前都触发重绘请求</li>\n<li>打破死循环</li>\n</ul>\n<ol>\n<li><strong>在 </strong><strong><code>invalidate()</code></strong><strong> 中按需请求 VSYNC</strong></li>\n</ol>\n<ul>\n<li>只有当 Compose 层真正需要更新时才请求 VSYNC</li>\n<li>确保 VSYNC 请求与实际 UI 变化同步</li>\n</ul>\n<h3><strong>代码变更</strong></h3>\n<h3><strong>变更 1：删除 </strong><strong><code>willDraw</code></strong><strong> 回调</strong></h3>\n<p><strong>文件</strong>：<code>compose/ui/ui-arkui/src/ohosArm64Main/cpp/compose/src/main/ets/compose/CanvasNode.ets</code></p>\n<p><strong>变更前</strong>（第 67-71 行）：</p>\n<pre><code>this.frameRate = displaySync.create();\nthis.context.getUIObserver().on(\"willDraw\", () =&gt; {\nthis.notifyRedraw()\n})\nthis.frameRate.setExpectedFrameRateRange({expected: 120, min: 0, max: 120});</code></pre>\n<p><strong>变更后</strong>：</p>\n<pre><code>this.frameRate = displaySync.create();\n// 删除 willDraw 回调，避免无条件触发重绘\n// this.context.getUIObserver().on(\"willDraw\", () =&gt; {\n// this.notifyRedraw()\n// })\nthis.frameRate.setExpectedFrameRateRange({expected: 120, min: 0, max: 120});</code></pre>\n<p><strong>原因</strong>：</p>\n<ul>\n<li><code>willDraw</code> 回调在每次绘制前都会触发</li>\n<li>无条件调用 <code>notifyRedraw()</code></li>\n<li>删除后，重绘请求只在真正需要时（通过 <code>invalidate()</code>）触发</li>\n</ul>\n<h3><strong>变更 2：在 </strong><strong><code>invalidate()</code></strong><strong> 中按需请求 VSYNC</strong></h3>\n<p><strong>文件</strong>：<code>compose/ui/ui/src/ohosArm64Main/kotlin/androidx/compose/ui/arkui/ArkUIViewController.kt</code></p>\n<p><strong>变更前</strong>（第 212-219 行）：</p>\n<pre><code>override fun invalidate() {\nOhosTrace.traceSync(\"xxx test invalidate\") {\ninvalid = true\nCanvas.notifyRedraw(id.takeLast(1).toInt()) // ← 直接通知重绘\nframeController?.requireFrameCallback()\n}\n}</code></pre>\n<figure class=\"doc-figure\"><img src=\"../knowledge-map-assets/vsync-5b772145-f0ac3c747f.png\" alt=\"VSYNC空跑问题根因分析与解决方案 图示\" /></figure>\n<p><strong>变更后</strong>：</p>\n<pre><code>override fun invalidate() {\nOhosTrace.traceSync(\"xxx test invalidate\") {\ninvalid = true\nCanvas.requestComposeVsyncAndNotify(id.takeLast(1).toInt()) // ← 通过 VSYNC 请求重绘\n//Canvas.notifyRedraw(id.takeLast(1).toInt()) // ← 已废弃，避免直接触发\nframeController?.requireFrameCallback()\n}\n}</code></pre>\n<p><strong>关键改进</strong>：</p>\n<ol>\n<li><strong>使用 </strong><strong><code>requestComposeVsyncAndNotify()</code></strong><strong> 替代 </strong><strong><code>notifyRedraw()</code></strong></li>\n</ol>\n<ul>\n<li><code>requestComposeVsyncAndNotify()</code> 会请求 VSYNC，并在 VSYNC 回调中触发 <code>notifyRedraw()</code></li>\n<li>确保重绘与 VSYNC 信号对齐，避免不必要的中间帧</li>\n</ul>\n<figure class=\"doc-figure\"><img src=\"../knowledge-map-assets/vsync-5b772145-b03104ab67.png\" alt=\"VSYNC空跑问题根因分析与解决方案 图示\" /></figure>\n<h3><strong>变更后的调用链（正确）</strong></h3>\n<pre><code>Compose 状态变化\n↓\ninvalidate() 被调用\n↓\nCanvas.requestComposeVsyncAndNotify() // ← 请求 VSYNC，但不立即触发\n↓\n等待下一个 VSYNC 信号\n↓\nVSYNC 回调触发 notifyRedraw()\n↓\n执行渲染处理（H... 轨道）\n↓\n如果没有新的 invalidate()，不再请求 VSYNC\n↓\n后续 VSYNC 信号到达时，没有渲染处理（H... 轨道为空）</code></pre>\n<p><strong>优势</strong>：</p>\n<ul>\n<li>只有在 <code>invalidate()</code> 被调用时（有实际的 UI 变化）才请求 VSYNC</li>\n<li>VSYNC 回调中触发重绘，确保与帧信号对齐</li>\n<li>没有 UI 变化时，不会执行渲染处理，避免”空跑”</li>\n</ul>\n<hr />\n<h2><strong>技术细节</strong></h2>\n<h3><strong><code>requestComposeVsyncAndNotify()</code></strong><strong> 的实现</strong></h3>\n<p><strong>位置</strong>：<code>OHRender/OHRender/src/oh/RenderNodeImplC.cpp</code></p>\n<p><strong>实现逻辑</strong>：</p>\n<pre><code>void RootRenderNodeManager::RequestComposeVsyncAndNotify(int32_t id) {\nRequestVsyncForNotify(id);\n}\nstatic void RequestVsyncForNotify(int32_t id) {\nOH_NativeVSync_RequestFrame(g_vsync_handle, OnNativeVsync,\nreinterpret_cast&lt;void*&gt;(static_cast&lt;intptr_t&gt;(id)));\n}\nstatic void OnNativeVsync(long long timestamp, void *data) {\nint32_t id = static_cast&lt;int32_t&gt;(reinterpret_cast&lt;intptr_t&gt;(data));\nif (id &gt;= 0) {\nRootRenderNodeManager::Instance().NotifyRedraw(id); // ← 在 VSYNC 回调中触发\n}\n}</code></pre>\n<p><strong>关键点</strong>：</p>\n<ul>\n<li><code>requestComposeVsyncAndNotify()</code> 不会立即触发重绘</li>\n<li>而是注册一个 VSYNC 回调</li>\n<li>当 VSYNC 信号到达时，回调中才调用 <code>NotifyRedraw()</code></li>\n<li>确保重绘与 VSYNC 信号对齐</li>\n</ul>\n<h3><strong><code>invalidate()</code></strong><strong> 的触发时机</strong></h3>\n<p><code>invalidate()</code> 在以下情况下被调用：</p>\n<ol>\n<li><strong>Compose 状态变化</strong>：</li>\n</ol>\n<ul>\n<li><code>mutableStateOf</code> 的值变化</li>\n<li><code>remember</code> 的状态更新</li>\n<li>触发重组</li>\n</ul>\n<ol>\n<li><strong>布局变化</strong>：</li>\n</ol>\n<ul>\n<li>组件大小变化</li>\n<li>布局约束变化</li>\n</ul>\n<ol>\n<li><strong>输入事件</strong>：</li>\n</ol>\n<ul>\n<li>触摸事件</li>\n<li>键盘事件</li>\n</ul>\n<ol>\n<li><strong>动画</strong>：</li>\n</ol>\n<ul>\n<li>动画值更新</li>\n<li>动画状态变化</li>\n</ul>\n<p><strong>关键</strong>：这些都是<strong>真正的 UI 变化</strong>，需要更新界面，因此应该请求 VSYNC。</p>\n<hr />\n<h2><strong>验证方法</strong></h2>\n<h3><strong>1. 性能分析工具验证</strong></h3>\n<p>使用 HarmonyOS Profiler 或类似工具：</p>\n<p><strong>验证指标</strong>：</p>\n<ul>\n<li><strong>VSYNC 信号</strong>：应该持续到达（这是正常的）</li>\n<li><strong>Composition 工作（C… 轨道）</strong>：</li>\n<li>有 UI 变化时：应该有活动</li>\n<li>没有 UI 变化时：应该为空</li>\n<li><strong>Handling 工作（H… 轨道）</strong>：</li>\n<li>有 UI 变化时：应该有活动</li>\n<li>没有 UI 变化时：应该为空（<strong>这是修复后的效果</strong>）</li>\n</ul>\n<p><strong>修复前</strong>：</p>\n<ul>\n<li>即使没有 UI 变化，轨道在每个 VSYNC 时都有活动</li>\n<li>形成”空跑”模式</li>\n</ul>\n<p><strong>修复后</strong>：</p>\n<ul>\n<li>没有 UI 变化时UI轨道应该为空</li>\n<li>只有在 <code>invalidate()</code> 被调用时，UI轨道才有活动</li>\n</ul>\n<h3><strong>2. 日志验证</strong></h3>\n<p>添加日志来跟踪 VSYNC 请求和重绘触发：</p>\n<pre><code>// 在 invalidate() 中添加日志\noverride fun invalidate() {\nprintln(\"[VSYNC] invalidate() called, requesting VSYNC\")\nCanvas.requestComposeVsyncAndNotify(id.takeLast(1).toInt())\nframeController?.requireFrameCallback()\n}\n// 在 VSYNC 回调中添加日志\nstatic void OnNativeVsync(long long timestamp, void *data) {\nint32_t id = static_cast&lt;int32_t&gt;(reinterpret_cast&lt;intptr_t&gt;(data));\nOH_LOG_Print(LOG_APP, LOG_DEBUG, LOG_DOMAIN, \"cmp\",\n\"OnNativeVsync: timestamp=%lld, id=%d\", timestamp, id);\nif (id &gt;= 0) {\nRootRenderNodeManager::Instance().NotifyRedraw(id);\n}\n}</code></pre>\n<p><strong>预期结果</strong>：</p>\n<ul>\n<li>没有 UI 变化时：不应该看到 <code>invalidate()</code> 的日志</li>\n<li>有 UI 变化时：应该看到 <code>invalidate()</code> → <code>OnNativeVsync</code> → <code>NotifyRedraw</code> 的日志序列</li>\n</ul>\n<h3><strong>3. CPU 使用率验证</strong></h3>\n<p><strong>修复前</strong>：</p>\n<ul>\n<li>CPU 使用率持续较高（即使没有 UI 变化）</li>\n<li>因为每个 VSYNC 都在执行渲染处理</li>\n</ul>\n<p><strong>修复后</strong>：</p>\n<ul>\n<li>没有 UI 变化时：CPU 使用率应该明显降低</li>\n<li>有 UI 变化时：CPU 使用率正常（执行必要的渲染工作）</li>\n</ul>\n<h3><strong>4. 功耗验证</strong></h3>\n<p><strong>修复前</strong>：</p>\n<ul>\n<li>功耗持续较高（即使屏幕静止）</li>\n</ul>\n<p><strong>修复后</strong>：</p>\n<ul>\n<li>没有 UI 变化时：功耗应该明显降低</li>\n<li>有 UI 变化时：功耗正常</li>\n</ul>\n<hr />\n<h2><strong>性能优化效果</strong></h2>\n<h3><strong>预期改进</strong></h3>\n<ol>\n<li><strong>CPU 使用率降低</strong></li>\n</ol>\n<ul>\n<li>没有 UI 变化时，CPU 使用率应该降低</li>\n<li>避免了无意义的渲染处理</li>\n</ul>\n<ol>\n<li><strong>功耗降低</strong></li>\n</ol>\n<ul>\n<li>屏幕静止时，功耗应该降低</li>\n<li>减少了不必要的 GPU/CPU 工作</li>\n</ul>\n<ol>\n<li><strong>帧率稳定性提升</strong></li>\n</ol>\n<ul>\n<li>避免了不必要的渲染工作干扰</li>\n<li>帧率更加稳定</li>\n</ul>\n<ol>\n<li><strong>响应性提升</strong></li>\n</ol>\n<ul>\n<li>真正的 UI 变化时，响应更快</li>\n<li>因为系统资源没有被”空跑”消耗</li>\n</ul>\n<hr />\n<h2><strong>相关代码位置</strong></h2>\n<h3><strong>关键文件</strong></h3>\n<ol>\n<li><strong>CanvasNode.ets</strong></li>\n</ol>\n<ul>\n<li>路径：<code>compose/ui/ui-arkui/src/ohosArm64Main/cpp/compose/src/main/ets/compose/CanvasNode.ets</code></li>\n<li>变更：删除 <code>willDraw</code> 回调中的 <code>notifyRedraw()</code> 调用</li>\n</ul>\n<ol>\n<li><strong>ArkUIViewController.kt</strong></li>\n</ol>\n<ul>\n<li>路径：<code>compose/ui/ui/src/ohosArm64Main/kotlin/androidx/compose/ui/arkui/ArkUIViewController.kt</code></li>\n<li>变更：在 <code>invalidate()</code> 中使用 <code>requestComposeVsyncAndNotify()</code> 替代 <code>notifyRedraw()</code></li>\n</ul>\n<ol>\n<li><strong>RenderNodeImplC.cpp</strong></li>\n</ol>\n<ul>\n<li>路径：<code>OHRender/OHRender/src/oh/RenderNodeImplC.cpp</code></li>\n<li>相关：<code>RequestComposeVsyncAndNotify()</code> 和 <code>OnNativeVsync()</code> 的实现</li>\n</ul>\n<h3><strong>相关 API</strong></h3>\n<ol>\n<li><strong><code>willDraw</code></strong><strong> 回调</strong></li>\n</ol>\n<ul>\n<li>ArkUI 框架提供的绘制前回调</li>\n<li>在每次绘制前触发</li>\n</ul>\n<ol>\n<li><strong><code>notifyRedraw()</code></strong></li>\n</ol>\n<ul>\n<li>直接触发重绘（不等待 VSYNC）</li>\n<li>已废弃，应该使用 VSYNC 驱动的方式</li>\n</ul>\n<ol>\n<li><strong><code>requestComposeVsyncAndNotify()</code></strong></li>\n</ol>\n<ul>\n<li>请求 VSYNC，在 VSYNC 回调中触发重绘</li>\n<li>确保重绘与帧信号对齐</li>\n</ul>\n<ol>\n<li><strong><code>invalidate()</code></strong></li>\n</ol>\n<ul>\n<li>Compose 层通知需要更新的接口</li>\n<li>应该在真正需要更新时调用</li>\n</ul>\n<hr />\n<h2><strong>注意事项</strong></h2>\n<h3><strong>1. VSYNC 驱动的重绘机制</strong></h3>\n<p><strong>理解要点</strong>：</p>\n<ul>\n<li>VSYNC 信号是<strong>显示器的刷新信号</strong>，不是 UI 更新的信号</li>\n<li>UI 更新应该<strong>响应状态变化</strong>，而不是响应 VSYNC</li>\n<li>VSYNC 只是用来<strong>对齐渲染时机</strong>，确保渲染与显示同步</li>\n</ul>\n<p><strong>正确流程</strong>：</p>\n<pre><code>UI 状态变化 → invalidate() → 请求 VSYNC → VSYNC 到达 → 执行渲染</code></pre>\n<p><strong>错误流程</strong>：</p>\n<pre><code>VSYNC 到达 → willDraw → notifyRedraw() → 执行渲染（即使没有 UI 变化）</code></pre>\n<hr />\n<h2><strong>总结</strong></h2>\n<h3><strong>问题根因</strong></h3>\n<p><strong><code>CanvasNode.ets</code></strong><strong> 中的 </strong><strong><code>willDraw</code></strong><strong> 回调无条件调用 </strong><strong><code>notifyRedraw()</code></strong>，导致：</p>\n<ul>\n<li>每次 VSYNC 信号到达时都会触发重绘请求</li>\n<li>即使没有实际的 UI 变化，也会执行渲染处理</li>\n<li>形成”VSYNC 空跑”问题</li>\n</ul>\n<h3><strong>解决方案</strong></h3>\n<ol>\n<li><strong>删除 </strong><strong><code>willDraw</code></strong><strong> 回调中的 </strong><strong><code>notifyRedraw()</code></strong><strong> 调用</strong></li>\n</ol>\n<ul>\n<li>避免无条件触发重绘请求</li>\n<li>打破死循环</li>\n</ul>\n<ol>\n<li><strong>在 </strong><strong><code>invalidate()</code></strong><strong> 中按需请求 VSYNC</strong></li>\n</ol>\n<ul>\n<li>使用 <code>requestComposeVsyncAndNotify()</code> 替代 <code>notifyRedraw()</code></li>\n<li>确保重绘与 VSYNC 信号对齐</li>\n<li>只在真正需要更新时才请求 VSYNC</li>\n</ul>\n<hr />"
        }
      ],
      "estimated_minutes": 21
    },
    {
      "module_id": "ohos-coil-abc42967",
      "title": "OHOS 下 Coil 自定义解码方案梳理",
      "source_path": "principle-analysis/coil库使用教程及自定义零拷贝方案的实现.md",
      "source_file_hash": "abc429679bf5631465478c6de241a281641ba6de",
      "split_mode": "auto",
      "render_version": 11,
      "difficulty": 3,
      "summary": "https://gitcode.com/RushC4/KuiklyBase-platform/blob/main/coil/README.md先使用这个链接在本地发布是配鸿蒙...",
      "sections": [
        {
          "section_id": "b07f3cf38b",
          "title": "0. Coil库的使用教程",
          "summary": "https://gitcode.com/RushC4/KuiklyBase-platform/blob/main/coil/README.md先使用这个链接在本地发布是配鸿蒙...",
          "key_points": [
            "https://gitcode.com/RushC4/KuiklyBase-platform/blob/main/coil/README.md先使用这个链接在本地发布是配鸿蒙化的Coil库，使用这个patchimage-20260209171517763",
            "在该目录下出现这个产物即发布成功.m2/repository/io/coil-kt/coil3/coil/3.0.4-OHOS-001，在Sample工程的libs.versions.toml文件下配置成如图所示",
            "image-20260209172154989",
            "在composeApp/build.gradle.kts文件中，按照如下方式配置，加入依赖的同时，也要链接so包"
          ],
          "estimated_minutes": 2,
          "content": "https://gitcode.com/RushC4/KuiklyBase-platform/blob/main/coil/README.md先使用这个链接在本地发布是配鸿蒙化的Coil库，使用这个patch![image-20260209171517763](/Users/zhangpanmac/Library/Application Support/typora-user-images/image-20260209171517763.png)\n\n在该目录下出现这个产物即发布成功.m2/repository/io/coil-kt/coil3/coil/3.0.4-OHOS-001，在Sample工程的libs.versions.toml文件下配置成如图所示                          \n\n![image-20260209172154989](/Users/zhangpanmac/Library/Application Support/typora-user-images/image-20260209172154989.png)\n\n在composeApp/build.gradle.kts文件中，按照如下方式配置，加入依赖的同时，也要链接so包\n\n![image-20260209172414680](/Users/zhangpanmac/Library/Application Support/typora-user-images/image-20260209172414680.png)![image-20260209172542933](/Users/zhangpanmac/Library/Application Support/typora-user-images/image-20260209172542933.png)\n\n此外，Ktor一般和Coil结合使用，拿到ktor产物后，放在如下目录：.m2/repository/io/ktor\n\n编写相关demo交给ai就好。会用到的包我放在了这个链接：https://docs.qq.com/space/DYWJqQm5OU2R3c3BJ?resourceId=altGLTMSHHXs&type=folder&mode=ai_mode\n\n![image-20260209173448158](/Users/zhangpanmac/Library/Application Support/typora-user-images/image-20260209173448158.png)",
          "content_html": "<p>https://gitcode.com/RushC4/KuiklyBase-platform/blob/main/coil/README.md先使用这个链接在本地发布是配鸿蒙化的Coil库，使用这个patch!<a href=\"../knowledge-map-assets/coil-abc42967-file-e620bdde09.png\" target=\"_blank\" rel=\"noopener noreferrer\">image-20260209171517763</a></p><p>在该目录下出现这个产物即发布成功.m2/repository/io/coil-kt/coil3/coil/3.0.4-OHOS-001，在Sample工程的libs.versions.toml文件下配置成如图所示</p><figure class=\"doc-figure\"><img src=\"../knowledge-map-assets/coil-abc42967-md-b8d5434e7c.png\" alt=\"image-20260209172154989\" loading=\"lazy\" referrerpolicy=\"no-referrer\" data-origin-src=\"../knowledge-map-assets/coil-abc42967-md-b8d5434e7c.png\" data-local-match=\"direct\" /><figcaption class=\"img-fallback\">图片加载失败，<a class=\"img-open-link\" href=\"../knowledge-map-assets/coil-abc42967-md-b8d5434e7c.png\" target=\"_blank\" rel=\"noopener noreferrer\">点击打开原图</a></figcaption></figure><p>在composeApp/build.gradle.kts文件中，按照如下方式配置，加入依赖的同时，也要链接so包</p><p>!<a href=\"../knowledge-map-assets/coil-abc42967-file-d23d2dd83b.png\" target=\"<em>blank\" rel=\"noopener noreferrer\">image-20260209172414680</a>!<a href=\"../knowledge-map-assets/coil-abc42967-file-47f58b4411.png\" target=\"</em>blank\" rel=\"noopener noreferrer\">image-20260209172542933</a></p><p>此外，Ktor一般和Coil结合使用，拿到ktor产物后，放在如下目录：.m2/repository/io/ktor</p><p>编写相关demo交给ai就好。会用到的包我放在了这个链接：https://docs.qq.com/space/DYWJqQm5OU2R3c3BJ?resourceId=altGLTMSHHXs&amp;type=folder&amp;mode=ai_mode</p><figure class=\"doc-figure\"><img src=\"../knowledge-map-assets/coil-abc42967-md-9e444f2eb5.png\" alt=\"image-20260209173448158\" loading=\"lazy\" referrerpolicy=\"no-referrer\" data-origin-src=\"../knowledge-map-assets/coil-abc42967-md-9e444f2eb5.png\" data-local-match=\"direct\" /><figcaption class=\"img-fallback\">图片加载失败，<a class=\"img-open-link\" href=\"../knowledge-map-assets/coil-abc42967-md-9e444f2eb5.png\" target=\"_blank\" rel=\"noopener noreferrer\">点击打开原图</a></figcaption></figure>"
        },
        {
          "section_id": "7cf7fdb34a",
          "title": "1. 这套方案在做什么",
          "summary": "这套方案的目标是： 保留 Coil 的请求/缓存/组件化能力。",
          "key_points": [
            "这套方案的目标是：",
            "保留 Coil 的请求/缓存/组件化能力。",
            "在 OHOS 上用自定义 Native 解码链路，把图片数据尽量直接走到 GPU（SurfaceBuffer -> EGLImage -> GL Texture -> SkImage）。",
            "在失败场景下自动回退到 Image.makeFromEncoded(bytes)，保证功能可用。"
          ],
          "estimated_minutes": 2,
          "content": "这套方案的目标是：\n- 保留 Coil 的请求/缓存/组件化能力。\n- 在 OHOS 上用自定义 Native 解码链路，把图片数据尽量直接走到 GPU（SurfaceBuffer -> EGLImage -> GL Texture -> SkImage）。\n- 在失败场景下自动回退到 `Image.makeFromEncoded(bytes)`，保证功能可用。\n\n一句话：\n**Coil 负责“拿图和调度”，自定义 Native 负责“高性能解码与贴图”。**\n\n---",
          "content_html": "<p>这套方案的目标是：</p><ul><li>保留 Coil 的请求/缓存/组件化能力。</li><li>在 OHOS 上用自定义 Native 解码链路，把图片数据尽量直接走到 GPU（SurfaceBuffer -&gt; EGLImage -&gt; GL Texture -&gt; SkImage）。</li><li>在失败场景下自动回退到 <code>Image.makeFromEncoded(bytes)</code>，保证功能可用。</li></ul><p>一句话： <strong>Coil 负责“拿图和调度”，自定义 Native 负责“高性能解码与贴图”。</strong></p><hr />"
        },
        {
          "section_id": "7a74b3a56e",
          "title": "2.1 ImageLoader 入口",
          "summary": "文件：composeApp/src/ohosArm64Main/kotlin/com/tencent/compose/sample/CoilKtorNetworkImageD...",
          "key_points": [
            "文件：composeApp/src/ohosArm64Main/kotlin/com/tencent/compose/sample/CoilKtorNetworkImageDemo.kt",
            "通过 setSingletonImageLoaderFactory 创建 ImageLoader。",
            "注册组件：",
            "DecoderProbeFactory()：自定义解码器入口（含日志探针）。"
          ],
          "estimated_minutes": 2,
          "content": "文件：`composeApp/src/ohosArm64Main/kotlin/com/tencent/compose/sample/CoilKtorNetworkImageDemo.kt`\n\n- 通过 `setSingletonImageLoaderFactory` 创建 `ImageLoader`。\n- 注册组件：\n  - `DecoderProbeFactory()`：自定义解码器入口（含日志探针）。\n  - `KtorNetworkFetcherFactory(httpClient)`：网络拉图。",
          "content_html": "<p>文件：<code>composeApp/src/ohosArm64Main/kotlin/com/tencent/compose/sample/CoilKtorNetworkImageDemo.kt</code></p><ul><li>通过 <code>setSingletonImageLoaderFactory</code> 创建 <code>ImageLoader</code>。</li><li>注册组件：<ul><li><code>DecoderProbeFactory()</code>：自定义解码器入口（含日志探针）。</li><li><code>KtorNetworkFetcherFactory(httpClient)</code>：网络拉图。</li></ul></li></ul>"
        },
        {
          "section_id": "8f890b5a0f",
          "title": "2.2 Decoder 探针",
          "summary": "文件：composeApp/src/ohosArm64Main/kotlin/com/tencent/compose/sample/CoilDecoderProbe.kt 读...",
          "key_points": [
            "文件：composeApp/src/ohosArm64Main/kotlin/com/tencent/compose/sample/CoilDecoderProbe.kt",
            "读取头部字节日志，记录 mime/dataSource。",
            "实际委托给 SkiaImageDecoder1。"
          ],
          "estimated_minutes": 2,
          "content": "文件：`composeApp/src/ohosArm64Main/kotlin/com/tencent/compose/sample/CoilDecoderProbe.kt`\n\n- 读取头部字节日志，记录 mime/dataSource。\n- 实际委托给 `SkiaImageDecoder1`。",
          "content_html": "<p>文件：<code>composeApp/src/ohosArm64Main/kotlin/com/tencent/compose/sample/CoilDecoderProbe.kt</code></p><ul><li>读取头部字节日志，记录 mime/dataSource。</li><li>实际委托给 <code>SkiaImageDecoder1</code>。</li></ul>"
        },
        {
          "section_id": "e5761dd61d",
          "title": "2.3 真正解码器",
          "summary": "文件：composeApp/src/ohosArm64Main/kotlin/com/tencent/compose/sample/coil.ohos.kt 核心类：Skia...",
          "key_points": [
            "文件：composeApp/src/ohosArm64Main/kotlin/com/tencent/compose/sample/coil.ohos.kt",
            "核心类：SkiaImageDecoder1。"
          ],
          "estimated_minutes": 2,
          "content": "文件：`composeApp/src/ohosArm64Main/kotlin/com/tencent/compose/sample/coil.ohos.kt`\n\n核心类：`SkiaImageDecoder1`。",
          "content_html": "<p>文件：<code>composeApp/src/ohosArm64Main/kotlin/com/tencent/compose/sample/coil.ohos.kt</code></p><p>核心类：<code>SkiaImageDecoder1</code>。</p>"
        },
        {
          "section_id": "4b5dd36822",
          "title": "2.4 Coil 图片适配层",
          "summary": "文件：composeApp/src/ohosArm64Main/kotlin/com/tencent/compose/sample/coil.imageAdapter.kt...",
          "key_points": [
            "文件：composeApp/src/ohosArm64Main/kotlin/com/tencent/compose/sample/coil.imageAdapter.kt",
            "SkiaImageAdapter 把 org.jetbrains.skia.Image 适配到 coil3.Image。",
            "draw() 时调用 canvas.drawImage(...)。"
          ],
          "estimated_minutes": 2,
          "content": "文件：`composeApp/src/ohosArm64Main/kotlin/com/tencent/compose/sample/coil.imageAdapter.kt`\n\n- `SkiaImageAdapter` 把 `org.jetbrains.skia.Image` 适配到 `coil3.Image`。\n- `draw()` 时调用 `canvas.drawImage(...)`。",
          "content_html": "<p>文件：<code>composeApp/src/ohosArm64Main/kotlin/com/tencent/compose/sample/coil.imageAdapter.kt</code></p><ul><li><code>SkiaImageAdapter</code> 把 <code>org.jetbrains.skia.Image</code> 适配到 <code>coil3.Image</code>。</li><li><code>draw()</code> 时调用 <code>canvas.drawImage(...)</code>。</li></ul>"
        },
        {
          "section_id": "e08bfe7c5f",
          "title": "2.5 Native GL 导入（外部仓库）",
          "summary": "文件：SkikoBridge/skikobridge/src/main/cpp/src/nativeJsMain/cpp/Image.cpp 核心函数： org_jetbra...",
          "key_points": [
            "文件：SkikoBridge/skikobridge/src/main/cpp/src/nativeJsMain/cpp/Image.cpp",
            "核心函数：",
            "org_jetbrains_skia_Image__1nMakeFromOhosSurfaceBuffer(...)",
            "org_jetbrains_skia_Image__1nDrainOhosSurfaceBufferReleases()"
          ],
          "estimated_minutes": 2,
          "content": "文件：`SkikoBridge/skikobridge/src/main/cpp/src/nativeJsMain/cpp/Image.cpp`\n\n核心函数：\n- `org_jetbrains_skia_Image__1nMakeFromOhosSurfaceBuffer(...)`\n- `org_jetbrains_skia_Image__1nDrainOhosSurfaceBufferReleases()`\n\n---",
          "content_html": "<p>文件：<code>SkikoBridge/skikobridge/src/main/cpp/src/nativeJsMain/cpp/Image.cpp</code></p><p>核心函数：</p><ul><li><code>org_jetbrains_skia_Image__1nMakeFromOhosSurfaceBuffer(...)</code></li><li><code>org_jetbrains_skia_Image__1nDrainOhosSurfaceBufferReleases()</code></li></ul><hr />"
        },
        {
          "section_id": "86f237c481",
          "title": "3. 端到端流程（从 URL 到上屏）",
          "summary": "mermaid flowchart TD A[\"Coil 请求图片\"] --> B[\"KtorNetworkFetcher<br/>下载字节\"] B --> C[\"Decod...",
          "key_points": [
            "mermaid",
            "flowchart TD",
            "A[\"Coil 请求图片\"] --> B[\"KtorNetworkFetcher<br/>下载字节\"]",
            "B --> C[\"DecoderProbeFactory<br/>选择 SkiaImageDecoder1\"]"
          ],
          "estimated_minutes": 2,
          "content": "```mermaid\nflowchart TD\n  A[\"Coil 请求图片\"] --> B[\"KtorNetworkFetcher<br/>下载字节\"]\n  B --> C[\"DecoderProbeFactory<br/>选择 SkiaImageDecoder1\"]\n  C --> D[\"读取 ByteArray\"]\n  D --> E{\"context 是否可用\"}\n  E -- \"否\" --> F[\"Image.makeFromEncoded<br/>回退\"]\n  E -- \"是\" --> G[\"decodeToSurfaceBuffer\"]\n  G --> H[\"SurfaceBuffer 指针\"]\n  H --> I[\"Main 线程调用<br/>makeFromOhosSurfaceBuffer\"]\n  I --> J[\"SurfaceBuffer -> EGLImage<br/>-> GL Texture\"]\n  J --> K[\"BorrowTextureFrom<br/>生成 SkImage\"]\n  K --> L[\"releaseSurfaceBuffer<br/>释放调用方引用\"]\n  L --> M[\"SkiaImageAdapter 返回给 Coil\"]\n  M --> N[\"Compose/Coil drawImage 上屏\"]\n```\n\n---",
          "content_html": "<pre><code class=\"language-mermaid\">flowchart TD\n  A[\"Coil 请求图片\"] --&gt; B[\"KtorNetworkFetcher&lt;br/&gt;下载字节\"]\n  B --&gt; C[\"DecoderProbeFactory&lt;br/&gt;选择 SkiaImageDecoder1\"]\n  C --&gt; D[\"读取 ByteArray\"]\n  D --&gt; E{\"context 是否可用\"}\n  E -- \"否\" --&gt; F[\"Image.makeFromEncoded&lt;br/&gt;回退\"]\n  E -- \"是\" --&gt; G[\"decodeToSurfaceBuffer\"]\n  G --&gt; H[\"SurfaceBuffer 指针\"]\n  H --&gt; I[\"Main 线程调用&lt;br/&gt;makeFromOhosSurfaceBuffer\"]\n  I --&gt; J[\"SurfaceBuffer -&gt; EGLImage&lt;br/&gt;-&gt; GL Texture\"]\n  J --&gt; K[\"BorrowTextureFrom&lt;br/&gt;生成 SkImage\"]\n  K --&gt; L[\"releaseSurfaceBuffer&lt;br/&gt;释放调用方引用\"]\n  L --&gt; M[\"SkiaImageAdapter 返回给 Coil\"]\n  M --&gt; N[\"Compose/Coil drawImage 上屏\"]</code></pre><hr />"
        },
        {
          "section_id": "1ae77104eb",
          "title": "4. Kotlin 侧详细逻辑（`SkiaImageDecoder1.decode`）",
          "summary": "按执行顺序： 读全量字节：source.source().use { it.readByteArray() } 空输入保护：bytes.isEmpty() 直接 return...",
          "key_points": [
            "按执行顺序：",
            "读全量字节：source.source().use { it.readByteArray() }",
            "空输入保护：bytes.isEmpty() 直接 return null",
            "计算目标尺寸（用于 isSampled 标记）"
          ],
          "estimated_minutes": 2,
          "content": "按执行顺序：\n1. 读全量字节：`source.source().use { it.readByteArray() }`\n2. 空输入保护：`bytes.isEmpty()` 直接 `return null`\n3. 计算目标尺寸（用于 `isSampled` 标记）\n4. 读取 `xcomponentDirectContext`\n5. 分支：\n   - `context == null`：直接 `Image.makeFromEncoded(bytes)`\n   - `context != null`：\n     - 调 `androidx_compose_ui_arkui_utils_decodeToSurfaceBuffer(...)`\n     - 在 `Dispatchers.Main` 调 `Image.makeFromOhosSurfaceBuffer(...)`\n     - 失败时 fallback 到 `Image.makeFromEncoded(bytes)`\n     - `finally` 调 `androidx_compose_ui_arkui_utils_releaseSurfaceBuffer(...)`\n6. 封装 `DecodeResult(image = SkiaImageAdapter(image), isSampled = ...)`\n\n说明：\n- 之所以在主线程调用 `makeFromOhosSurfaceBuffer`，是因为 GL/EGL 上下文通常绑定在渲染线程/主线程。\n- `finally` 保证 `surfaceBuffer` 调用方引用一定释放。\n\n---",
          "content_html": "<p>按执行顺序：</p><ol><li>读全量字节：<code>source.source().use { it.readByteArray() }</code></li><li>空输入保护：<code>bytes.isEmpty()</code> 直接 <code>return null</code></li><li>计算目标尺寸（用于 <code>isSampled</code> 标记）</li><li>读取 <code>xcomponentDirectContext</code></li><li>分支：<ul><li><code>context == null</code>：直接 <code>Image.makeFromEncoded(bytes)</code></li><li><code>context != null</code>：<ul><li>调 <code>androidx_compose_ui_arkui_utils_decodeToSurfaceBuffer(...)</code></li><li>在 <code>Dispatchers.Main</code> 调 <code>Image.makeFromOhosSurfaceBuffer(...)</code></li><li>失败时 fallback 到 <code>Image.makeFromEncoded(bytes)</code></li><li><code>finally</code> 调 <code>androidx_compose_ui_arkui_utils_releaseSurfaceBuffer(...)</code></li></ul></li></ul></li><li>封装 <code>DecodeResult(image = SkiaImageAdapter(image), isSampled = ...)</code></li></ol><p>说明：</p><ul><li>之所以在主线程调用 <code>makeFromOhosSurfaceBuffer</code>，是因为 GL/EGL 上下文通常绑定在渲染线程/主线程。</li><li><code>finally</code> 保证 <code>surfaceBuffer</code> 调用方引用一定释放。</li></ul><hr />"
        },
        {
          "section_id": "e33d49addf",
          "title": "5. Native 侧详细逻辑（`makeFromOhosSurfaceBuffer`）",
          "summary": "文件：Image.cpp（SkikoBridge） 核心步骤： 参数判空，校验 EGLContext 当前可用。",
          "key_points": [
            "文件：Image.cpp（SkikoBridge）",
            "核心步骤：",
            "参数判空，校验 EGLContext 当前可用。",
            "DrainOhosReleaseQueueOnCurrentGLThread()：先清理上一批异步入队释放资源。"
          ],
          "estimated_minutes": 2,
          "content": "文件：`Image.cpp`（SkikoBridge）\n\n核心步骤：\n1. 参数判空，校验 `EGLContext` 当前可用。\n2. `DrainOhosReleaseQueueOnCurrentGLThread()`：先清理上一批异步入队释放资源。\n3. `OH_NativeWindow_CreateNativeWindowBufferFromNativeBuffer(surfaceBuffer)`。\n4. `eglCreateImageKHR(..., EGL_NATIVE_BUFFER_OHOS, nativeWindowBuffer, ...)` 创建 `EGLImage`。\n5. 创建 `GL_TEXTURE_2D`，`glEGLImageTargetTexture2DOES` 绑定图像。\n6. 通过 `GrBackendTexture + SkImages::BorrowTextureFrom(...)` 生成 `SkImage`。\n\n为了修复“图片上屏后文字乱码”，增加了：\n- 保存/恢复 GL 状态：`GL_ACTIVE_TEXTURE`、`GL_TEXTURE_BINDING_2D`\n- `context->resetContext(kAll_GrBackendState)` 告知 Skia 外部 GL 状态发生变化\n\n---",
          "content_html": "<p>文件：<code>Image.cpp</code>（SkikoBridge）</p><p>核心步骤：</p><ol><li>参数判空，校验 <code>EGLContext</code> 当前可用。</li><li><code>DrainOhosReleaseQueueOnCurrentGLThread()</code>：先清理上一批异步入队释放资源。</li><li><code>OH_NativeWindow_CreateNativeWindowBufferFromNativeBuffer(surfaceBuffer)</code>。</li><li><code>eglCreateImageKHR(..., EGL_NATIVE_BUFFER_OHOS, nativeWindowBuffer, ...)</code> 创建 <code>EGLImage</code>。</li><li>创建 <code>GL_TEXTURE_2D</code>，<code>glEGLImageTargetTexture2DOES</code> 绑定图像。</li><li>通过 <code>GrBackendTexture + SkImages::BorrowTextureFrom(...)</code> 生成 <code>SkImage</code>。</li></ol><p>为了修复“图片上屏后文字乱码”，增加了：</p><ul><li>保存/恢复 GL 状态：<code>GL_ACTIVE_TEXTURE</code>、<code>GL_TEXTURE_BINDING_2D</code></li><li><code>context-&gt;resetContext(kAll_GrBackendState)</code> 告知 Skia 外部 GL 状态发生变化</li></ul><hr />"
        },
        {
          "section_id": "22ff841717",
          "title": "6. 资源生命周期模型（重点）",
          "summary": "你当前实现采用“延迟回收队列”模型： OhosTextureReleaseProc 不直接销毁 GL/EGL 资源（它可能运行在非 GL 线程）。",
          "key_points": [
            "你当前实现采用“延迟回收队列”模型：",
            "OhosTextureReleaseProc 不直接销毁 GL/EGL 资源（它可能运行在非 GL 线程）。",
            "只把 releaseCtx 入队。",
            "在有 current EGLContext 的线程调用 DrainOhosReleaseQueueOnCurrentGLThread 真正释放。"
          ],
          "estimated_minutes": 2,
          "content": "你当前实现采用“延迟回收队列”模型：\n- `OhosTextureReleaseProc` 不直接销毁 GL/EGL 资源（它可能运行在非 GL 线程）。\n- 只把 `releaseCtx` 入队。\n- 在有 current EGLContext 的线程调用 `DrainOhosReleaseQueueOnCurrentGLThread` 真正释放。\n\n`releaseCtx` 当前持有：\n- `textureId`\n- `EGLImageKHR`\n- `OHNativeWindowBuffer*`\n- `OH_NativeBuffer*`（带引用计数）\n\n释放顺序：\n1. `glDeleteTextures`\n2. `eglDestroyImageKHR`\n3. `OH_NativeWindow_DestroyNativeWindowBuffer`\n4. `OH_NativeBuffer_Unreference`\n\n这样可以避免：\n- 非 GL 线程销毁纹理导致崩溃\n- NativeBuffer 提前释放导致悬挂\n- early-return 泄漏\n\n---",
          "content_html": "<p>你当前实现采用“延迟回收队列”模型：</p><ul><li><code>OhosTextureReleaseProc</code> 不直接销毁 GL/EGL 资源（它可能运行在非 GL 线程）。</li><li>只把 <code>releaseCtx</code> 入队。</li><li>在有 current EGLContext 的线程调用 <code>DrainOhosReleaseQueueOnCurrentGLThread</code> 真正释放。</li></ul><p><code>releaseCtx</code> 当前持有：</p><ul><li><code>textureId</code></li><li><code>EGLImageKHR</code></li><li><code>OHNativeWindowBuffer*</code></li><li><code>OH_NativeBuffer*</code>（带引用计数）</li></ul><p>释放顺序：</p><ol><li><code>glDeleteTextures</code></li><li><code>eglDestroyImageKHR</code></li><li><code>OH_NativeWindow_DestroyNativeWindowBuffer</code></li><li><code>OH_NativeBuffer_Unreference</code></li></ol><p>这样可以避免：</p><ul><li>非 GL 线程销毁纹理导致崩溃</li><li>NativeBuffer 提前释放导致悬挂</li><li>early-return 泄漏</li></ul><hr />"
        },
        {
          "section_id": "5fd1a87352",
          "title": "7. 与旧方案相比的主要收益",
          "summary": "更高的 GPU 亲和路径 通过 SurfaceBuffer/EGLImage 直连 GL 纹理，减少中间拷贝。",
          "key_points": [
            "更高的 GPU 亲和路径",
            "通过 SurfaceBuffer/EGLImage 直连 GL 纹理，减少中间拷贝。",
            "稳定性增强",
            "补齐失败回滚和引用计数释放。"
          ],
          "estimated_minutes": 2,
          "content": "1. 更高的 GPU 亲和路径\n- 通过 SurfaceBuffer/EGLImage 直连 GL 纹理，减少中间拷贝。\n\n2. 稳定性增强\n- 补齐失败回滚和引用计数释放。\n- 增加 fallback 路径，确保 decode 失败仍可展示。\n\n3. 修复 GL 状态污染\n- 通过状态恢复 + `resetContext` 修复了“文字乱码”问题。\n\n---",
          "content_html": "<ol><li>更高的 GPU 亲和路径</li></ol><ul><li>通过 SurfaceBuffer/EGLImage 直连 GL 纹理，减少中间拷贝。</li></ul><ol><li>稳定性增强</li></ol><ul><li>补齐失败回滚和引用计数释放。</li><li>增加 fallback 路径，确保 decode 失败仍可展示。</li></ul><ol><li>修复 GL 状态污染</li></ol><ul><li>通过状态恢复 + <code>resetContext</code> 修复了“文字乱码”问题。</li></ul><hr />"
        }
      ],
      "estimated_minutes": 24
    },
    {
      "module_id": "savelayer-b18a6be3",
      "title": "saveLayer 实现方案解析",
      "source_path": "principle-analysis/saveLayer 实现方案解析.docx",
      "source_file_hash": "b18a6be352c391529c759f280297effbf33d5558",
      "split_mode": "auto",
      "render_version": 11,
      "difficulty": 3,
      "summary": "saveLayer 实现方案解析 文档目标：从渲染管线原理出发，由浅入深地剖析 saveLayer 在 OHRender 渲染路线中的完整实现链路 涵盖层次：Kotlin (...",
      "sections": [
        {
          "section_id": "76481f50bc",
          "title": "saveLayer 实现方案解析",
          "summary": "saveLayer 实现方案解析 文档目标：从渲染管线原理出发，由浅入深地剖析 saveLayer 在 OHRender 渲染路线中的完整实现链路 涵盖层次：Kotlin (...",
          "key_points": [
            "渲染管线原理：saveLayer 的作用",
            "实现链路总览",
            "第一层：Kotlin/Compose 侧",
            "第二层：Skiko JNI 桥接"
          ],
          "estimated_minutes": 58,
          "content": "saveLayer 实现方案解析\n\n文档目标：从渲染管线原理出发，由浅入深地剖析 saveLayer 在 OHRender 渲染路线中的完整实现链路\n\n涵盖层次：Kotlin (Compose) → Skiko (JNI/KNI) → OHRender (C++) → HarmonyOS Native (OH_Drawing)\n\n生成日期：2025年12月12日\n\n1. 渲染管线原理：saveLayer 的作用\n\n1.1 什么是 saveLayer 和 restore？\n\n在 2D 图形渲染中，saveLayer 和 restore 是一对配合使用的 API，共同实现离屏渲染（Offscreen Rendering）机制。\n\nsaveLayer 的作用：\n\n创建临时图层：在当前 Canvas 之外开辟一个新的绘图表面（Layer）\n\n重定向绘制指令：后续的 drawRect、drawPath 等操作都绘制到这个临时图层\n\n保存状态：将当前的变换矩阵（CTM）、裁剪区域（Clip）、Paint 属性压入状态栈\n\nrestore 的作用：\n\n图层合成：将离屏图层作为一个整体，应用 saveLayer 时指定的 Paint 特效（透明度、混合模式、滤镜）后，合成回主 Canvas\n\n状态恢复：从状态栈中弹出之前保存的 CTM、Clip 等状态，恢复到 saveLayer 调用前的绘制环境\n\n资源释放：销毁临时图层，释放离屏缓冲区内存\n\n核心配合关系：\n\nsaveLayer 相当于\"开启录制\"，创建新舞台\n\n中间的绘制指令在\"离屏舞台\"上表演\n\nrestore 相当于\"停止录制并播放\"，将录制内容合成到主舞台\n\n1.2 为什么需要 saveLayer？\n\n问题场景：假设要绘制两个重叠的半透明矩形\n\n// ❌ 不使用 saveLayer（错误效果） canvas.drawRect(rect1, Paint().apply { alpha = 128 }) canvas.drawRect(rect2, Paint().apply { alpha = 128 }) // 结果：重叠区域会比单独区域更暗（alpha 叠加）\n\n// ✅ 使用 saveLayer（正确效果） canvas.saveLayer(bounds, Paint().apply { alpha = 128 }) canvas.drawRect(rect1, Paint().apply { color = Color.Red }) canvas.drawRect(rect2, Paint().apply { color = Color.Blue }) canvas.restore() // 结果：两个矩形先在图层上以不透明方式绘制，然后整个图层以 50% 透明度合成\n\n1.3 渲染管线视角的三层理解\n\n层次\n\n概念\n\n物理实现\n\n逻辑层 (Compose)\n\n保存 CTM/Clip 状态，开启\"离屏录制\"\n\n状态栈压入，标记 isLayer=true\n\n执行层 (渲染引擎)\n\n切换 Render Target，临时缓冲区接收绘制\n\nGPU 命令缓冲区切换，FBO (FrameBuffer Object) 分配\n\n物理层 (HarmonyOS)\n\n系统级离屏 Canvas 创建\n\nOH_Drawing_CanvasSaveLayer 调用，内存缓冲分配\n\n关键原理：\n\n抗锯齿裁剪：复杂裁剪（圆角、Path）的边缘需要平滑处理，saveLayer 确保先在图层内绘制完整内容，再统一应用抗锯齿裁剪\n\n群组透明：多个图形作为整体应用透明度，避免重叠区域透明度累加\n\n滤镜效果：ColorFilter、ImageFilter 等需要在独立图层上生效\n\n2. 实现链路总览\n\n完整路径：\n\nKotlin → androidx.compose.ui.graphics.Canvas.saveLayer\n\nSkiko → org.jetbrains.skia.Canvas.saveLayer (Kotlin/Native)\n\nJNI → Canvas.cc::org_jetbrains_skia_Canvas__1nSaveLayerRect\n\nOHRender → SkCanvas.cpp::internalSaveLayer\n\nHarmonyOS → OH_Drawing_CanvasSaveLayer (系统 Native API)\n\n3. 第一层：Kotlin/Compose 侧\n\n3.1 接口定义\n\n文件位置：\n\ncompose/ui/ui-graphics/src/commonMain/kotlin/androidx/compose/ui/graphics/Canvas.kt\n\ninterface Canvas { /** * Saves a copy of the current transform and clip on the save stack, and then * creates a new group which subsequent calls will become a part of. When the * save stack is later popped, the group will be flattened into a layer and * have the given `paint`'s [Paint.colorFilter] and [Paint.blendMode] * applied. */ fun saveLayer(bounds: Rect, paint: Paint) }\n\n关键点：\n\nbounds：图层的边界矩形，限定离屏渲染区域（可优化内存占用）\n\npaint：合成时应用的画笔属性（透明度、混合模式、滤镜等）\n\n3.2 实现类\n\n文件位置：\n\ncompose/ui/ui-graphics/src/skikoMain/kotlin/androidx/compose/ui/graphics/SkiaBackedCanvas.skiko.kt\n\nsaveLayer 实现\n\ninternal class SkiaBackedCanvas(val skia: org.jetbrains.skia.Canvas) : Canvas { override fun saveLayer(bounds: Rect, paint: Paint) { if (EnableSkiaBackedCanvasLog) { kLog(\"[SkiaBackedCanvas] saveLayer $bounds\") } skia.saveLayer( bounds.left, bounds.top, bounds.right, bounds.bottom, paint.skia // 转换为 Skiko 的 Paint 对象 ) } }\n\nrestore 实现\n\ninternal class SkiaBackedCanvas(val skia: org.jetbrains.skia.Canvas) : Canvas { override fun restore() { if (EnableSkiaBackedCanvasLog) { kLog(\"[SkiaBackedCanvas] restore\") } skia.restore() // 调用 Skiko 的 restore，触发图层合成 } }\n\n职责：\n\nsaveLayer：将 Compose 的 Rect/Paint 类型转换为 Skiko 的原生类型\n\nrestore：无需参数，直接调用 Skiko 的 restore() 方法\n\n可选地输出调试日志（通过 EnableSkiaBackedCanvasLog 开关）\n\n4. 第二层：Skiko JNI 桥接\n\n4.1 JNI 入口\n\n文件位置：skiko/src/nativeJsMain/cpp/Canvas.cc\n\nsaveLayer JNI 绑定\n\nSKIKO_EXPORT KInt org_jetbrains_skia_Canvas__1nSaveLayerRect( KNativePointer ptr, // Canvas 指针 KFloat left, KFloat top, // 矩形边界 KFloat right, KFloat bottom, KNativePointer paintPtr // Paint 指针 ) { // 1. 指针类型恢复 SkCanvas* canvas = reinterpret_cast<SkCanvas*>(ptr); SkPaint* paint = reinterpret_cast<SkPaint*>(paintPtr); // 2. 构造矩形 SkRect bounds {left, top, right, bottom}; // 3. 调用 OHRender 的 C++ 实现 return canvas->saveLayer(&bounds, paint); }\n\nrestore JNI 绑定\n\nSKIKO_EXPORT void org_jetbrains_skia_Canvas__1nRestore(KNativePointer ptr) { // 直接调用 SkCanvas 的 restore 方法 reinterpret_cast<SkCanvas*>(ptr)->restore(); }\n\n关键机制：\n\n指针传递：Kotlin/Native 侧通过 Long 类型传递 C++ 对象的内存地址\n\nsaveLayer 公共接口\n\nint SkCanvas::saveLayer(const SkRect* bounds, const SkPaint* paint) { return this->saveLayer(SaveLayerRec(bounds, paint, 0)); } int SkCanvas::saveLayer(const SaveLayerRec& rec) { TRACE_EVENT0(\"skia\", TRACE_FUNC); SaveLayerStrategy strategy = this->getSaveLayerStrategy(rec); this->willSaveLayer(rec); if (strategy == kFullLayer_SaveLayerStrategy) { this->internalSaveLayer(rec, strategy); } return this->getSaveCount() - 1; }\n\nrestore 公共接口\n\nvoid SkCanvas::restore() { // 处理子 Canvas 的情况（用于某些特殊渲染路径） if (fSubCanvas && fSubCanvas->getSaveCount() == 1) { finishSubCanvas(); fNeedCreateSubCanvas = true; } if (fSubCanvas) { SkASSERT(fSubCanvas->getSaveCount() > 1); fSubCanvas->restore(); return; } // 检查栈深度，防止 underflow if (fSaveCount > fInitSaveCount) { fSaveCount -= 1; this->internalRestore(); // 调用内部实现 } Rec(bounds, paint, 0)); } int SkCanvas::saveLayer(const SaveLayerRec& rec) { TRACE_EVENT0(\"skia\", TRACE_FUNC); SaveLayerStrategy strategy = this->getSaveLayerStrategy(rec); this->willSaveLayer(rec); if (strategy == kFullLayer_SaveLayerStrategy) { this->internalSaveLayer(rec, strategy); } return this->getSaveCount() - 1; }\n\n5.2 核心实现：internalSaveLayer\n\n文件位置：OHRender/src/core/SkCanvas.cpp (行 1052-1147)\n\nvoid SkCanvas::internalSaveLayer(const SaveLayerRec& rec, SaveLayerStrategy strategy) { TRACE_EVENT0(\"skia\", TRACE_FUNC); // === 1. 状态压栈 === fSaveCount += 1; CanvasState state; state.fIsLayer = true; state.fSaveLayerFlag = true; state.fNotInv = fNotInv; state.fClip = fCullRect; // 当前裁剪区域 state.fTransform = fCTM; // 当前变换矩阵 state.fInvTransform = fInvCTM; // 逆变换矩阵 state.fClipShape = fClipShape; // 裁剪形状 state.fPendingDifferenceShape = fPendingDifferenceShape; if (rec.fPaint) { state.fPaint = *rec.fPaint; state.fPaint->setMaskFilter(nullptr); // MaskFilter 在合成时应用 state.fPaint->setAntiAlias(true); } fStateStack.push_back(state); // 压入状态栈 // === 2. 裁剪区域更新 === bool needHashClip = false; bool needHashBounds = false; if (rec.fBounds) { if (fCullRect.has_value()) { auto realBounds = fCTM.mapRect(*rec.fBounds); // 变换到设备坐标 if (realBounds.contains(fCullRect.value())) { needHashClip = true; } if (!fCullRect->intersect(realBounds)) { fCullRect = SkRect::MakeEmpty(); } else { if (!needHashClip) { needHashClip = true; needHashBounds = true; } } } else { fCullRect = fCTM.mapRect(*rec.fBounds); needHashBounds = true; } } else { needHashClip = true; } // === 3. Hash 计算（用于渲染节点去重/缓存）=== if (fEnableHash) { fHasher.push(HASH_UNIQUE_ID); fHasher.push(fCTM.hash()); if (needHashClip) { fHasher.push(GetClipShapeHash(fClipShape)); fHasher.push(GetClipShapeHash(fPendingDifferenceShape)); } if (needHashBounds) { fHasher.pushArray(rec.fBounds, 1); } if (state.fPaint) { fHasher.push(state.fPaint->hash()); } } // === 4. 绘制边界更新 === if (PaintMayAffectTransparentBlack(rec.fPaint)) { if (fCullRect.has_value() && fDrawBounds.has_value()) { fDrawBounds->join(fCullRect.value()); } else { fDrawBounds = std::nullopt; // 图层可能影响透明区域 } } // === 5. 渲染成本计算（Raster Cache 决策）=== if (OHRenderNode::gEnableRasterCache && !fForbidRasterCache && !fCullRect->isEmpty()) { float costPerPixel = 1 + 1; // 默认：读取 + 写入 if (state.fPaint) { costPerPixel = state.fPaint->computePerPixelCost(fCullRect.value()); } float thisCost = fCullRect->width() * fCullRect->height() * (costPerPixel + 1); fDrawCost += thisCost; if (thisCost > 10) { fDrawCost += doRealClipCost(); // 复杂裁剪的额外成本 } } // === 6. Paint 属性同步到 HarmonyOS Painter === if (state.fPaint) { state.fPaint->updateOHPainter(); } // === 7. 调用 HarmonyOS 系统 API === OH_Drawing_CanvasSaveLayer( fDrawingCanvas, (const OH_Drawing_Rect *)rec.fBounds, (state.fPaint ? (OH_Drawing_Brush *)(*state.fPaint) : nullptr) ); }\n\n5.3 Paint 属性映射\n\n文件位置：OHRender/src/core/SkPaint.cpp\n\nvoid SkPaint::updateOHPainter() const { hasUpdate = true; gOHPainter.updateOHPainter(*this); } void OHPainter::updateOHPainter(const SkPaint &painter) { // === PathEffect === { OH_Drawing_PathEffect *newEffect = nullptr; if (painter.fPathEffect) { newEffect = *as_PEB(painter.fPathEffect); } if (newEffect != fPathEffect) { OH_Drawing_PenSetPathEffect(fOHPen, newEffect); fPathEffect = newEffect; } } // === ShaderEffect === { OH_Drawing_ShaderEffect *newEffect = nullptr; if (painter.fShader) { newEffect = *as_SB(painter.fShader); } if (newEffect != fShaderEffect) { OH_Drawing_PenSetShaderEffect(fOHPen, newEffect); OH_Drawing_BrushSetShaderEffect(fOHBrush, newEffect); fShaderEffect = newEffect; } } // === Filter (Mask/Color/Image) === bool filterHasChange = false; { OH_Drawing_MaskFilter *newFilter = nullptr; if (painter.fMaskFilter) { newFilter = *as_MFB(painter.fMaskFilter); } if (newFilter != fMashFilter) { OH_Drawing_FilterSetMaskFilter(fOHFilter, newFilter); fMashFilter = newFilter; filterHasChange = true; } } // ... ColorFilter、ImageFilter 类似处理 ... if (filterHasChange) { OH_Drawing_PenSetFilter(fOHPen, fOHFilter); OH_Drawing_BrushSetFilter(fOHBrush, fOHFilter); } // === BlendMode === auto blendMode = painter.asBlendMode(); if (blendMode) { SkBlendMode b = blendMode.value(); OH_Drawing_PenSetBlendMode(fOHPen, (OH_Drawing_BlendMode)b); OH_Drawing_BrushSetBlendMode(fOHBrush, (OH_Drawing_BlendMode)b); } // === 基础属性 === OH_Drawing_PenSetColor(fOHPen, painter.getColor()); OH_Drawing_BrushSetColor(fOHBrush, painter.getColor()); }\n\n5.4 核心实现：internalRestore\n\n文件位置：OHRender/src/core/SkCanvas.cpp (行 1199-1215)\n\nvoid SkCanvas::internalRestore() { // === 1. 获取栈顶状态 === auto& topLayer = fStateStack.back(); // === 2. 裁剪状态检查（用于 Raster Cache 优化）=== if (OHRenderNode::gEnableRasterCache && !fForbidRasterCache && fNowDrawClipShape != topLayer.fClipShape) { fNeedDoClip = true; // 标记需要重新应用裁剪 } // === 3. 恢复画布状态 === fNotInv = topLayer.fNotInv; // 恢复矩阵可逆性标志 fCTM = topLayer.fTransform; // 恢复变换矩阵 fInvCTM = topLayer.fInvTransform; // 恢复逆变换矩阵 fCullRect = topLayer.fClip; // 恢复裁剪矩形 fClipShape = topLayer.fClipShape; // 恢复裁剪形状 fPendingDifferenceShape = topLayer.fPendingDifferenceShape;// 恢复待处理的差集裁剪 // === 4. Hash 更新（用于渲染节点缓存）=== if (topLayer.fSaveLayerFlag && fEnableHash) { fHasher.push(HASH_UNIQUE_ID); // 记录 restore 操作到 Hash } // === 5. 弹出状态栈 === fStateStack.pop_back(); // === 6. 调用 HarmonyOS 系统 API === // 如果是 saveLayer，会触发图层合成；如果是普通 save，仅恢复状态 OH_Drawing_CanvasRestore(fDrawingCanvas); }\n\n关键逻辑：\n\n状态恢复顺序：必须先恢复内存中的状态（CTM、Clip），再调用系统 API\n\n图层合成：OH_Drawing_CanvasRestore 内部会判断栈顶是否为 Layer，如果是则执行合成\n\n裁剪优化：检测裁剪形状变化，用于 Raster Cache 的失效判断\n\n栈平衡：每次 restore 必须对应一次 save 或 saveLayer\n\nOH_Drawing_PenSetWidth(fOHPen, painter.getStrokeWidth());\n\nOH_Drawing_PenSetMiterLimit(fOHPen, painter.getStrokeMiter());\n\nOH_Drawing_PenSetAntiAlias(fOHPen, painter.isAntiAlias());\n\nOH_Drawing_CanvasRestore 系统 API\n\nAPI 签名（根据 OpenHarmony 文档）：\n\n/** * @brief Restores the canvas state from the save stack. * If the saved state was created by OH_Drawing_CanvasSaveLayer, * this will also composite the layer back to the parent canvas. * * @param canvas Pointer to an OH_Drawing_Canvas object. * * @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing */ void OH_Drawing_CanvasRestore(OH_Drawing_Canvas* canvas);\n\n系统行为：\n\n状态恢复：\n\n从内部栈中弹出保存的状态（CTM、Clip 等）\n\n恢复到 save() 或 saveLayer() 调用前的绘制环境\n\n图层合成（仅当栈顶为 Layer 时）：\n\n将离屏缓冲区作为纹理，应用 saveLayer 时指定的 brush 属性\n\n执行 GPU Blend 操作（Alpha、BlendMode、Filter）\n\n将合成结果绘制到父 Canvas\n\n资源清理：\n\n释放离屏缓冲区内存\n\n销毁临时的渲染目标（FBO）\n\n6.4 典型调用流程\n\n// === 创建图层 === OH_Drawing_Rect layerBounds = {0, 0, 200, 200}; OH_Drawing_Brush* layerBrush = OH_Drawing_BrushCreate(); OH_Drawing_BrushSetAlpha(layerBrush, 128); // 50% 透明 OH_Drawing_BrushSetBlendMode(layerBrush, BLEND_MODE_SRC_OVER); int saveCount = OH_Drawing_CanvasSaveLayer(canvas, &layerBounds, layerBrush); // === 在图层上绘制 === OH_Drawing_CanvasDrawRect(canvas, &rect1); OH_Drawing_CanvasDrawCircle(canvas, x, y, radius); // === 恢复并合成图层 === OH_Drawing_CanvasRestore(canvas); // ↑ 内部执行： // 1. 弹出状态栈 // 2. 应用 layerBrush 的 Alpha/BlendMode 进行图层合成 // 3. 释放离屏缓冲区\n\n关键时序：\n\nOH_Drawing_CanvasSaveLayer → 创建离屏缓冲 + 切换渲染目标 ↓ 绘制指令写入离屏缓冲 ↓ OH_Drawing_CanvasRestore → 合成图层 + 恢复状态 + 释放资源\n\n增量更新：只有发生变化的属性才调用 HarmonyOS API（避免重复设置）\n\n全局 Painter：gOHPainter 是全局单例，管理 OH_Drawing_Pen 和 OH_Drawing_Brush\n\n类型映射：Skia 的 SkBlendMode、SkStrokeCap 等枚举直接映射到 HarmonyOS 的对应枚举\n\n6. 第四层：HarmonyOS Native API\n\n6.1 系统调用\n\nAPI 签名（根据 OpenHarmony 文档）：\n\n/** * @brief Saves the current canvas state (including clip and transformation) onto the save stack * and creates a new layer with specified bounds and brush properties. * * @param canvas Pointer to an OH_Drawing_Canvas object. * @param bounds Optional. Pointer to an OH_Drawing_Rect that defines the layer bounds. * If nullptr, the layer uses the entire canvas. * @param brush Optional. Pointer to an OH_Drawing_Brush for layer composition. * Controls alpha, blend mode, color filter, etc. when the layer is restored. * * @return The save count (depth of the save stack). * * @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing */ int OH_Drawing_CanvasSaveLayer( OH_Drawing_Canvas* canvas, const OH_Drawing_Rect* bounds, const OH_Drawing_Brush* brush );\n\n6.2 系统行为\n\n图层生命周期\n\n7.4 关键数据传递\n\n阶段\n\n数据\n\n来源\n\n目标\n\nKotlin → Skiko\n\nRect , Paint\n\nCompose 对象\n\nSkiko 包装对象\n\nSkiko → JNI\n\n指针地址 ( Long )\n\nKotlin/Native\n\nC++ 指针\n\nOHRender → HarmonyOS\n\nOH_Drawing_Rect* , OH_Drawing_Brush*\n\nSkPaint 映射\n\n系统 API\n\nHarmonyOS → GPU\n\n离屏缓冲区句柄\n\n系统分配\n\nGPU FBO\n\nrestore 触发\n\n图层纹理 + Brush 属性\n\n离屏缓冲\n\nGPU Blend 单元\n\n合成参数记录：\n\n保存 brush 的属性（Alpha、BlendMode、Filter）\n\nrestore() 时应用这些属性进行图层合成\n\n栈管理：\n\n返回当前栈深度（saveCount）\n\n必须调用 OH_Drawing_CanvasRestore() 平衡\n\n6.3 典型调用流程\n\n// === 创建图层 === OH_Drawing_Rect layerBounds = {0, 0, 200, 200}; OH_Drawing_Brush* layerBrush = OH_Drawing_BrushCreate(); OH_Drawing_BrushSetAlpha(layerBrush, 128); // 50% 透明 OH_Drawing_BrushSetBlendMode(layerBrush, BLEND_MODE_SRC_OVER); int saveCount = OH_Drawing_CanvasSaveLayer(canvas, &layerBounds, layerBrush); // === 在图层上绘制 === OH_Drawing_CanvasDrawRect(canvas, &rect1); OH_Drawing_CanvasDrawCircle(canvas, x, y, radius); // === 恢复并合成图层 === OH_Drawing_CanvasRestore(canvas); // 应用 layerBrush 的属性\n\n7. 数据流与状态管理\n\n7.1 状态栈结构\n\n// OHRender/include/core/SkCanvas.h struct CanvasState { bool fIsLayer; // 是否为 Layer 状态 bool fSaveLayerFlag; // saveLayer 标记 bool fNotInv; // 变换矩阵是否可逆 std::optional<SkRect> fClip; // 裁剪矩形 SkMatrix fTransform; // 变换矩阵 (CTM) SkMatrix fInvTransform; // 逆变换矩阵 SkClipShape fClipShape; // 裁剪形状（Rect/RRect/Path） SkClipShape fPendingDifferenceShape; // 待应用的差集裁剪 std::optional<SkPaint> fPaint; // 合成时使用的 Paint }; class SkCanvas { std::vector<CanvasState> fStateStack; // 状态栈 int fSaveCount; // 保存计数 // ... };\n\n7.2 状态流转\n\n7.3 关键数据传递\n\n阶段\n\n数据\n\n来源\n\n目标\n\nKotlin → Skiko\n\nRect , Paint\n\nCompose 对象\n\nSkiko 包装对象\n\nSkiko → JNI\n\n指针地址 ( Long )\n\nKotlin/Native\n\nC++ 指针\n\nOHRender → HarmonyOS\n\nOH_Drawing_Rect* , OH_Drawing_Brush*\n\nSkPaint 映射\n\n系统 API\n\nHarmonyOS → GPU\n\n离屏缓冲区句柄\n\n系统分配\n\nGPU FBO\n\nrestore 触发\n\n图层纹理 + Brush 属性\n\n离屏缓冲\n\nGPU Blend 单元\n\n7.4 完整跨层时序图\n\n以下时序图展示了从应用层调用 saveLayer 到 restore 完成图层合成的完整流程，涵盖所有架构层次：\n\n时序图关键点说明：\n\n阶段划分：\n\n蓝色区域：saveLayer 创建图层（~10-20 步骤）\n\n黄色区域：绘制指令执行（可多次调用）\n\n红色区域：restore 合成图层（~15 步骤）\n\n跨层调用链：\n\nCompose App → Kotlin → Skiko → JNI → C++ → HarmonyOS → GPU\n\n每一层都有明确的职责和边界\n\n关键节点：\n\n状态栈操作：push 在 saveLayer，pop 在 restore\n\nPaint 映射：发生在 updateOHPainter，一次性同步所有属性\n\nGPU 切换：saveLayer 时创建 FBO，restore 时销毁\n\n异步特性：\n\n绘制指令通常是异步的（GPU 命令队列）\n\n但 saveLayer/restore 会触发同步点（Flush）\n\n性能热点：\n\n离屏缓冲分配：O(width × height) 内存开销\n\nGPU Blend：O(pixel_count) 计算开销\n\n状态同步：多次系统 API 调用\n\n8. 性能考量与最佳实践\n\n8.1 性能成本分析\n\n操作\n\n成本\n\n原因\n\n创建图层\n\n高\n\n内存分配（width × height × 4 字节）+ GPU FBO 创建\n\n渲染切换\n\n高\n\nGPU 命令缓冲区 flush，丧失批处理优化\n\n图层合成\n\n中\n\n纹理上传 + Blend 操作\n\n状态管理\n\n低\n\n内存栈操作（几十字节）\n\n典型场景成本（1920×1080 全屏）：\n\n离屏缓冲：1920 × 1080 × 4 = 8.3 MB\n\nGPU Flush：~1-2ms（取决于命令队列深度）\n\nBlend 操作：~0.5ms（现代 GPU）\n\n8.2 优化策略\n\n✅ 正确用法\n\n限定 bounds\n\n// ✅ 只对需要的区域创建图层val bounds = Rect(100f, 100f, 300f, 300f) canvas.saveLayer(bounds, paint)\n\n避免嵌套\n\n// ❌ 多层嵌套成本指数增长 canvas.saveLayer(bounds1, paint1) canvas.saveLayer(bounds2, paint2) canvas.drawRect(...) canvas.restore() canvas.restore()\n\n合理使用 BlendMode\n\n// ✅ 在图层级别应用混合模式 canvas.saveLayer(bounds, Paint().apply { blendMode = BlendMode.Multiply })\n\n❌ 常见误用\n\n仅为保存状态而使用\n\n// ❌ 不需要图层效果时，用 save() 即可 canvas.saveLayer(bounds, Paint()) // 浪费 canvas.drawRect(...) canvas.restore() // ✅ 改用 save() canvas.save() canvas.drawRect(...) canvas.restore()\n\n全屏无界 Layer\n\n// ❌ 未指定 bounds，使用整个 Canvas canvas.saveLayer(null, paint) // 可能创建巨大缓冲区\n\n8.3 Raster Cache 机制\n\nOHRender 提供了渲染节点缓存机制（OHRenderNode::gEnableRasterCache）：\n\n// SkCanvas.cpp (internalSaveLayer) if (OHRenderNode::gEnableRasterCache && !fForbidRasterCache && !fCullRect->isEmpty()) { float costPerPixel = 1 + 1; // 读 + 写 if (state.fPaint) { costPerPixel = state.fPaint->computePerPixelCost(fCullRect.value()); } float thisCost = fCullRect->width() * fCullRect->height() * (costPerPixel + 1); fDrawCost += thisCost; }\n\n决策依据：\n\n成本超过阈值 → 缓存渲染结果\n\n下次相同 Hash → 直接复用缓存\n\n9. 调试与追踪\n\n9.1 日志开关\n\nKotlin 侧\n\nKotlin\n\ncompose/ui/ui-graphics/.../SkiaBackedCanvas.skiko.kt\n\nsaveLayer(bounds, paint)\n\nrestore()\n\nJNI\n\nskiko/src/nativeJsMain/cpp/Canvas.cc\n\norg_jetbrains_skia_Canvas__1nSaveLayerRect\n\norg_jetbrains_skia_Canvas__1nRestore\n\nC++\n\nOHRender/src/core/SkCanvas.cpp\n\ninternalSaveLayer(rec, strategy)\n\ninternalRestore()\n\nPaint\n\nOHRender/src/core/SkPaint.cpp\n\nupdateOHPainter()\n\n-\n\n系统\n\nHarmonyOS SDK\n\nOH_Drawing_CanvasSaveLayer\n\n`OH_Drawing_CanvasRestore\n\nC++侧\n\n// OHRender/src/core/SkCanvas.cpp void SkCanvas::internalSaveLayer(...) { TRACE_EVENT0(\"skia\", TRACE_FUNC); // Chrome Tracing 格式 // ... }\n\n9.2 追踪工具\n\nHarmonyOS Profiler\n\n路径：DevEco Studio → Profiler → Graphics\n\n观察项：FBO 创建次数、内存占用、Blend 操作耗时\n\nSkiko 追踪\n\n# 设置环境变量启用详细日志 export SKIKO_LOG_LEVEL=TRACE\n\nHiTrace\n\n// 生成 trace 文件（需启用 TRACE_EVENT 宏） TRACE_EVENT_BEGIN0(\"rendering\", \"saveLayer\"); // ... 代码 ... TRACE_EVENT_END0(\"rendering\", \"saveLayer\");\n\n9.3 常见问题诊断\n\n症状\n\n可能原因\n\n排查方法\n\n卡顿\n\n频繁创建/销毁图层\n\n用 Profiler 检查 saveLayer 调用频率\n\n内存泄漏\n\nrestore() 未调用\n\n检查状态栈深度 getSaveCount()\n\n渲染错误\n\nPaint 属性未正确映射\n\n断点 updateOHPainter() ，检查 HarmonyOS API 调用\n\n透明叠加异常\n\n未使用 saveLayer\n\n在重叠区域验证是否统一应用透明度\n\n总结\n\n核心要点\n\n分层理解\n\n逻辑层：Compose Canvas 接口，状态栈管理\n\n执行层：OHRender 引擎，Paint 映射、Hash 计算\n\n物理层：HarmonyOS Native API，离屏缓冲、GPU 合成\n\n数据流转\n\nKotlin Rect/Paint → Skiko 封装 → JNI 指针 → C++ SkCanvas → OH_Drawing API\n\n状态同步\n\nCTM/Clip 压入 fStateStack\n\nPaint 属性映射到 OH_Drawing_Brush/Pen\n\n系统级栈由 OH_Drawing_Canvas 管理\n\n性能优化\n\n限定 bounds 减少内存\n\n避免嵌套 saveLayer\n\n利用 Raster Cache 缓存重复渲染\n\n关键文件索引\n\n层次\n\n文件路径\n\n核心函数\n\nKotlin\n\ncompose/ui/ui-graphics/.../SkiaBackedCanvas.skiko.kt\n\nsaveLayer(bounds, paint)\n\nJNI\n\nskiko/src/nativeJsMain/cpp/Canvas.cc\n\norg_jetbrains_skia_Canvas__1nSaveLayerRect\n\nC++\n\nOHRender/src/core/SkCanvas.cpp\n\ninternalSaveLayer(rec, strategy)\n\nPaint\n\nOHRender/src/core/SkPaint.cpp\n\nupdateOHPainter()\n\n系统\n\nHarmonyOS SDK\n\nOH_Drawing_CanvasSaveLayer\n\n文档更新记录\n\n日期\n\n版本\n\n变更\n\n2025-12-12\n\n1.0\n\n初始版本，完整链路分析\n\n2025-12-15\n\n1.1\n\n补充 restore 实现方案，增加图层生命周期说明\n\n相关文档\n\nOpenHarmony Drawing API 官方文档\n\nSkia Canvas 参考\n\nCompose Graphics 设计文档",
          "content_html": "<h1><strong>saveLayer 实现方案解析</strong></h1>\n<p><strong>文档目标</strong>：从渲染管线原理出发，由浅入深地剖析 <code>saveLayer</code> 在 OHRender 渲染路线中的完整实现链路</p>\n<p><strong>涵盖层次</strong>：Kotlin (Compose) → Skiko (JNI/KNI) → OHRender (C++) → HarmonyOS Native (OH_Drawing)</p>\n<p><strong>生成日期</strong>：2025年12月12日</p>\n<h2><strong>1. 渲染管线原理：saveLayer 的作用</strong></h2>\n<h3><strong>1.1 什么是 saveLayer 和 restore？</strong></h3>\n<p>在 2D 图形渲染中，<code>saveLayer</code> 和 <code>restore</code> 是一对配合使用的 API，共同实现<strong>离屏渲染</strong>（Offscreen Rendering）机制。</p>\n<h4><strong>saveLayer 的作用：</strong></h4>\n<ol>\n<li><strong>创建临时图层</strong>：在当前 Canvas 之外开辟一个新的绘图表面（Layer）</li>\n<li><strong>重定向绘制指令</strong>：后续的 <code>drawRect</code>、<code>drawPath</code> 等操作都绘制到这个临时图层</li>\n<li><strong>保存状态</strong>：将当前的变换矩阵（CTM）、裁剪区域（Clip）、Paint 属性压入状态栈</li>\n</ol>\n<h4><strong>restore 的作用：</strong></h4>\n<ol>\n<li><strong>图层合成</strong>：将离屏图层作为一个整体，应用 <code>saveLayer</code> 时指定的 <code>Paint</code> 特效（透明度、混合模式、滤镜）后，合成回主 Canvas</li>\n<li><strong>状态恢复</strong>：从状态栈中弹出之前保存的 CTM、Clip 等状态，恢复到 <code>saveLayer</code> 调用前的绘制环境</li>\n<li><strong>资源释放</strong>：销毁临时图层，释放离屏缓冲区内存</li>\n</ol>\n<p><strong>核心配合关系</strong>：</p>\n<ul>\n<li><code>saveLayer</code> 相当于\"<strong>开启录制</strong>\"，创建新舞台</li>\n<li>中间的绘制指令在\"<strong>离屏舞台</strong>\"上表演</li>\n<li><code>restore</code> 相当于\"<strong>停止录制并播放</strong>\"，将录制内容合成到主舞台</li>\n</ul>\n<h3><strong>1.2 为什么需要 saveLayer？</strong></h3>\n<p><strong>问题场景</strong>：假设要绘制两个重叠的半透明矩形</p>\n<pre><code>// ❌ 不使用 saveLayer（错误效果）\ncanvas.drawRect(rect1, Paint().apply { alpha = 128 })\ncanvas.drawRect(rect2, Paint().apply { alpha = 128 })\n// 结果：重叠区域会比单独区域更暗（alpha 叠加）</code></pre>\n<pre><code>// ✅ 使用 saveLayer（正确效果）\ncanvas.saveLayer(bounds, Paint().apply { alpha = 128 })\ncanvas.drawRect(rect1, Paint().apply { color = Color.Red })\ncanvas.drawRect(rect2, Paint().apply { color = Color.Blue })\ncanvas.restore()\n// 结果：两个矩形先在图层上以不透明方式绘制，然后整个图层以 50% 透明度合成</code></pre>\n<h3><strong>1.3 渲染管线视角的三层理解</strong></h3>\n<div class=\"doc-table-wrap\"><table class=\"doc-table\"><thead><tr><th>层次</th><th>概念</th><th>物理实现</th></tr></thead><tbody><tr><td>逻辑层 (Compose)</td><td>保存 CTM/Clip 状态，开启&quot;离屏录制&quot;</td><td>状态栈压入，标记 isLayer=true</td></tr><tr><td>执行层 (渲染引擎)</td><td>切换 Render Target，临时缓冲区接收绘制</td><td>GPU 命令缓冲区切换，FBO (FrameBuffer Object) 分配</td></tr><tr><td>物理层 (HarmonyOS)</td><td>系统级离屏 Canvas 创建</td><td>OH_Drawing_CanvasSaveLayer 调用，内存缓冲分配</td></tr></tbody></table></div>\n<p><strong>关键原理</strong>：</p>\n<ul>\n<li><strong>抗锯齿裁剪</strong>：复杂裁剪（圆角、Path）的边缘需要平滑处理，<code>saveLayer</code> 确保先在图层内绘制完整内容，再统一应用抗锯齿裁剪</li>\n<li><strong>群组透明</strong>：多个图形作为整体应用透明度，避免重叠区域透明度累加</li>\n<li><strong>滤镜效果</strong>：<code>ColorFilter</code>、<code>ImageFilter</code> 等需要在独立图层上生效</li>\n</ul>\n<h2><strong>2. 实现链路总览</strong></h2>\n<figure class=\"doc-figure\"><img src=\"../knowledge-map-assets/savelayer-b18a6be3-d4d267ce33.png\" alt=\"saveLayer 实现方案解析 图示\" /></figure>\n<p><strong>完整路径</strong>：</p>\n<ol>\n<li><strong>Kotlin</strong> → <code>androidx.compose.ui.graphics.Canvas.saveLayer</code></li>\n<li><strong>Skiko</strong> → <code>org.jetbrains.skia.Canvas.saveLayer</code> (Kotlin/Native)</li>\n<li><strong>JNI</strong> → <code>Canvas.cc::org_jetbrains_skia_Canvas__1nSaveLayerRect</code></li>\n<li><strong>OHRender</strong> → <code>SkCanvas.cpp::internalSaveLayer</code></li>\n<li><strong>HarmonyOS</strong> → <code>OH_Drawing_CanvasSaveLayer</code> (系统 Native API)</li>\n</ol>\n<hr />\n<h2><strong>3. 第一层：Kotlin/Compose 侧</strong></h2>\n<h3><strong>3.1 接口定义</strong></h3>\n<p><strong>文件位置</strong>：</p>\n<p><code>compose/ui/ui-graphics/src/commonMain/kotlin/androidx/compose/ui/graphics/Canvas.kt</code></p>\n<pre><code>interface Canvas {\n/**\n* Saves a copy of the current transform and clip on the save stack, and then\n* creates a new group which subsequent calls will become a part of. When the\n* save stack is later popped, the group will be flattened into a layer and\n* have the given `paint`'s [Paint.colorFilter] and [Paint.blendMode]\n* applied.\n*/\nfun saveLayer(bounds: Rect, paint: Paint)\n}</code></pre>\n<p><strong>关键点</strong>：</p>\n<ul>\n<li><code>bounds</code>：图层的边界矩形，限定离屏渲染区域（可优化内存占用）</li>\n<li><code>paint</code>：合成时应用的画笔属性（透明度、混合模式、滤镜等）</li>\n</ul>\n<h3><strong>3.2 实现类</strong></h3>\n<p><strong>文件位置</strong>：</p>\n<p><code>compose/ui/ui-graphics/src/skikoMain/kotlin/androidx/compose/ui/graphics/SkiaBackedCanvas.skiko.kt</code></p>\n<h4><strong>saveLayer 实现</strong></h4>\n<pre><code>internal class SkiaBackedCanvas(val skia: org.jetbrains.skia.Canvas) : Canvas {\noverride fun saveLayer(bounds: Rect, paint: Paint) {\nif (EnableSkiaBackedCanvasLog) {\nkLog(\"[SkiaBackedCanvas] saveLayer $bounds\")\n}\nskia.saveLayer(\nbounds.left,\nbounds.top,\nbounds.right,\nbounds.bottom,\npaint.skia // 转换为 Skiko 的 Paint 对象\n)\n}\n}</code></pre>\n<h4><strong>restore 实现</strong></h4>\n<pre><code>internal class SkiaBackedCanvas(val skia: org.jetbrains.skia.Canvas) : Canvas {\noverride fun restore() {\nif (EnableSkiaBackedCanvasLog) {\nkLog(\"[SkiaBackedCanvas] restore\")\n}\nskia.restore() // 调用 Skiko 的 restore，触发图层合成\n}\n}</code></pre>\n<p><strong>职责</strong>：</p>\n<ol>\n<li><strong>saveLayer</strong>：将 Compose 的 <code>Rect</code>/<code>Paint</code> 类型转换为 Skiko 的原生类型</li>\n<li><strong>restore</strong>：无需参数，直接调用 Skiko 的 <code>restore()</code> 方法</li>\n<li>可选地输出调试日志（通过 <code>EnableSkiaBackedCanvasLog</code> 开关）</li>\n</ol>\n<hr />\n<h2><strong>4. 第二层：Skiko JNI 桥接</strong></h2>\n<h3><strong>4.1 JNI 入口</strong></h3>\n<p><strong>文件位置</strong>：<code>skiko/src/nativeJsMain/cpp/Canvas.cc</code></p>\n<h4><strong>saveLayer JNI 绑定</strong></h4>\n<pre><code>SKIKO_EXPORT KInt org_jetbrains_skia_Canvas__1nSaveLayerRect(\nKNativePointer ptr, // Canvas 指针\nKFloat left, KFloat top, // 矩形边界\nKFloat right, KFloat bottom,\nKNativePointer paintPtr // Paint 指针\n) {\n// 1. 指针类型恢复\nSkCanvas* canvas = reinterpret_cast&lt;SkCanvas*&gt;(ptr);\nSkPaint* paint = reinterpret_cast&lt;SkPaint*&gt;(paintPtr);\n// 2. 构造矩形\nSkRect bounds {left, top, right, bottom};\n// 3. 调用 OHRender 的 C++ 实现\nreturn canvas-&gt;saveLayer(&amp;bounds, paint);\n}</code></pre>\n<h4><strong>restore JNI 绑定</strong></h4>\n<pre><code>SKIKO_EXPORT void org_jetbrains_skia_Canvas__1nRestore(KNativePointer ptr) {\n// 直接调用 SkCanvas 的 restore 方法\nreinterpret_cast&lt;SkCanvas*&gt;(ptr)-&gt;restore();\n}</code></pre>\n<p><strong>关键机制</strong>：</p>\n<ul>\n<li><strong>指针传递</strong>：Kotlin/Native 侧通过 <code>Long</code> 类型传递 C++ 对象的内存地址</li>\n</ul>\n<h4><strong>saveLayer 公共接口</strong></h4>\n<pre><code>int SkCanvas::saveLayer(const SkRect* bounds, const SkPaint* paint) {\nreturn this-&gt;saveLayer(SaveLayerRec(bounds, paint, 0));\n}\nint SkCanvas::saveLayer(const SaveLayerRec&amp; rec) {\nTRACE_EVENT0(\"skia\", TRACE_FUNC);\nSaveLayerStrategy strategy = this-&gt;getSaveLayerStrategy(rec);\nthis-&gt;willSaveLayer(rec);\nif (strategy == kFullLayer_SaveLayerStrategy) {\nthis-&gt;internalSaveLayer(rec, strategy);\n}\nreturn this-&gt;getSaveCount() - 1;\n}</code></pre>\n<h4><strong>restore 公共接口</strong></h4>\n<pre><code>void SkCanvas::restore() {\n// 处理子 Canvas 的情况（用于某些特殊渲染路径）\nif (fSubCanvas &amp;&amp; fSubCanvas-&gt;getSaveCount() == 1) {\nfinishSubCanvas();\nfNeedCreateSubCanvas = true;\n}\nif (fSubCanvas) {\nSkASSERT(fSubCanvas-&gt;getSaveCount() &gt; 1);\nfSubCanvas-&gt;restore();\nreturn;\n}\n// 检查栈深度，防止 underflow\nif (fSaveCount &gt; fInitSaveCount) {\nfSaveCount -= 1;\nthis-&gt;internalRestore(); // 调用内部实现\n}\nRec(bounds, paint, 0));\n}\nint SkCanvas::saveLayer(const SaveLayerRec&amp; rec) {\nTRACE_EVENT0(\"skia\", TRACE_FUNC);\nSaveLayerStrategy strategy = this-&gt;getSaveLayerStrategy(rec);\nthis-&gt;willSaveLayer(rec);\nif (strategy == kFullLayer_SaveLayerStrategy) {\nthis-&gt;internalSaveLayer(rec, strategy);\n}\nreturn this-&gt;getSaveCount() - 1;\n}</code></pre>\n<h3><strong>5.2 核心实现：internalSaveLayer</strong></h3>\n<p><strong>文件位置</strong>：<code>OHRender/src/core/SkCanvas.cpp</code> (行 1052-1147)</p>\n<pre><code>void SkCanvas::internalSaveLayer(const SaveLayerRec&amp; rec, SaveLayerStrategy strategy) {\nTRACE_EVENT0(\"skia\", TRACE_FUNC);\n// === 1. 状态压栈 ===\nfSaveCount += 1;\nCanvasState state;\nstate.fIsLayer = true;\nstate.fSaveLayerFlag = true;\nstate.fNotInv = fNotInv;\nstate.fClip = fCullRect; // 当前裁剪区域\nstate.fTransform = fCTM; // 当前变换矩阵\nstate.fInvTransform = fInvCTM; // 逆变换矩阵\nstate.fClipShape = fClipShape; // 裁剪形状\nstate.fPendingDifferenceShape = fPendingDifferenceShape;\nif (rec.fPaint) {\nstate.fPaint = *rec.fPaint;\nstate.fPaint-&gt;setMaskFilter(nullptr); // MaskFilter 在合成时应用\nstate.fPaint-&gt;setAntiAlias(true);\n}\nfStateStack.push_back(state); // 压入状态栈\n// === 2. 裁剪区域更新 ===\nbool needHashClip = false;\nbool needHashBounds = false;\nif (rec.fBounds) {\nif (fCullRect.has_value()) {\nauto realBounds = fCTM.mapRect(*rec.fBounds); // 变换到设备坐标\nif (realBounds.contains(fCullRect.value())) {\nneedHashClip = true;\n}\nif (!fCullRect-&gt;intersect(realBounds)) {\nfCullRect = SkRect::MakeEmpty();\n} else {\nif (!needHashClip) {\nneedHashClip = true;\nneedHashBounds = true;\n}\n}\n} else {\nfCullRect = fCTM.mapRect(*rec.fBounds);\nneedHashBounds = true;\n}\n} else {\nneedHashClip = true;\n}\n// === 3. Hash 计算（用于渲染节点去重/缓存）===\nif (fEnableHash) {\nfHasher.push(HASH_UNIQUE_ID);\nfHasher.push(fCTM.hash());\nif (needHashClip) {\nfHasher.push(GetClipShapeHash(fClipShape));\nfHasher.push(GetClipShapeHash(fPendingDifferenceShape));\n}\nif (needHashBounds) {\nfHasher.pushArray(rec.fBounds, 1);\n}\nif (state.fPaint) {\nfHasher.push(state.fPaint-&gt;hash());\n}\n}\n// === 4. 绘制边界更新 ===\nif (PaintMayAffectTransparentBlack(rec.fPaint)) {\nif (fCullRect.has_value() &amp;&amp; fDrawBounds.has_value()) {\nfDrawBounds-&gt;join(fCullRect.value());\n} else {\nfDrawBounds = std::nullopt; // 图层可能影响透明区域\n}\n}\n// === 5. 渲染成本计算（Raster Cache 决策）===\nif (OHRenderNode::gEnableRasterCache &amp;&amp; !fForbidRasterCache &amp;&amp; !fCullRect-&gt;isEmpty()) {\nfloat costPerPixel = 1 + 1; // 默认：读取 + 写入\nif (state.fPaint) {\ncostPerPixel = state.fPaint-&gt;computePerPixelCost(fCullRect.value());\n}\nfloat thisCost = fCullRect-&gt;width() * fCullRect-&gt;height() * (costPerPixel + 1);\nfDrawCost += thisCost;\nif (thisCost &gt; 10) {\nfDrawCost += doRealClipCost(); // 复杂裁剪的额外成本\n}\n}\n// === 6. Paint 属性同步到 HarmonyOS Painter ===\nif (state.fPaint) {\nstate.fPaint-&gt;updateOHPainter();\n}\n// === 7. 调用 HarmonyOS 系统 API ===\nOH_Drawing_CanvasSaveLayer(\nfDrawingCanvas,\n(const OH_Drawing_Rect *)rec.fBounds,\n(state.fPaint ? (OH_Drawing_Brush *)(*state.fPaint) : nullptr)\n);\n}</code></pre>\n<h3><strong>5.3 Paint 属性映射</strong></h3>\n<p><strong>文件位置</strong>：<code>OHRender/src/core/SkPaint.cpp</code></p>\n<pre><code>void SkPaint::updateOHPainter() const {\nhasUpdate = true;\ngOHPainter.updateOHPainter(*this);\n}\nvoid OHPainter::updateOHPainter(const SkPaint &amp;painter) {\n// === PathEffect ===\n{\nOH_Drawing_PathEffect *newEffect = nullptr;\nif (painter.fPathEffect) {\nnewEffect = *as_PEB(painter.fPathEffect);\n}\nif (newEffect != fPathEffect) {\nOH_Drawing_PenSetPathEffect(fOHPen, newEffect);\nfPathEffect = newEffect;\n}\n}\n// === ShaderEffect ===\n{\nOH_Drawing_ShaderEffect *newEffect = nullptr;\nif (painter.fShader) {\nnewEffect = *as_SB(painter.fShader);\n}\nif (newEffect != fShaderEffect) {\nOH_Drawing_PenSetShaderEffect(fOHPen, newEffect);\nOH_Drawing_BrushSetShaderEffect(fOHBrush, newEffect);\nfShaderEffect = newEffect;\n}\n}\n// === Filter (Mask/Color/Image) ===\nbool filterHasChange = false;\n{\nOH_Drawing_MaskFilter *newFilter = nullptr;\nif (painter.fMaskFilter) {\nnewFilter = *as_MFB(painter.fMaskFilter);\n}\nif (newFilter != fMashFilter) {\nOH_Drawing_FilterSetMaskFilter(fOHFilter, newFilter);\nfMashFilter = newFilter;\nfilterHasChange = true;\n}\n}\n// ... ColorFilter、ImageFilter 类似处理 ...\nif (filterHasChange) {\nOH_Drawing_PenSetFilter(fOHPen, fOHFilter);\nOH_Drawing_BrushSetFilter(fOHBrush, fOHFilter);\n}\n// === BlendMode ===\nauto blendMode = painter.asBlendMode();\nif (blendMode) {\nSkBlendMode b = blendMode.value();\nOH_Drawing_PenSetBlendMode(fOHPen, (OH_Drawing_BlendMode)b);\nOH_Drawing_BrushSetBlendMode(fOHBrush, (OH_Drawing_BlendMode)b);\n}\n// === 基础属性 ===\nOH_Drawing_PenSetColor(fOHPen, painter.getColor());\nOH_Drawing_BrushSetColor(fOHBrush, painter.getColor());\n}</code></pre>\n<h3><strong>5.4 核心实现：internalRestore</strong></h3>\n<p><strong>文件位置</strong>：<code>OHRender/src/core/SkCanvas.cpp</code> (行 1199-1215)</p>\n<pre><code>void SkCanvas::internalRestore() {\n// === 1. 获取栈顶状态 ===\nauto&amp; topLayer = fStateStack.back();\n// === 2. 裁剪状态检查（用于 Raster Cache 优化）===\nif (OHRenderNode::gEnableRasterCache &amp;&amp;\n!fForbidRasterCache &amp;&amp;\nfNowDrawClipShape != topLayer.fClipShape) {\nfNeedDoClip = true; // 标记需要重新应用裁剪\n}\n// === 3. 恢复画布状态 ===\nfNotInv = topLayer.fNotInv; // 恢复矩阵可逆性标志\nfCTM = topLayer.fTransform; // 恢复变换矩阵\nfInvCTM = topLayer.fInvTransform; // 恢复逆变换矩阵\nfCullRect = topLayer.fClip; // 恢复裁剪矩形\nfClipShape = topLayer.fClipShape; // 恢复裁剪形状\nfPendingDifferenceShape = topLayer.fPendingDifferenceShape;// 恢复待处理的差集裁剪\n// === 4. Hash 更新（用于渲染节点缓存）===\nif (topLayer.fSaveLayerFlag &amp;&amp; fEnableHash) {\nfHasher.push(HASH_UNIQUE_ID); // 记录 restore 操作到 Hash\n}\n// === 5. 弹出状态栈 ===\nfStateStack.pop_back();\n// === 6. 调用 HarmonyOS 系统 API ===\n// 如果是 saveLayer，会触发图层合成；如果是普通 save，仅恢复状态\nOH_Drawing_CanvasRestore(fDrawingCanvas);\n}</code></pre>\n<p><strong>关键逻辑</strong>：</p>\n<ol>\n<li><strong>状态恢复顺序</strong>：必须先恢复内存中的状态（CTM、Clip），再调用系统 API</li>\n<li><strong>图层合成</strong>：<code>OH_Drawing_CanvasRestore</code> 内部会判断栈顶是否为 Layer，如果是则执行合成</li>\n<li><strong>裁剪优化</strong>：检测裁剪形状变化，用于 Raster Cache 的失效判断</li>\n<li><strong>栈平衡</strong>：每次 <code>restore</code> 必须对应一次 <code>save</code> 或 <code>saveLayer</code></li>\n</ol>\n<p>OH_Drawing_PenSetWidth(fOHPen, painter.getStrokeWidth());</p>\n<p>OH_Drawing_PenSetMiterLimit(fOHPen, painter.getStrokeMiter());</p>\n<p>OH_Drawing_PenSetAntiAlias(fOHPen, painter.isAntiAlias());</p>\n<p>OH_Drawing_CanvasRestore 系统 API</p>\n<p><strong>API 签名</strong>（根据 OpenHarmony 文档）：</p>\n<pre><code>/**\n* @brief Restores the canvas state from the save stack.\n* If the saved state was created by OH_Drawing_CanvasSaveLayer,\n* this will also composite the layer back to the parent canvas.\n*\n* @param canvas Pointer to an OH_Drawing_Canvas object.\n*\n* @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n*/\nvoid OH_Drawing_CanvasRestore(OH_Drawing_Canvas* canvas);</code></pre>\n<p><strong>系统行为</strong>：</p>\n<ol>\n<li><strong>状态恢复</strong>：</li>\n</ol>\n<ul>\n<li>从内部栈中弹出保存的状态（CTM、Clip 等）</li>\n<li>恢复到 <code>save()</code> 或 <code>saveLayer()</code> 调用前的绘制环境</li>\n</ul>\n<ol>\n<li><strong>图层合成</strong>（仅当栈顶为 Layer 时）：</li>\n</ol>\n<ul>\n<li>将离屏缓冲区作为纹理，应用 <code>saveLayer</code> 时指定的 <code>brush</code> 属性</li>\n<li>执行 GPU Blend 操作（Alpha、BlendMode、Filter）</li>\n<li>将合成结果绘制到父 Canvas</li>\n</ul>\n<ol>\n<li><strong>资源清理</strong>：</li>\n</ol>\n<ul>\n<li>释放离屏缓冲区内存</li>\n<li>销毁临时的渲染目标（FBO）</li>\n</ul>\n<h3><strong>6.4 典型调用流程</strong></h3>\n<pre><code>// === 创建图层 ===\nOH_Drawing_Rect layerBounds = {0, 0, 200, 200};\nOH_Drawing_Brush* layerBrush = OH_Drawing_BrushCreate();\nOH_Drawing_BrushSetAlpha(layerBrush, 128); // 50% 透明\nOH_Drawing_BrushSetBlendMode(layerBrush, BLEND_MODE_SRC_OVER);\nint saveCount = OH_Drawing_CanvasSaveLayer(canvas, &amp;layerBounds, layerBrush);\n// === 在图层上绘制 ===\nOH_Drawing_CanvasDrawRect(canvas, &amp;rect1);\nOH_Drawing_CanvasDrawCircle(canvas, x, y, radius);\n// === 恢复并合成图层 ===\nOH_Drawing_CanvasRestore(canvas);\n// ↑ 内部执行：\n// 1. 弹出状态栈\n// 2. 应用 layerBrush 的 Alpha/BlendMode 进行图层合成\n// 3. 释放离屏缓冲区</code></pre>\n<p><strong>关键时序</strong>：</p>\n<pre><code>OH_Drawing_CanvasSaveLayer → 创建离屏缓冲 + 切换渲染目标\n↓ 绘制指令写入离屏缓冲\n↓\nOH_Drawing_CanvasRestore → 合成图层 + 恢复状态 + 释放资源</code></pre>\n<ul>\n<li><strong>增量更新</strong>：只有发生变化的属性才调用 HarmonyOS API（避免重复设置）</li>\n<li><strong>全局 Painter</strong>：<code>gOHPainter</code> 是全局单例，管理 <code>OH_Drawing_Pen</code> 和 <code>OH_Drawing_Brush</code></li>\n<li><strong>类型映射</strong>：Skia 的 <code>SkBlendMode</code>、<code>SkStrokeCap</code> 等枚举直接映射到 HarmonyOS 的对应枚举</li>\n</ul>\n<hr />\n<h2><strong>6. 第四层：HarmonyOS Native API</strong></h2>\n<h3><strong>6.1 系统调用</strong></h3>\n<p><strong>API 签名</strong>（根据 OpenHarmony 文档）：</p>\n<pre><code>/**\n* @brief Saves the current canvas state (including clip and transformation) onto the save stack\n* and creates a new layer with specified bounds and brush properties.\n*\n* @param canvas Pointer to an OH_Drawing_Canvas object.\n* @param bounds Optional. Pointer to an OH_Drawing_Rect that defines the layer bounds.\n* If nullptr, the layer uses the entire canvas.\n* @param brush Optional. Pointer to an OH_Drawing_Brush for layer composition.\n* Controls alpha, blend mode, color filter, etc. when the layer is restored. *\n* @return The save count (depth of the save stack).\n*\n* @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n*/\nint OH_Drawing_CanvasSaveLayer(\nOH_Drawing_Canvas* canvas,\nconst OH_Drawing_Rect* bounds,\nconst OH_Drawing_Brush* brush\n);</code></pre>\n<h3><strong>6.2 系统行为</strong></h3>\n<p>图层生命周期</p>\n<figure class=\"doc-figure\"><img src=\"../knowledge-map-assets/savelayer-b18a6be3-9cde1e68b3.png\" alt=\"saveLayer 实现方案解析 图示\" /></figure>\n<h3><strong>7.4 关键数据传递</strong></h3>\n<div class=\"doc-table-wrap\"><table class=\"doc-table\"><thead><tr><th>阶段</th><th>数据</th><th>来源</th><th>目标</th></tr></thead><tbody><tr><td>Kotlin → Skiko</td><td>Rect , Paint</td><td>Compose 对象</td><td>Skiko 包装对象</td></tr><tr><td>Skiko → JNI</td><td>指针地址 ( Long )</td><td>Kotlin/Native</td><td>C++ 指针</td></tr><tr><td>OHRender → HarmonyOS</td><td>OH_Drawing_Rect* , OH_Drawing_Brush*</td><td>SkPaint 映射</td><td>系统 API</td></tr><tr><td>HarmonyOS → GPU</td><td>离屏缓冲区句柄</td><td>系统分配</td><td>GPU FBO</td></tr><tr><td>restore 触发</td><td>图层纹理 + Brush 属性</td><td>离屏缓冲</td><td>GPU Blend 单元</td></tr></tbody></table></div>\n<ol>\n<li><strong>合成参数记录</strong>：</li>\n</ol>\n<ul>\n<li>保存 <code>brush</code> 的属性（Alpha、BlendMode、Filter）</li>\n<li><code>restore()</code> 时应用这些属性进行图层合成</li>\n</ul>\n<ol>\n<li><strong>栈管理</strong>：</li>\n</ol>\n<ul>\n<li>返回当前栈深度（<code>saveCount</code>）</li>\n<li>必须调用 <code>OH_Drawing_CanvasRestore()</code> 平衡</li>\n</ul>\n<h3><strong>6.3 典型调用流程</strong></h3>\n<pre><code>// === 创建图层 ===\nOH_Drawing_Rect layerBounds = {0, 0, 200, 200};\nOH_Drawing_Brush* layerBrush = OH_Drawing_BrushCreate();\nOH_Drawing_BrushSetAlpha(layerBrush, 128); // 50% 透明\nOH_Drawing_BrushSetBlendMode(layerBrush, BLEND_MODE_SRC_OVER);\nint saveCount = OH_Drawing_CanvasSaveLayer(canvas, &amp;layerBounds, layerBrush);\n// === 在图层上绘制 ===\nOH_Drawing_CanvasDrawRect(canvas, &amp;rect1);\nOH_Drawing_CanvasDrawCircle(canvas, x, y, radius);\n// === 恢复并合成图层 ===\nOH_Drawing_CanvasRestore(canvas); // 应用 layerBrush 的属性</code></pre>\n<hr />\n<h2><strong>7. 数据流与状态管理</strong></h2>\n<h3><strong>7.1 状态栈结构</strong></h3>\n<pre><code>// OHRender/include/core/SkCanvas.h\nstruct CanvasState {\nbool fIsLayer; // 是否为 Layer 状态\nbool fSaveLayerFlag; // saveLayer 标记\nbool fNotInv; // 变换矩阵是否可逆\nstd::optional&lt;SkRect&gt; fClip; // 裁剪矩形\nSkMatrix fTransform; // 变换矩阵 (CTM)\nSkMatrix fInvTransform; // 逆变换矩阵\nSkClipShape fClipShape; // 裁剪形状（Rect/RRect/Path）\nSkClipShape fPendingDifferenceShape; // 待应用的差集裁剪\nstd::optional&lt;SkPaint&gt; fPaint; // 合成时使用的 Paint\n};\nclass SkCanvas {\nstd::vector&lt;CanvasState&gt; fStateStack; // 状态栈\nint fSaveCount; // 保存计数\n// ...\n};</code></pre>\n<h3><strong>7.2 状态流转</strong></h3>\n<figure class=\"doc-figure\"><img src=\"../knowledge-map-assets/savelayer-b18a6be3-e3bae9c953.png\" alt=\"saveLayer 实现方案解析 图示\" /></figure>\n<h3><strong>7.3 关键数据传递</strong></h3>\n<div class=\"doc-table-wrap\"><table class=\"doc-table\"><thead><tr><th>阶段</th><th>数据</th><th>来源</th><th>目标</th></tr></thead><tbody><tr><td>Kotlin → Skiko</td><td>Rect , Paint</td><td>Compose 对象</td><td>Skiko 包装对象</td></tr><tr><td>Skiko → JNI</td><td>指针地址 ( Long )</td><td>Kotlin/Native</td><td>C++ 指针</td></tr><tr><td>OHRender → HarmonyOS</td><td>OH_Drawing_Rect* , OH_Drawing_Brush*</td><td>SkPaint 映射</td><td>系统 API</td></tr><tr><td>HarmonyOS → GPU</td><td>离屏缓冲区句柄</td><td>系统分配</td><td>GPU FBO</td></tr><tr><td>restore 触发</td><td>图层纹理 + Brush 属性</td><td>离屏缓冲</td><td>GPU Blend 单元</td></tr></tbody></table></div>\n<h3><strong>7.4 完整跨层时序图</strong></h3>\n<p>以下时序图展示了从应用层调用 <code>saveLayer</code> 到 <code>restore</code> 完成图层合成的完整流程，涵盖所有架构层次：</p>\n<figure class=\"doc-figure\"><img src=\"../knowledge-map-assets/savelayer-b18a6be3-04e8132251.png\" alt=\"saveLayer 实现方案解析 图示\" /></figure>\n<p><strong>时序图关键点说明</strong>：</p>\n<ol>\n<li><strong>阶段划分</strong>：</li>\n</ol>\n<ul>\n<li><strong>蓝色区域</strong>：saveLayer 创建图层（~10-20 步骤）</li>\n<li><strong>黄色区域</strong>：绘制指令执行（可多次调用）</li>\n<li><strong>红色区域</strong>：restore 合成图层（~15 步骤）</li>\n</ul>\n<ol>\n<li><strong>跨层调用链</strong>：</li>\n</ol>\n<pre><code>Compose App → Kotlin → Skiko → JNI → C++ → HarmonyOS → GPU</code></pre>\n<p>每一层都有明确的职责和边界</p>\n<ol>\n<li><strong>关键节点</strong>：</li>\n</ol>\n<ul>\n<li><strong>状态栈操作</strong>：<code>push</code> 在 saveLayer，<code>pop</code> 在 restore</li>\n<li><strong>Paint 映射</strong>：发生在 <code>updateOHPainter</code>，一次性同步所有属性</li>\n<li><strong>GPU 切换</strong>：saveLayer 时创建 FBO，restore 时销毁</li>\n</ul>\n<ol>\n<li><strong>异步特性</strong>：</li>\n</ol>\n<ul>\n<li>绘制指令通常是异步的（GPU 命令队列）</li>\n<li>但 saveLayer/restore 会触发同步点（Flush）</li>\n</ul>\n<ol>\n<li><strong>性能热点</strong>：</li>\n</ol>\n<ul>\n<li><strong>离屏缓冲分配</strong>：O(width × height) 内存开销</li>\n<li><strong>GPU Blend</strong>：O(pixel_count) 计算开销</li>\n<li><strong>状态同步</strong>：多次系统 API 调用</li>\n</ul>\n<hr />\n<h2><strong>8. 性能考量与最佳实践</strong></h2>\n<h3><strong>8.1 性能成本分析</strong></h3>\n<div class=\"doc-table-wrap\"><table class=\"doc-table\"><thead><tr><th>操作</th><th>成本</th><th>原因</th></tr></thead><tbody><tr><td>创建图层</td><td>高</td><td>内存分配（width × height × 4 字节）+ GPU FBO 创建</td></tr><tr><td>渲染切换</td><td>高</td><td>GPU 命令缓冲区 flush，丧失批处理优化</td></tr><tr><td>图层合成</td><td>中</td><td>纹理上传 + Blend 操作</td></tr><tr><td>状态管理</td><td>低</td><td>内存栈操作（几十字节）</td></tr></tbody></table></div>\n<p><strong>典型场景成本</strong>（1920×1080 全屏）：</p>\n<ul>\n<li>离屏缓冲：<code>1920 × 1080 × 4 = 8.3 MB</code></li>\n<li>GPU Flush：~1-2ms（取决于命令队列深度）</li>\n<li>Blend 操作：~0.5ms（现代 GPU）</li>\n</ul>\n<h3><strong>8.2 优化策略</strong></h3>\n<h4><strong>✅ 正确用法</strong></h4>\n<ol>\n<li><strong>限定 bounds</strong></li>\n</ol>\n<pre><code>// ✅ 只对需要的区域创建图层val bounds = Rect(100f, 100f, 300f, 300f)\ncanvas.saveLayer(bounds, paint)</code></pre>\n<ol>\n<li><strong>避免嵌套</strong></li>\n</ol>\n<pre><code>// ❌ 多层嵌套成本指数增长\ncanvas.saveLayer(bounds1, paint1)\ncanvas.saveLayer(bounds2, paint2)\ncanvas.drawRect(...)\ncanvas.restore()\ncanvas.restore()</code></pre>\n<ol>\n<li><strong>合理使用 BlendMode</strong></li>\n</ol>\n<pre><code>// ✅ 在图层级别应用混合模式\ncanvas.saveLayer(bounds, Paint().apply {\nblendMode = BlendMode.Multiply\n})</code></pre>\n<h4><strong>❌ 常见误用</strong></h4>\n<ol>\n<li><strong>仅为保存状态而使用</strong></li>\n</ol>\n<pre><code>// ❌ 不需要图层效果时，用 save() 即可\ncanvas.saveLayer(bounds, Paint()) // 浪费\ncanvas.drawRect(...)\ncanvas.restore()\n// ✅ 改用 save()\ncanvas.save()\ncanvas.drawRect(...)\ncanvas.restore()</code></pre>\n<ol>\n<li><strong>全屏无界 Layer</strong></li>\n</ol>\n<pre><code>// ❌ 未指定 bounds，使用整个 Canvas\ncanvas.saveLayer(null, paint) // 可能创建巨大缓冲区</code></pre>\n<h3><strong>8.3 Raster Cache 机制</strong></h3>\n<p>OHRender 提供了渲染节点缓存机制（<code>OHRenderNode::gEnableRasterCache</code>）：</p>\n<pre><code>// SkCanvas.cpp (internalSaveLayer)\nif (OHRenderNode::gEnableRasterCache &amp;&amp; !fForbidRasterCache &amp;&amp; !fCullRect-&gt;isEmpty()) {\nfloat costPerPixel = 1 + 1; // 读 + 写\nif (state.fPaint) {\ncostPerPixel = state.fPaint-&gt;computePerPixelCost(fCullRect.value());\n}\nfloat thisCost = fCullRect-&gt;width() * fCullRect-&gt;height() * (costPerPixel + 1);\nfDrawCost += thisCost;\n}</code></pre>\n<p><strong>决策依据</strong>：</p>\n<ul>\n<li>成本超过阈值 → 缓存渲染结果</li>\n<li>下次相同 Hash → 直接复用缓存</li>\n</ul>\n<hr />\n<h2><strong>9. 调试与追踪</strong></h2>\n<h3><strong>9.1 日志开关</strong></h3>\n<h4><strong>Kotlin 侧</strong></h4>\n<div class=\"doc-table-wrap\"><table class=\"doc-table\"><thead><tr><th>Kotlin</th><th>compose/ui/ui-graphics/.../SkiaBackedCanvas.skiko.kt</th><th>saveLayer(bounds, paint)</th><th>restore()</th></tr></thead><tbody><tr><td>JNI</td><td>skiko/src/nativeJsMain/cpp/Canvas.cc</td><td>org_jetbrains_skia_Canvas__1nSaveLayerRect</td><td>org_jetbrains_skia_Canvas__1nRestore</td></tr><tr><td>C++</td><td>OHRender/src/core/SkCanvas.cpp</td><td>internalSaveLayer(rec, strategy)</td><td>internalRestore()</td></tr><tr><td>Paint</td><td>OHRender/src/core/SkPaint.cpp</td><td>updateOHPainter()</td><td>-</td></tr><tr><td>系统</td><td>HarmonyOS SDK</td><td>OH_Drawing_CanvasSaveLayer</td><td>`OH_Drawing_CanvasRestore</td></tr></tbody></table></div>\n<h4><strong>C++侧</strong></h4>\n<pre><code>// OHRender/src/core/SkCanvas.cpp\nvoid SkCanvas::internalSaveLayer(...) { TRACE_EVENT0(\"skia\", TRACE_FUNC); // Chrome Tracing 格式\n// ...\n}</code></pre>\n<h3><strong>9.2 追踪工具</strong></h3>\n<ol>\n<li><strong>HarmonyOS Profiler</strong></li>\n</ol>\n<ul>\n<li>路径：DevEco Studio → Profiler → Graphics</li>\n<li>观察项：FBO 创建次数、内存占用、Blend 操作耗时</li>\n</ul>\n<ol>\n<li><strong>Skiko 追踪</strong></li>\n</ol>\n<pre><code># 设置环境变量启用详细日志\nexport SKIKO_LOG_LEVEL=TRACE</code></pre>\n<ol>\n<li><strong>HiTrace</strong></li>\n</ol>\n<pre><code>// 生成 trace 文件（需启用 TRACE_EVENT 宏）\nTRACE_EVENT_BEGIN0(\"rendering\", \"saveLayer\");\n// ... 代码 ...\nTRACE_EVENT_END0(\"rendering\", \"saveLayer\");</code></pre>\n<h3><strong>9.3 常见问题诊断</strong></h3>\n<div class=\"doc-table-wrap\"><table class=\"doc-table\"><thead><tr><th>症状</th><th>可能原因</th><th>排查方法</th></tr></thead><tbody><tr><td>卡顿</td><td>频繁创建/销毁图层</td><td>用 Profiler 检查 saveLayer 调用频率</td></tr><tr><td>内存泄漏</td><td>restore() 未调用</td><td>检查状态栈深度 getSaveCount()</td></tr><tr><td>渲染错误</td><td>Paint 属性未正确映射</td><td>断点 updateOHPainter() ，检查 HarmonyOS API 调用</td></tr><tr><td>透明叠加异常</td><td>未使用 saveLayer</td><td>在重叠区域验证是否统一应用透明度</td></tr></tbody></table></div>\n<hr />\n<h2><strong>总结</strong></h2>\n<h3><strong>核心要点</strong></h3>\n<ol>\n<li><strong>分层理解</strong></li>\n</ol>\n<ul>\n<li><strong>逻辑层</strong>：Compose Canvas 接口，状态栈管理</li>\n<li><strong>执行层</strong>：OHRender 引擎，Paint 映射、Hash 计算</li>\n<li><strong>物理层</strong>：HarmonyOS Native API，离屏缓冲、GPU 合成</li>\n</ul>\n<ol>\n<li><strong>数据流转</strong></li>\n</ol>\n<pre><code>Kotlin Rect/Paint → Skiko 封装 → JNI 指针 → C++ SkCanvas → OH_Drawing API</code></pre>\n<ol>\n<li><strong>状态同步</strong></li>\n</ol>\n<ul>\n<li>CTM/Clip 压入 <code>fStateStack</code></li>\n<li>Paint 属性映射到 <code>OH_Drawing_Brush/Pen</code></li>\n<li>系统级栈由 <code>OH_Drawing_Canvas</code> 管理</li>\n</ul>\n<ol>\n<li><strong>性能优化</strong></li>\n</ol>\n<ul>\n<li>限定 <code>bounds</code> 减少内存</li>\n<li>避免嵌套 <code>saveLayer</code></li>\n<li>利用 Raster Cache 缓存重复渲染</li>\n</ul>\n<h3><strong>关键文件索引</strong></h3>\n<div class=\"doc-table-wrap\"><table class=\"doc-table\"><thead><tr><th>层次</th><th>文件路径</th><th>核心函数</th></tr></thead><tbody><tr><td>Kotlin</td><td>compose/ui/ui-graphics/.../SkiaBackedCanvas.skiko.kt</td><td>saveLayer(bounds, paint)</td></tr><tr><td>JNI</td><td>skiko/src/nativeJsMain/cpp/Canvas.cc</td><td>org_jetbrains_skia_Canvas__1nSaveLayerRect</td></tr><tr><td>C++</td><td>OHRender/src/core/SkCanvas.cpp</td><td>internalSaveLayer(rec, strategy)</td></tr><tr><td>Paint</td><td>OHRender/src/core/SkPaint.cpp</td><td>updateOHPainter()</td></tr><tr><td>系统</td><td>HarmonyOS SDK</td><td>OH_Drawing_CanvasSaveLayer</td></tr></tbody></table></div>\n<hr />\n<p><strong>文档更新记录</strong></p>\n<div class=\"doc-table-wrap\"><table class=\"doc-table\"><thead><tr><th>日期</th><th>版本</th><th>变更</th></tr></thead><tbody><tr><td>2025-12-12</td><td>1.0</td><td>初始版本，完整链路分析</td></tr><tr><td>2025-12-15</td><td>1.1</td><td>补充 restore 实现方案，增加图层生命周期说明</td></tr></tbody></table></div>\n<p><strong>相关文档</strong></p>\n<ul>\n<li>OpenHarmony Drawing API 官方文档</li>\n<li>Skia Canvas 参考</li>\n<li>Compose Graphics 设计文档</li>\n</ul>"
        }
      ],
      "estimated_minutes": 58
    },
    {
      "module_id": "slottable-composition-8939c899",
      "title": "SlotTable 与 Composition 完整详解",
      "source_path": "runtime-analysis/SlotTable 与 Composition 完整详解.docx",
      "source_file_hash": "8939c8996d7f4ef32f287e5e0e68789b096d1943",
      "split_mode": "auto",
      "render_version": 11,
      "difficulty": 3,
      "summary": "SlotTable 与 Composition 完整详解 目录 SlotTable 概述 为什么需要 SlotTable SlotTable 的核心结构 核心概念详解 Slo...",
      "sections": [
        {
          "section_id": "57b8165d6f",
          "title": "SlotTable 与 Composition 完整详解",
          "summary": "SlotTable 与 Composition 完整详解 目录 SlotTable 概述 为什么需要 SlotTable SlotTable 的核心结构 核心概念详解 Slo...",
          "key_points": [
            "状态持久化",
            "结构比较",
            "增量更新",
            "作用域管理"
          ],
          "estimated_minutes": 69,
          "content": "SlotTable 与 Composition 完整详解\n\n目录\n\nSlotTable 概述\n\n为什么需要 SlotTable\n\nSlotTable 的核心结构\n\n核心概念详解\n\nSlotTable 与 LayoutNode 的关系\n\nSlotTable 的使用方式\n\nComposition 初始化流程\n\nstartRoot() 方法详解\n\n实际应用示例\n\nSlotTable 概述\n\nSlotTable 是 Compose 运行时的核心数据结构，用于在内存中存储整个 Composition Tree（组合树）的完整状态信息。它是 Compose 增量重组（Incremental Recomposition）机制的基础。\n\n类比理解\n\n可以将 SlotTable 理解为：\n\nUI 树的内存快照：存储了当前 UI 的结构和所有状态\n\n状态管理器：管理每个 composable 的状态值（remember、mutableStateOf 等）\n\n差异比较器：通过对比新旧 SlotTable 找出需要重组的部分\n\n设计图纸：存储了 UI 的完整结构和状态，描述了每个组件的类型、参数、状态值\n\n为什么需要 SlotTable\n\nCompose 的增量重组机制需要解决以下问题：\n\n1. 状态持久化\n\n需要在重组之间保存状态值\n\n例如 remember { mutableStateOf(0) } 的值必须在重组后保持不变\n\n2. 结构比较\n\n需要比较新旧组合树的结构\n\n识别哪些 composable 被添加、删除或修改\n\n3. 增量更新\n\n只重组真正变化的部分\n\n避免全量重建带来的性能损失\n\n4. 作用域管理\n\n管理 CompositionLocal 的作用域\n\n跟踪哪些 composable 需要访问哪些上下文值\n\nSlotTable 就是解决这些问题的核心数据结构。\n\nSlotTable 的核心结构\n\n数据结构定义\n\ninternal class SlotTable : CompositionData, Iterable<CompositionGroup> { // 1. Groups 数组：存储\"组\"的元数据（类似树的节点信息） var groups = IntArray(0) var groupsSize = 0 // 2. Slots 数组：存储实际的数据值（状态值、参数等） var slots = Array<Any?>(0) { null } var slotsSize = 0 // 3. 读写控制 private var readers = 0 // 当前活跃的 Reader 数量 internal var writer = false // 是否有活跃的 Writer // 4. 版本控制 internal var version = 0 // 用于检测并发修改 // 5. Anchor 管理 internal var anchors: ArrayList<Anchor> = arrayListOf() }\n\nGroups 数组的结构\n\n每个 Group 在 groups 数组中占用 5 个连续的整数：\n\n[Key, GroupInfo, ParentAnchor, Size, DataAnchor]\n\n理解：像\"身份证信息\"\n\n想象每个 Group 就像一个人的身份证，需要存储 5 条信息：\n\n身份证：[姓名, 性别, 出生日期, 地址, 身份证号] ↑ ↑ ↑ ↑ ↑ 信息1 信息2 信息3 信息4 信息5\n\n在 groups 数组中：\n\ngroups 数组：[Key, GroupInfo, ParentAnchor, Size, DataAnchor] ↑ ↑ ↑ ↑ ↑ 信息1 信息2 信息3 信息4 信息5\n\n具体例子：一个 Text 组\n\n假设有一个 Text(\"Hello\") 组，它在 groups 数组中占 5 个位置：\n\ngroups 数组（IntArray）： 索引: 0 1 2 3 4 5 6 7 8 9 ... 值: [Key, Info, Parent, Size, Data, Key, Info, Parent, Size, Data, ...] ↑ ↑ Text组（5个整数） 下一个组（5个整数）\n\n为什么是 5 个整数？\n\n这 5 个信息是 Group 的最小必需信息：\n\nKey (Offset 0)：组的整数键值，用于识别 composable\n\nGroupInfo (Offset 1)：标志位，包含：\n\n是否为 Node（UI 节点）\n\n是否有 ObjectKey\n\n是否有 Aux 数据\n\n是否被标记（Mark）\n\n节点数量（Node Count）\n\nParentAnchor (Offset 2)：父组的锚点引用\n\nSize (Offset 3)：组的尺寸（包含自身和所有子组）\n\nDataAnchor (Offset 4)：指向 slots 数组的锚点\n\n就像身份证必须有这 5 项信息才能完整描述一个人！\n\n如何访问 Group 的信息？\n\n// 假设 Group 从索引 startIndex 开始 fun getGroupKey(groups: IntArray, startIndex: Int): Int { return groups[startIndex + 0] // Offset 0: Key } fun getGroupInfo(groups: IntArray, startIndex: Int): Int { return groups[startIndex + 1] // Offset 1: GroupInfo } fun getParentAnchor(groups: IntArray, startIndex: Int): Int { return groups[startIndex + 2] // Offset 2: ParentAnchor } fun getGroupSize(groups: IntArray, startIndex: Int): Int { return groups[startIndex + 3] // Offset 3: Size } fun getDataAnchor(groups: IntArray, startIndex: Int): Int { return groups[startIndex + 4] // Offset 4: DataAnchor }\n\n实际例子：多个 Group\n\n假设有 3 个 Group（Column、Text1、Text2）：\n\n// groups 数组（简化示例） val groups = intArrayOf( // Group 1: Column（索引 0-4） 100, // Key: Column 的 hash 0, // GroupInfo: 普通组 -1, // ParentAnchor: 没有父组 15, // Size: 占用 15 个整数（包含自己和子组） 0, // DataAnchor: 指向 slots[0] // Group 2: Text1（索引 5-9） 200, // Key: Text 的 hash 1, // GroupInfo: Node 组 0, // ParentAnchor: 父组在索引 0（Column） 5, // Size: 占用 5 个整数 1, // DataAnchor: 指向 slots[1] // Group 3: Text2（索引 10-14） 200, // Key: Text 的 hash（和 Text1 相同） 1, // GroupInfo: Node 组 0, // ParentAnchor: 父组在索引 0（Column） 5, // Size: 占用 5 个整数 2 // DataAnchor: 指向 slots[2] )\n\n访问 Text1 组的信息：\n\nval text1StartIndex = 5 val key = groups[text1StartIndex + 0] // = 200 val info = groups[text1StartIndex + 1] // = 1 val parent = groups[text1StartIndex + 2] // = 0（指向 Column） val size = groups[text1StartIndex + 3] // = 5 val dataAnchor = groups[text1StartIndex + 4] // = 1（指向 slots[1]）\n\n内存布局图示\n\ngroups 数组（IntArray）： ┌─────────────────────────────────────────────────────────┐ │ 索引 │ 0 │ 1 │ 2 │ 3 │ 4 │ 5 │ 6 │ 7 │ ... ├─────────────────────────────────────────────────────────┤ │ 值 │ Key │Info │Parent│Size │Data │ Key │Info │Parent│ ... │ │ 100 │ 0 │ -1 │ 15 │ 0 │ 200 │ 1 │ 0 │ ... └─────────────────────────────────────────────────────────┘ ↑ ↑ ↑ Column组（5个整数） Text1组（5个整数） Text2组（5个整数） 索引0-4 索引5-9 索引10-14\n\n为什么用连续整数而不是对象？\n\n性能优势：\n\n内存连续：5 个整数连续存储，CPU 缓存友好\n\n访问快速：直接通过索引访问，无需对象解引用\n\n内存紧凑：每个 Group 只占 20 字节（5 × 4 字节），比对象小得多\n\n批量操作：可以批量移动、复制整块数据\n\n对比：\n\n// 如果用对象（慢）： class Group { var key: Int var info: Int var parent: Int var size: Int var dataAnchor: Int } // 每个对象还有对象头（8-16 字节），总共约 40+ 字节 // 用 IntArray（快）： groups[startIndex + 0] // 直接访问，20 字节\n\nSlots 数组的结构\n\nslots 数组存储每个组的实际数据：\n\n对于 Node 组：存储 LayoutNode\n\n对于普通组：存储参数值、lambda、状态值等\n\n可选：ObjectKey、Aux 数据（如 CompositionLocal map）\n\n核心概念详解\n\n1. Group（组）\n\nGroup 对应一个 composable 函数的调用，形成树形结构：\n\nColumn { // Group 1 (根组) Text(\"A\") // Group 2 (Column 的子组) Row { // Group 3 (Column 的子组) Text(\"B\") // Group 4 (Row 的子组) } }\n\n每个 Group 包含：\n\n结构信息：在树中的位置、父子关系\n\n元数据：key、是否是节点、节点数量\n\n数据引用：指向 slots 数组中实际数据的锚点\n\n2. Slot（插槽）\n\nSlot 是 slots 数组中的元素，存储实际的业务数据：\n\n@Composable fun MyComposable(state: Int, onEvent: () -> Unit) { // state 和 onEvent 会存储在 slots 中 Text(\"Count: $state\") }\n\n不同类型的 Slot：\n\n参数 Slot：存储函数参数值\n\n状态 Slot：存储 remember、mutableStateOf 的值\n\nLambda Slot：存储回调函数\n\nNode Slot：存储 LayoutNode 或其他 UI 节点\n\n3. Anchor（锚点）\n\nAnchor 就像书签或者门牌号，用来记住\"某个东西在哪里\"。\n\n生活化例子：图书馆的书架\n\n想象你在图书馆管理书籍：\n\n书架：[书1][书2][书3][书4][书5] ↑ ↑ ↑ ↑ ↑ 位置0 位置1 位置2 位置3 位置4\n\n普通方式（容易出错）：\n\n你记录：\"书3 在第 2 个位置\"\n\n但如果有人在位置 1 插入新书，书3 就变成位置 3 了，你的记录就错了！\n\n使用 Anchor（智能定位）：\n\nAnchor 有两种记录方式：\n\n正数：从左边数（\"从开头数第几个\"）\n\n负数：从右边数（\"从末尾数第几个\"）\n\n举个例子：\n\n数组：[A][B][C][D][E] (长度 5) ↑ ↑ ↑ ↑ ↑ 0 1 2 3 4 假设有个\"空隙\"（gap）在位置 2： [A][B][_][_][C][D][E] ↑ ↑ ↑↑ ↑ ↑ ↑ 0 1 23 4 5 6 gap在这里\n\n书 A（位置 0）：Anchor = 0（从左边数）\n\n书 B（位置 1）：Anchor = 1（从左边数）\n\n书 C（位置 4）：Anchor = -3（从右边数：总共 7 个位置，C 是倒数第 3 个）\n\n书 D（位置 5）：Anchor = -2（从右边数：倒数第 2 个）\n\n书 E（位置 6）：Anchor = -1（从右边数：倒数第 1 个）\n\n为什么这样设计？\n\n当 gap 移动时：\n\n如果 gap 在位置 2，只影响位置 2 附近的 Anchor\n\n位置 0、1 的 Anchor 不变（它们用正数，从左边数）\n\n位置 4、5、6 的 Anchor 不变（它们用负数，从右边数）\n\n只有跨越 gap 的 Anchor 才需要更新\n\n4. Gap Buffer（间隙缓冲区）\n\nGap Buffer 就像在数组中预留一个\"空位\"，方便快速插入和删除。\n\nGap 是否存在于 groups 数组中？\n\n答案：是的！ Gap 确实存在于 groups 数组中，但它是未使用的空间，不是有效的 Group 数据。\n\n关键理解：\n\nGap 是数组中的空位（未初始化的位置或可覆盖的位置）\n\nGap 不是 Group，它只是预留的空间\n\nGap 的位置会动态移动，用于优化插入/删除操作\n\nGap 在 groups 数组中的存在方式\n\n方式 1：未初始化的位置\n\n// groups 数组（初始状态，gap 在末尾） val groups = IntArray(20) // 分配 20 个位置 // 假设已经存储了 3 个 Group（占用 15 个位置） // [Group1(5个)][Group2(5个)][Group3(5个)][_][_][_][_][_] // 索引0-4 索引5-9 索引10-14 15 16 17 18 19 // ↑ // gap 在这里\n\n方式 2：可覆盖的位置\n\n// 当 gap 移动到中间时 // [Group1][Group2][_][_][Group3] // 0-4 5-9 10 11 12-16 // ↑↑ // gap 在这里（可以覆盖） // 这些位置（索引 10-11）的值可能是： // - 0（未初始化） // - 之前 Group 的残留数据（会被覆盖） // - 任意值（不重要，因为会被覆盖）\n\nGap 的表示方式\n\nGap 不是用特殊值标记的，而是通过位置范围来跟踪：\n\nclass SlotTable { var groups = IntArray(0) var groupsSize = 0 // 实际使用的 Group 数量 // Gap 的位置（内部维护） private var gapStart = 0 // Gap 的起始位置 private var gapEnd = 0 // Gap 的结束位置 // Gap 的大小 fun gapSize(): Int = gapEnd - gapStart }\n\nGap 性能优化的原理\n\n关键理解：\n\nGap 确实只用两个值（gapStart 和 gapEnd）来标记一个连续的空位区域\n\n性能优化的关键在于：在 gap 位置的操作是 O(1)，而普通数组是 O(n)\n\n性能对比：普通数组 vs Gap Buffer\n\n场景：在位置 i 插入一个 Group（占用 5 个位置）\n\n普通数组（慢）：\n\n// 数组：[A][B][C][D][E] // 0 1 2 3 4 // 想在位置 2 插入 [X][X][X][X][X] // 需要移动后面的所有元素！ // 时间复杂度：O(n) // n 是后面元素的数量\n\nGap Buffer（快）：\n\n// 数组：[A][B][_][_][_][_][_][C][D][E] // 0 1 2 3 4 5 6 7 8 9 // ↑ ↑ // gapStart gapEnd // 如果 gap 就在位置 2，直接插入！ // 时间复杂度：O(1) // 如果 gap 就在目标位置\n\n关键优化点：\n\n在 Gap 位置操作是 O(1)：如果 gap 正好在要插入的位置，直接插入，无需移动任何元素！\n\n移动 Gap 的成本可以分摊：虽然移动 gap 需要 O(距离)，但这个成本可以分摊到多次操作中\n\n智能策略：Compose 使用批量操作和预测策略来最小化移动成本\n\n连续区域：gap 是一个连续的空位区域，两个值就足够描述\n\n为什么只有两个值就够了？\n\n答案：因为 gap 是一个连续的区域！\n\n// Gap 的结构 gapStart = 10 // Gap 的起始位置 gapEnd = 20 // Gap 的结束位置 // Gap 的大小 gapSize = gapEnd - gapStart // = 10 // Gap 覆盖的区域 // [有效数据][_][_][_][_][_][_][_][_][_][有效数据] // ↑ ↑ // gapStart gapEnd // (索引 10) (索引 20)\n\n关键点：\n\n一个连续区域：gap 是一个连续的空位，不是多个分散的空位\n\n两个值足够：只需要 gapStart 和 gapEnd 就能完全描述这个区域\n\n简单高效：两个值的维护成本很低，但带来的性能提升很大\n\n5. GroupInfo 详解\n\nGroupInfo 是一个整数，用二进制位（bit）存储多个布尔标志，就像开关一样。\n\n类比理解：\n\n就像房间里的多个开关：\n\n开关1：灯是否亮（是/否）\n\n开关2：空调是否开（是/否）\n\n开关3：窗户是否开（是/否）\n\n…\n\nGroupInfo 用一个整数存储多个这样的开关状态！\n\nGroupInfo 存储哪些信息？\n\nGroupInfo 的每个二进制位代表一个标志：\n\n位位置（从右到左）： 位 0: 是否为 Node（UI 节点） 位 1: 是否有 ObjectKey 位 2: 是否有 Aux 数据 位 3: 是否被标记（Mark） 位 4-31: 节点数量（Node Count）\n\n示例：\n\n// 假设 GroupInfo = 0b00000001 // 二进制：00000000 00000000 00000000 00000001 // ↑ ↑ // 高位 低位（位0） // = 1（是 Node）\n\nGroupInfo 有什么用？\n\n作用 1：快速判断 Group 的类型\n\n// 检查是否是 Node 组 fun isNodeGroup(groupInfo: Int): Boolean { return (groupInfo and 0b1) != 0 // 检查位 0 } // 检查是否有 ObjectKey fun hasObjectKey(groupInfo: Int): Boolean { return (groupInfo and 0b10) != 0 // 检查位 1 } // 检查是否有 Aux 数据 fun hasAuxData(groupInfo: Int): Boolean { return (groupInfo and 0b100) != 0 // 检查位 2 }\n\n作用 2：存储节点数量\n\n// 获取节点数量（位 4-31） fun getNodeCount(groupInfo: Int): Int { return groupInfo shr 4 // 右移 4 位，获取高位 } // 设置节点数量 fun setNodeCount(groupInfo: Int, count: Int): Int { val flags = groupInfo and 0b1111 // 保留低 4 位（标志位） return flags or (count shl 4) // 设置高位（节点数量） }\n\n作用 3：标记状态\n\n// 检查是否被标记 fun isMarked(groupInfo: Int): Boolean { return (groupInfo and 0b1000) != 0 // 检查位 3 } // 设置标记 fun markGroup(groupInfo: Int): Int { return groupInfo or 0b1000 // 设置位 3 为 1 }\n\n使用场景\n\n使用场景 1：判断是否需要创建 LayoutNode\n\nfun processGroup(groups: IntArray, startIndex: Int) { val groupInfo = groups[startIndex + 1] // 获取 GroupInfo // 检查是否是 Node 组 if (isNodeGroup(groupInfo)) { // 是 Node 组，需要创建 LayoutNode val layoutNode = createLayoutNode() // 存储到 slots 数组 val dataAnchor = groups[startIndex + 4] slots[dataAnchor] = layoutNode } else { // 不是 Node 组，只是容器（如 Column、Row） // 不需要创建 LayoutNode } }\n\nSlotTable 与 LayoutNode 的关系\n\n概述\n\nSlotTable 和 LayoutNode 是 Compose 架构中两个核心组件，它们分别属于不同的层次：\n\nSlotTable：Compose Runtime 层的数据结构，存储组合树（Composition Tree）的完整状态\n\nLayoutNode：Compose UI 层的节点，代表一个可布局和可绘制的 UI 元素\n\n它们通过 Composer 和 Applier 机制连接在一起。\n\n1. 核心关系\n\n1.1 存储关系\n\nLayoutNode 存储在 SlotTable 的 slots 数组中\n\n// SlotTable.kt 注释说明（第 63-65 行） // Node - a value of a node group that can be set independently of the slots of the group. // This is, for example, where the LayoutNode is stored by the slot table when // emitting using the UIEmitter.\n\n关键点：\n\n当 Group 的 GroupInfo 标记为 isNode = true 时，对应的 LayoutNode 存储在 slots 数组中\n\n存储位置由 Group 的 DataAnchor 指向\n\n通过 groups.nodeIndex(index) 可以获取 LayoutNode 在 slots 数组中的索引\n\n1.2 数据结构映射\n\nSlotTable (Runtime 层) ├── groups 数组 │ └── Group (5个整数) │ ├── Key │ ├── GroupInfo (包含 isNode 标志) │ ├── ParentAnchor │ ├── Size │ └── DataAnchor → 指向 slots 数组 │ └── slots 数组 └── [index] = LayoutNode (当 isNode = true 时)\n\n2. 创建流程\n\n2.1 Composer 创建 LayoutNode\n\n当 Composable 函数调用 Layout 或 ComposeNode 时：\n\n// Composer.kt 第 1670-1677 行 override fun <T> createNode(factory: () -> T) { validateNodeExpected() runtimeCheck(inserting) { \"createNode() can only be called when inserting\" } val insertIndex = nodeIndexStack.peek() val groupAnchor = writer.anchor(writer.parent) groupNodeCount++ insertFixups.createAndInsertNode(factory, insertIndex, groupAnchor) }\n\n流程：\n\ncreateNode 被调用，传入 factory: () -> LayoutNode\n\n创建一个新的 Group，标记 isNode = true\n\n调用 factory() 创建 LayoutNode 实例\n\n将 LayoutNode 存储到 slots 数组中\n\n通过 DataAnchor 建立 Group 和 LayoutNode 的关联\n\n2.2 实际代码示例\n\n// Layout.kt 中的 Column 实现 @Composable fun Column( modifier: Modifier = Modifier, content: @Composable ColumnScope.() -> Unit ) { ReusableComposeNode<ComposeUiNode, Applier<Any>>( factory = { LayoutNode() }, // ← 创建 LayoutNode update = { /* ... */ }, content = content ) }\n\n执行流程：\n\n1. Column() 被调用 ↓ 2. ReusableComposeNode 调用 Composer.createNode { LayoutNode() } ↓ 3. Composer 创建 Group，设置 isNode = true ↓ 4. 调用 factory() 创建 LayoutNode 实例 ↓ 5. 将 LayoutNode 存储到 slots[DataAnchor] ↓ 6. Group 的 DataAnchor 指向 slots 数组中的 LayoutNode\n\n3. 访问机制\n\n3.1 从 SlotTable 读取 LayoutNode\n\n// SlotTable.kt 第 1229-1231 行 private fun IntArray.node(index: Int) = if (isNode(index)) { slots[nodeIndex(index)] // ← 从 slots 数组获取 LayoutNode } else Composer.Empty\n\n关键方法：\n\ngroups.isNode(index)：检查 Group 是否为 Node 组\n\ngroups.nodeIndex(index)：获取 LayoutNode 在 slots 数组中的索引\n\nslots[nodeIndex]：获取实际的 LayoutNode 实例\n\n3.2 从 LayoutNode 反向查找 SlotTable\n\nLayoutNode 本身不直接存储对 SlotTable 的引用，但可以通过以下方式关联：\n\n通过 Composition 上下文：LayoutNode 属于某个 Composition，而 Composition 持有 SlotTable\n\n通过 Applier：Applier 维护 LayoutNode 树，同时知道对应的 SlotTable\n\n4. 生命周期关系\n\n4.1 创建阶段\n\nComposition 初始化 ↓ SlotTable 创建（空） ↓ Composer 执行 Composable 函数 ↓ 遇到 Layout/ComposeNode ↓ 创建 Group (isNode = true) ↓ 创建 LayoutNode 实例 ↓ 存储到 slots 数组 ↓ Applier 将 LayoutNode 添加到树中\n\n4.2 重组阶段\n\n状态变化触发重组 ↓ Composer 比较新旧 SlotTable ↓ 发现 Group 需要更新 ↓ 从 slots 数组读取现有 LayoutNode ↓ 调用 update 回调更新 LayoutNode ↓ LayoutNode 标记为需要重新测量/布局\n\n4.3 删除阶段\n\nComposable 被移除 ↓ SlotTable 删除对应的 Group ↓ 从 slots 数组移除 LayoutNode 引用 ↓ Applier 从树中移除 LayoutNode ↓ LayoutNode 被回收\n\n5. 数据同步机制\n\n5.1 状态同步\n\nSlotTable 存储的状态 → LayoutNode 的属性\n\n// 示例：Modifier 更新 @Composable fun MyComposable(modifier: Modifier) { Layout(content = {}) { measurables, constraints -> // ... } } // 重组时： // 1. SlotTable 中存储的 modifier 值变化 // 2. Composer 检测到变化 // 3. 调用 update 回调 // 4. LayoutNode.modifier 被更新\n\n5.2 结构同步\n\nSlotTable 的 Group 树 ↔ LayoutNode 树\n\nSlotTable Groups 树 LayoutNode 树 ┌─────────────────┐ ┌──────────────┐ │ Group (Column) │ ←──→ │ LayoutNode │ │ ├─ Group (T1)│ ←──→ │ ├─ LayoutNode│ │ └─ Group (T2)│ ←──→ │ └─ LayoutNode│ └─────────────────┘ └──────────────┘\n\n同步机制：\n\nApplier 负责维护两棵树的一致性\n\n当 SlotTable 变化时，Applier 更新 LayoutNode 树\n\n通过 Applier.insert、Applier.remove、Applier.move 等方法\n\n6. 关键代码位置\n\n6.1 SlotTable 相关\n\n定义：compose/runtime/runtime/src/commonMain/kotlin/androidx/compose/runtime/SlotTable.kt\n\nNode 存储：第 1229-1231 行（node() 方法）\n\nNode 索引：groups.nodeIndex(index) 方法\n\n6.2 LayoutNode 相关\n\n定义：compose/ui/ui/src/commonMain/kotlin/androidx/compose/ui/node/LayoutNode.kt\n\n实现 ComposeNodeLifecycleCallback：第 88 行\n\n6.3 连接点\n\nComposer.createNode：compose/runtime/runtime/src/commonMain/kotlin/androidx/compose/runtime/Composer.kt 第 1670 行\n\nApplier：负责将 SlotTable 的变化应用到 LayoutNode 树\n\n7. 总结\n\n7.1 核心关系\n\n存储关系：LayoutNode 存储在 SlotTable 的 slots 数组中\n\n创建关系：Composer 通过 createNode 创建 LayoutNode 并存储到 SlotTable\n\n访问关系：通过 Group 的 DataAnchor 和 nodeIndex 访问 LayoutNode\n\n同步关系：Applier 负责保持 SlotTable 和 LayoutNode 树的一致性\n\n7.2 设计优势\n\n分离关注点：\n\nSlotTable 专注于状态管理和结构存储\n\nLayoutNode 专注于布局和绘制\n\n性能优化：\n\nSlotTable 使用紧凑的数组结构\n\nLayoutNode 只在需要时才创建\n\n增量更新：\n\n通过比较 SlotTable 找出变化\n\n只更新受影响的 LayoutNode\n\n7.3 类比理解\n\nSlotTable 就像\"设计图纸\"：\n\n存储了 UI 的完整结构和状态\n\n描述了每个组件的类型、参数、状态值\n\nLayoutNode 就像\"实际建筑\"：\n\n根据设计图纸建造的实际 UI 元素\n\n负责实际的布局、测量、绘制\n\nComposer 就像\"建筑师\"：\n\n根据设计图纸（SlotTable）建造建筑（LayoutNode）\n\n当图纸变化时，更新或重建建筑\n\nSlotTable 的使用方式\n\n基本使用模式\n\n虽然开发者通常不直接使用 SlotTable，但了解其使用模式有助于理解 Compose 的工作原理：\n\n1. 读取模式（Reader）\n\nslotTable.read { reader -> // 遍历组合树 reader.startGroup() // 读取当前组的数据 val oldValue = reader.next() // 读取第一个 slot val lambda = reader.next() // 读取第二个 slot // 处理子组 while (!reader.isGroupEnd) { // 递归处理子组... } reader.endGroup() }\n\n特点：\n\n支持多个 Reader 同时读取\n\n不能在有 Writer 时读取\n\n使用期间不能写入\n\n2. 写入模式（Writer）\n\n// 写入新的组合树状态 slotTable.write { writer -> writer.startGroup(key = composableKey) // 写入/更新数据 writer.update(newValue) // 更新第一个 slot writer.update(newLambda) // 更新第二个 slot // 处理子组 // ... writer.endGroup() }\n\n特点：\n\n只能有一个 Writer 同时写入\n\n写入时不能有 Reader\n\n写入完成后，Gap 会被移动到末尾\n\n3. 完整的重组流程\n\n// 1. 读取旧状态 slotTable.read { reader -> // 比较结构，识别变化 } // 2. 写入新状态 slotTable.write { writer -> // 更新变化的部分 if (hasChanges) { writer.update(newValue) } else { writer.skip() // 跳过未变化的部分 } }\n\nComposition 初始化流程\n\n整体流程\n\n当调用 setContent { ... } 时，Compose 会执行以下步骤：\n\n1. 创建 Composition └─> 创建 SlotTable（如果首次） └─> 创建 Composer 2. 开始 Composition └─> startRoot() ← 这是我们要重点分析的 3. 执行 Composable 函数 └─> 构建组合树 └─> 填充 SlotTable 4. 结束 Composition └─> endRoot() └─> 应用变化到 UI\n\nstartRoot() 的位置\n\nstartRoot() 是 Composition 的入口方法，在每个 Composition 开始时都会被调用一次。\n\nstartRoot() 方法详解\n\n完整代码\n\n@OptIn(InternalComposeApi::class) private fun startRoot() { OhosTrace.traceSync(\"Composer startRoot\", { // 1. 打开 SlotTable Reader reader = slotTable.openReader() // 2. 开始根组 startGroup(rootKey) // 3. 父上下文管理 parentContext.startComposing() parentProvider = parentContext.getCompositionLocalScope() providersInvalidStack.push(providersInvalid.asInt()) providersInvalid = changed(parentProvider) providerCache = null // 4. 调试信息收集 if (!forceRecomposeScopes) { forceRecomposeScopes = parentContext.collectingParameterInformation } // 5. 源码信息收集 if (!sourceInformationEnabled) { sourceInformationEnabled = parentContext.collectingSourceInformation } // 6. 检查表注册 parentProvider.read(LocalInspectionTables)?.let { it.add(slotTable) parentContext.recordInspectionTable(it) } // 7. 开始父上下文组 startGroup(parentContext.compoundHashKey) }) }\n\n逐步解析\n\n步骤 1: 打开 SlotTable Reader\n\nreader = slotTable.openReader()\n\n作用：\n\n打开 SlotTable 的读取通道\n\n准备读取现有的组合树状态\n\n如果这是首次组合，SlotTable 可能是空的\n\n要点：\n\nReader 用于读取之前保存的状态\n\n在重组时，可以通过 Reader 比较新旧结构\n\n步骤 2: 开始根组\n\nstartGroup(rootKey)\n\n作用：\n\n在 SlotTable 中创建一个根组（Root Group）\n\nrootKey 是一个特殊的键值，标识这是整个 Composition 的根\n\n结构示意：\n\nSlotTable: Group(rootKey) ← 根组开始 └─> [后续所有 composable 组都会是这个组的子组]\n\n步骤 3: 父上下文管理\n\nparentContext.startComposing() parentProvider = parentContext.getCompositionLocalScope() providersInvalidStack.push(providersInvalid.asInt()) providersInvalid = changed(parentProvider) providerCache = null\n\n详细解释：\n\nparentContext.startComposing()\n\n通知父上下文开始组合\n\n用于嵌套 Composition 的场景\n\nparentProvider = parentContext.getCompositionLocalScope()\n\n获取父级的 CompositionLocal 作用域\n\nCompositionLocal 用于向下传递上下文值（类似 Context in Android）\n\n例如：LocalContext、LocalConfiguration 等\n\nprovidersInvalidStack.push(...) 和 providersInvalid = changed(...)\n\n作用： 检查 CompositionLocal 是否变化\n\n机制：\n\n将旧的 providersInvalid 状态压栈保存\n\n检查新的 parentProvider 是否有变化\n\n如果有变化，providersInvalid 会被标记，触发相关 composable 重组\n\n为什么需要栈？ 支持嵌套的 CompositionLocal 作用域\n\nproviderCache = null\n\n清空 CompositionLocal 的缓存\n\n确保使用最新的上下文值\n\n步骤 4: 调试信息收集\n\nif (!forceRecomposeScopes) { forceRecomposeScopes = parentContext.collectingParameterInformation }\n\n作用：\n\n如果父上下文正在收集参数信息（用于调试工具），启用强制重组范围\n\n用于 Android Studio 的 Compose 调试功能\n\n可以显示哪些 composable 的参数发生了变化\n\n使用场景：\n\nLayout Inspector\n\nRecomposition Count 调试\n\nParameter Tracking\n\n步骤 5: 源码信息收集\n\nif (!sourceInformationEnabled) { sourceInformationEnabled = parentContext.collectingSourceInformation }\n\n作用：\n\n启用源码信息收集功能\n\n用于在调试时显示 composable 的来源位置（文件名、行号等）\n\n存储在 GroupSourceInformation 中\n\n示例：\n\n// 调试工具可以显示： // MyComposable.kt:42 ← 这个 composable 定义在哪个文件的哪一行\n\n步骤 6: 检查表注册\n\nparentProvider.read(LocalInspectionTables)?.let { it.add(slotTable) parentContext.recordInspectionTable(it) }\n\n作用：\n\n将当前 SlotTable 注册到检查表（Inspection Table）\n\n用于 Android Studio 的 Composition Inspector\n\n允许开发工具实时查看组合树的结构\n\n检查表的作用：\n\n显示当前 Composition 的完整树结构\n\n显示每个 composable 的状态值\n\n显示重组次数和原因\n\n步骤 7: 开始父上下文组\n\nstartGroup(parentContext.compoundHashKey)\n\n作用：\n\n开始一个用于管理父上下文的作用域组\n\ncompoundHashKey 是父上下文的唯一标识\n\n这个组用于隔离不同嵌套层级的 CompositionLocal 值\n\n结构示意：\n\nSlotTable: Group(rootKey) ← 步骤 2 创建的根组 Group(parentContextKey) ← 步骤 7 创建的父上下文组 └─> [实际的 UI composable 组]\n\n为什么需要这个组？\n\n管理 CompositionLocal 的层级作用域\n\n确保每个层级有独立的上下文值\n\n支持嵌套的 CompositionLocalProvider\n\n实际应用示例\n\n示例 1: 首次组合\n\n// 用户代码 setContent { Column { Text(\"Hello\") Button(onClick = {}) { Text(\"Click\") } } }\n\n执行流程：\n\nstartRoot() 被调用\n\n创建根组和父上下文组\n\n初始化 CompositionLocal 作用域\n\nColumn { … } 被调用\n\n创建 Column 组（key = Column 的 hash）\n\n在 slots 中存储 Column 的参数（content lambda）\n\nText(\"Hello\") 被调用\n\n创建 Text 组（key = Text 的 hash）\n\n在 slots 中存储参数（\"Hello\"）\n\n创建 LayoutNode 用于渲染\n\nButton { … } 被调用\n\n创建 Button 组\n\n存储 onClick lambda 和 content lambda\n\nendRoot() 被调用\n\n关闭 Reader\n\n应用变化到 UI 层\n\n示例 2: 重组场景\n\nvar count by remember { mutableStateOf(0) } Column { Text(\"Count: $count\") // 当 count 变化时，这个 Text 需要重组 Button(onClick = { count++ }) { Text(\"Increment\") } }\n\n重组流程：\n\nstartRoot() 被调用\n\n打开 Reader，读取现有的 SlotTable\n\nColumn { … } 被比较\n\nReader 找到 Column 组\n\n比较 key 是否匹配 → 匹配，继续\n\nText(\"Count: $count\") 被比较\n\nReader 找到 Text 组\n\n读取旧的 count 值（存储在 slot 中）\n\n比较新旧 count 值 → 不匹配！\n\n标记该组需要重组\n\n重组执行\n\nWriter 更新 Text 组的 slot\n\n新的 count 值被写入\n\nButton { … } 被比较\n\n没有变化，跳过\n\n示例 3: CompositionLocal 使用\n\n// 提供上下文值 CompositionLocalProvider(LocalContentAlpha provides 0.5f) { Column { Text(\"Alpha: ${LocalContentAlpha.current}\") // 使用上下文值 } }\n\nstartRoot() 中的处理：\n\n获取父上下文\n\nparentProvider = parentContext.getCompositionLocalScope()\n\n获取包含 LocalContentAlpha = 0.5f 的作用域\n\n检查变化\n\nprovidersInvalid = changed(parentProvider)\n\n如果 LocalContentAlpha 的值变化，标记需要重组\n\n创建作用域组\n\nstartGroup(parentContext.compoundHashKey)\n\n创建一个组来管理这个 CompositionLocal 作用域\n\n示例 4: 重组优化\n\n@Composable fun MyScreen() { var count by remember { mutableStateOf(0) } Column { Text(\"Count: $count\") // ← 只有这个会重组 Button(onClick = { count++ }) { Text(\"Increment\") } } }\n\n执行流程：\n\n状态变化：count 从 0 变为 1\n\nSlotTable 比较：发现 Text 的 Group 需要更新\n\n读取 LayoutNode：从 slots[nodeIndex] 获取 Text 的 LayoutNode\n\n更新内容：调用 update 回调更新 Text 的文本\n\n标记重绘：LayoutNode 标记为需要重绘\n\n示例 5: 节点复用\n\n@Composable fun List(items: List<Item>) { items.forEach { item -> ItemRow(item) // ← 相同的 key 会复用 LayoutNode } }\n\n执行流程：\n\n第一次组合：为每个 item 创建 Group 和 LayoutNode\n\n列表变化：添加/删除 item\n\nSlotTable 比较：通过 key 匹配新旧 Group\n\n复用 LayoutNode：如果 key 匹配，复用现有的 LayoutNode\n\n更新内容：只更新变化的部分\n\n调试技巧\n\n1. 查看 SlotTable 内容\n\n// 在调试器中 composition.slotTable.groups // 查看 groups 数组 composition.slotTable.slots // 查看 slots 数组（包含 LayoutNode）\n\n2. 查看 LayoutNode 树\n\n// 从 Composition 获取根 LayoutNode val rootNode = (composition as? ControlledComposition)?.root rootNode?.forEach { node -> println(\"LayoutNode: ${node.javaClass.simpleName}\") }\n\n3. 验证关联关系\n\n// 验证 SlotTable 中的 LayoutNode 和实际的 LayoutNode 树是否一致 val slotTableNodes = composition.slotTable.slots.filterIsInstance<LayoutNode>() val layoutTreeNodes = rootNode?.collectAllNodes() ?: emptyList() // 比较两个列表是否一致\n\n常见问题\n\nQ1: 为什么 LayoutNode 不直接存储在 Group 中？\n\nA: 性能考虑。使用数组存储可以：\n\n减少内存碎片\n\n提高缓存局部性\n\n支持批量操作\n\nQ2: SlotTable 和 LayoutNode 树是否总是同步？\n\nA: 在正常流程中是的，但存在短暂的异步窗口：\n\nSlotTable 先更新（重组阶段）\n\n然后通过 Applier 应用到 LayoutNode 树（应用阶段）\n\nQ3: 如何知道一个 LayoutNode 对应哪个 Group？\n\nA: 通过 Applier 维护的映射关系，或者遍历 SlotTable 查找 slots[nodeIndex] == layoutNode 的 Group。\n\nQ4: Gap 是否存在于 groups 数组中？\n\nA: 是的！Gap 确实存在于 groups 数组中，但它是未使用的空间，不是有效的 Group 数据。\n\n关键点：\n\nGap 是数组中的空位：未使用的空间，不是有效的 Group 数据\n\nGap 的位置会动态移动：根据插入/删除操作的需要移动\n\nGap 中的值不重要：可能是 0、未初始化值或残留数据\n\n通过位置范围跟踪：使用 gapStart 和 gapEnd 来标记 gap 的位置\n\n两个数组都有 gap：groups 数组和 slots 数组都有各自的 gap\n\n性能优化：在 gap 位置操作是 O(1)，移动成本可以分摊，实际性能更好\n\n总结\n\nSlotTable 的作用\n\n状态存储：保存所有 composable 的状态值\n\n结构管理：维护组合树的完整结构\n\n差异检测：通过比较实现增量重组\n\n性能优化：使用 Gap Buffer 优化更新性能\n\nstartRoot() 的作用\n\n初始化组合：创建根组和父上下文组\n\n上下文管理：设置 CompositionLocal 作用域\n\n调试支持：启用调试工具所需的信息收集\n\n检查工具：注册 SlotTable 供开发工具使用\n\nSlotTable 与 LayoutNode 的关系\n\n存储关系：LayoutNode 存储在 SlotTable 的 slots 数组中\n\n创建关系：Composer 通过 createNode 创建 LayoutNode 并存储到 SlotTable\n\n访问关系：通过 Group 的 DataAnchor 和 nodeIndex 访问 LayoutNode\n\n同步关系：Applier 负责保持 SlotTable 和 LayoutNode 树的一致性\n\n关键要点\n\nSlotTable 是 Compose 的核心：几乎所有 Compose 特性都依赖于它\n\n增量重组的基础：通过 SlotTable 的比较实现高效的 UI 更新\n\n状态管理的关键：所有状态都存储在 SlotTable 的 slots 中\n\n开发工具的支撑：Composition Inspector 等工具依赖 SlotTable\n\n设计图纸与建筑：SlotTable 是设计图纸，LayoutNode 是实际建筑，Composer 是建筑师\n\n理解 SlotTable、LayoutNode 和 startRoot() 的工作原理，有助于：\n\n更好地理解 Compose 的重组机制\n\n优化性能（避免不必要的重组）\n\n调试 Compose 相关问题\n\n深入理解 Compose 的设计哲学\n\n参考资料\n\nSlotTable.kt - Compose Runtime 核心数据结构\n\nLayoutNode.kt - Compose UI 布局节点\n\nComposer.kt - 组合执行器\n\nApplier.kt - 应用器，负责同步 SlotTable 和 LayoutNode 树\n\nCompose 官方文档：重组\n\n目录",
          "content_html": "<h1>SlotTable 与 Composition 完整详解</h1>\n<h2><strong>目录</strong></h2>\n<ol>\n<li>SlotTable 概述</li>\n<li>为什么需要 SlotTable</li>\n<li>SlotTable 的核心结构</li>\n<li>核心概念详解</li>\n<li>SlotTable 与 LayoutNode 的关系</li>\n<li>SlotTable 的使用方式</li>\n<li>Composition 初始化流程</li>\n<li>startRoot() 方法详解</li>\n<li>实际应用示例</li>\n</ol>\n<hr />\n<h2><strong>SlotTable 概述</strong></h2>\n<p><code>SlotTable</code> 是 Compose 运行时的<strong>核心数据结构</strong>，用于在内存中存储整个 Composition Tree（组合树）的完整状态信息。它是 Compose 增量重组（Incremental Recomposition）机制的基础。</p>\n<h3><strong>类比理解</strong></h3>\n<p>可以将 <code>SlotTable</code> 理解为：</p>\n<ul>\n<li><strong>UI 树的内存快照</strong>：存储了当前 UI 的结构和所有状态</li>\n<li><strong>状态管理器</strong>：管理每个 composable 的状态值（remember、mutableStateOf 等）</li>\n<li><strong>差异比较器</strong>：通过对比新旧 SlotTable 找出需要重组的部分</li>\n<li><strong>设计图纸</strong>：存储了 UI 的完整结构和状态，描述了每个组件的类型、参数、状态值</li>\n</ul>\n<hr />\n<h2><strong>为什么需要 SlotTable</strong></h2>\n<p>Compose 的增量重组机制需要解决以下问题：</p>\n<h3><strong>1. 状态持久化</strong></h3>\n<ul>\n<li>需要在重组之间保存状态值</li>\n<li>例如 <code>remember { mutableStateOf(0) }</code> 的值必须在重组后保持不变</li>\n</ul>\n<h3><strong>2. 结构比较</strong></h3>\n<ul>\n<li>需要比较新旧组合树的结构</li>\n<li>识别哪些 composable 被添加、删除或修改</li>\n</ul>\n<h3><strong>3. 增量更新</strong></h3>\n<ul>\n<li>只重组真正变化的部分</li>\n<li>避免全量重建带来的性能损失</li>\n</ul>\n<h3><strong>4. 作用域管理</strong></h3>\n<ul>\n<li>管理 CompositionLocal 的作用域</li>\n<li>跟踪哪些 composable 需要访问哪些上下文值</li>\n</ul>\n<p><strong>SlotTable 就是解决这些问题的核心数据结构。</strong></p>\n<hr />\n<h2><strong>SlotTable 的核心结构</strong></h2>\n<h3><strong>数据结构定义</strong></h3>\n<pre><code>internal class SlotTable : CompositionData, Iterable&lt;CompositionGroup&gt; {\n// 1. Groups 数组：存储\"组\"的元数据（类似树的节点信息）\nvar groups = IntArray(0)\nvar groupsSize = 0\n// 2. Slots 数组：存储实际的数据值（状态值、参数等）\nvar slots = Array&lt;Any?&gt;(0) { null }\nvar slotsSize = 0\n// 3. 读写控制\nprivate var readers = 0 // 当前活跃的 Reader 数量\ninternal var writer = false // 是否有活跃的 Writer\n// 4. 版本控制\ninternal var version = 0 // 用于检测并发修改\n// 5. Anchor 管理\ninternal var anchors: ArrayList&lt;Anchor&gt; = arrayListOf()\n}</code></pre>\n<h3><strong>Groups 数组的结构</strong></h3>\n<p>每个 Group 在 <code>groups</code> 数组中占用 <strong>5 个连续的整数</strong>：</p>\n<pre><code>[Key, GroupInfo, ParentAnchor, Size, DataAnchor]</code></pre>\n<h3><strong>理解：像\"身份证信息\"</strong></h3>\n<p>想象每个 Group 就像一个人的身份证，需要存储 5 条信息：</p>\n<pre><code>身份证：[姓名, 性别, 出生日期, 地址, 身份证号]\n↑ ↑ ↑ ↑ ↑\n信息1 信息2 信息3 信息4 信息5</code></pre>\n<p><strong>在 groups 数组中：</strong></p>\n<pre><code>groups 数组：[Key, GroupInfo, ParentAnchor, Size, DataAnchor]\n↑ ↑ ↑ ↑ ↑\n信息1 信息2 信息3 信息4 信息5</code></pre>\n<h3><strong>具体例子：一个 Text 组</strong></h3>\n<p>假设有一个 <code>Text(\"Hello\")</code> 组，它在 groups 数组中占 5 个位置：</p>\n<pre><code>groups 数组（IntArray）：\n索引: 0 1 2 3 4 5 6 7 8 9 ...\n值: [Key, Info, Parent, Size, Data, Key, Info, Parent, Size, Data, ...]\n↑ ↑\nText组（5个整数） 下一个组（5个整数）</code></pre>\n<h3><strong>为什么是 5 个整数？</strong></h3>\n<p>这 5 个信息是 Group 的<strong>最小必需信息</strong>：</p>\n<ol>\n<li><strong>Key (Offset 0)</strong>：组的整数键值，用于识别 composable</li>\n<li><strong>GroupInfo (Offset 1)</strong>：标志位，包含：</li>\n</ol>\n<ul>\n<li>是否为 Node（UI 节点）</li>\n<li>是否有 ObjectKey</li>\n<li>是否有 Aux 数据</li>\n<li>是否被标记（Mark）</li>\n<li>节点数量（Node Count）</li>\n</ul>\n<ol>\n<li><strong>ParentAnchor (Offset 2)</strong>：父组的锚点引用</li>\n<li><strong>Size (Offset 3)</strong>：组的尺寸（包含自身和所有子组）</li>\n<li><strong>DataAnchor (Offset 4)</strong>：指向 slots 数组的锚点</li>\n</ol>\n<p><strong>就像身份证必须有这 5 项信息才能完整描述一个人！</strong></p>\n<h3><strong>如何访问 Group 的信息？</strong></h3>\n<pre><code>// 假设 Group 从索引 startIndex 开始\nfun getGroupKey(groups: IntArray, startIndex: Int): Int {\nreturn groups[startIndex + 0] // Offset 0: Key\n}\nfun getGroupInfo(groups: IntArray, startIndex: Int): Int {\nreturn groups[startIndex + 1] // Offset 1: GroupInfo\n}\nfun getParentAnchor(groups: IntArray, startIndex: Int): Int {\nreturn groups[startIndex + 2] // Offset 2: ParentAnchor\n}\nfun getGroupSize(groups: IntArray, startIndex: Int): Int {\nreturn groups[startIndex + 3] // Offset 3: Size\n}\nfun getDataAnchor(groups: IntArray, startIndex: Int): Int {\nreturn groups[startIndex + 4] // Offset 4: DataAnchor\n}</code></pre>\n<h3><strong>实际例子：多个 Group</strong></h3>\n<p>假设有 3 个 Group（Column、Text1、Text2）：</p>\n<pre><code>// groups 数组（简化示例）\nval groups = intArrayOf(\n// Group 1: Column（索引 0-4）\n100, // Key: Column 的 hash\n0, // GroupInfo: 普通组\n-1, // ParentAnchor: 没有父组\n15, // Size: 占用 15 个整数（包含自己和子组）\n0, // DataAnchor: 指向 slots[0]\n// Group 2: Text1（索引 5-9）\n200, // Key: Text 的 hash\n1, // GroupInfo: Node 组\n0, // ParentAnchor: 父组在索引 0（Column）\n5, // Size: 占用 5 个整数\n1, // DataAnchor: 指向 slots[1]\n// Group 3: Text2（索引 10-14）\n200, // Key: Text 的 hash（和 Text1 相同）\n1, // GroupInfo: Node 组\n0, // ParentAnchor: 父组在索引 0（Column）\n5, // Size: 占用 5 个整数\n2 // DataAnchor: 指向 slots[2]\n)</code></pre>\n<p><strong>访问 Text1 组的信息：</strong></p>\n<pre><code>val text1StartIndex = 5\nval key = groups[text1StartIndex + 0] // = 200\nval info = groups[text1StartIndex + 1] // = 1\nval parent = groups[text1StartIndex + 2] // = 0（指向 Column）\nval size = groups[text1StartIndex + 3] // = 5\nval dataAnchor = groups[text1StartIndex + 4] // = 1（指向 slots[1]）</code></pre>\n<h3><strong>内存布局图示</strong></h3>\n<pre><code>groups 数组（IntArray）：\n┌─────────────────────────────────────────────────────────┐\n│ 索引 │ 0 │ 1 │ 2 │ 3 │ 4 │ 5 │ 6 │ 7 │ ...\n├─────────────────────────────────────────────────────────┤\n│ 值 │ Key │Info │Parent│Size │Data │ Key │Info │Parent│ ...\n│ │ 100 │ 0 │ -1 │ 15 │ 0 │ 200 │ 1 │ 0 │ ...\n└─────────────────────────────────────────────────────────┘\n↑ ↑ ↑\nColumn组（5个整数） Text1组（5个整数） Text2组（5个整数）\n索引0-4 索引5-9 索引10-14</code></pre>\n<h3><strong>为什么用连续整数而不是对象？</strong></h3>\n<p><strong>性能优势：</strong></p>\n<ol>\n<li><strong>内存连续</strong>：5 个整数连续存储，CPU 缓存友好</li>\n<li><strong>访问快速</strong>：直接通过索引访问，无需对象解引用</li>\n<li><strong>内存紧凑</strong>：每个 Group 只占 20 字节（5 × 4 字节），比对象小得多</li>\n<li><strong>批量操作</strong>：可以批量移动、复制整块数据</li>\n</ol>\n<p><strong>对比：</strong></p>\n<pre><code>// 如果用对象（慢）：\nclass Group {\nvar key: Int\nvar info: Int\nvar parent: Int\nvar size: Int\nvar dataAnchor: Int\n}\n// 每个对象还有对象头（8-16 字节），总共约 40+ 字节\n// 用 IntArray（快）：\ngroups[startIndex + 0] // 直接访问，20 字节</code></pre>\n<h3><strong>Slots 数组的结构</strong></h3>\n<p><code>slots</code> 数组存储每个组的实际数据：</p>\n<ul>\n<li>对于 Node 组：存储 <code>LayoutNode</code></li>\n<li>对于普通组：存储参数值、lambda、状态值等</li>\n<li>可选：ObjectKey、Aux 数据（如 CompositionLocal map）</li>\n</ul>\n<hr />\n<h2><strong>核心概念详解</strong></h2>\n<h3><strong>1. Group（组）</strong></h3>\n<p><strong>Group</strong> 对应一个 composable 函数的调用，形成树形结构：</p>\n<pre><code>Column { // Group 1 (根组)\nText(\"A\") // Group 2 (Column 的子组)\nRow { // Group 3 (Column 的子组)\nText(\"B\") // Group 4 (Row 的子组)\n}\n}</code></pre>\n<p>每个 Group 包含：</p>\n<ul>\n<li>结构信息：在树中的位置、父子关系</li>\n<li>元数据：key、是否是节点、节点数量</li>\n<li>数据引用：指向 slots 数组中实际数据的锚点</li>\n</ul>\n<h3><strong>2. Slot（插槽）</strong></h3>\n<p><strong>Slot</strong> 是 <code>slots</code> 数组中的元素，存储实际的业务数据：</p>\n<pre><code>@Composable\nfun MyComposable(state: Int, onEvent: () -&gt; Unit) {\n// state 和 onEvent 会存储在 slots 中\nText(\"Count: $state\")\n}</code></pre>\n<p>不同类型的 Slot：</p>\n<ul>\n<li><strong>参数 Slot</strong>：存储函数参数值</li>\n<li><strong>状态 Slot</strong>：存储 <code>remember</code>、<code>mutableStateOf</code> 的值</li>\n<li><strong>Lambda Slot</strong>：存储回调函数</li>\n<li><strong>Node Slot</strong>：存储 <code>LayoutNode</code> 或其他 UI 节点</li>\n</ul>\n<h3><strong>3. Anchor（锚点）</strong></h3>\n<p><strong>Anchor 就像书签或者门牌号</strong>，用来记住\"某个东西在哪里\"。</p>\n<h4><strong>生活化例子：图书馆的书架</strong></h4>\n<p>想象你在图书馆管理书籍：</p>\n<pre><code>书架：[书1][书2][书3][书4][书5]\n↑ ↑ ↑ ↑ ↑\n位置0 位置1 位置2 位置3 位置4</code></pre>\n<p><strong>普通方式（容易出错）：</strong></p>\n<ul>\n<li>你记录：\"书3 在第 2 个位置\"</li>\n<li>但如果有人在位置 1 插入新书，书3 就变成位置 3 了，你的记录就错了！</li>\n</ul>\n<p><strong>使用 Anchor（智能定位）：</strong></p>\n<ul>\n<li>Anchor 有两种记录方式：</li>\n</ul>\n<ol>\n<li><strong>正数</strong>：从左边数（\"从开头数第几个\"）</li>\n<li><strong>负数</strong>：从右边数（\"从末尾数第几个\"）</li>\n</ol>\n<p><strong>举个例子：</strong></p>\n<pre><code>数组：[A][B][C][D][E] (长度 5)\n↑ ↑ ↑ ↑ ↑\n0 1 2 3 4\n假设有个\"空隙\"（gap）在位置 2：\n[A][B][_][_][C][D][E]\n↑ ↑ ↑↑ ↑ ↑ ↑\n0 1 23 4 5 6\ngap在这里</code></pre>\n<ul>\n<li><strong>书 A（位置 0）</strong>：Anchor = 0（从左边数）</li>\n<li><strong>书 B（位置 1）</strong>：Anchor = 1（从左边数）</li>\n<li><strong>书 C（位置 4）</strong>：Anchor = -3（从右边数：总共 7 个位置，C 是倒数第 3 个）</li>\n<li><strong>书 D（位置 5）</strong>：Anchor = -2（从右边数：倒数第 2 个）</li>\n<li><strong>书 E（位置 6）</strong>：Anchor = -1（从右边数：倒数第 1 个）</li>\n</ul>\n<p><strong>为什么这样设计？</strong></p>\n<p>当 gap 移动时：</p>\n<ul>\n<li>如果 gap 在位置 2，只影响位置 2 附近的 Anchor</li>\n<li>位置 0、1 的 Anchor 不变（它们用正数，从左边数）</li>\n<li>位置 4、5、6 的 Anchor 不变（它们用负数，从右边数）</li>\n<li><strong>只有跨越 gap 的 Anchor 才需要更新</strong></li>\n</ul>\n<h3><strong>4. Gap Buffer（间隙缓冲区）</strong></h3>\n<p><strong>Gap Buffer 就像在数组中预留一个\"空位\"</strong>，方便快速插入和删除。</p>\n<h4><strong>Gap 是否存在于 groups 数组中？</strong></h4>\n<p><strong>答案：是的！</strong> Gap 确实存在于 <code>groups</code> 数组中，但它是<strong>未使用的空间</strong>，不是有效的 Group 数据。</p>\n<p><strong>关键理解：</strong></p>\n<ul>\n<li>Gap 是数组中的<strong>空位</strong>（未初始化的位置或可覆盖的位置）</li>\n<li>Gap 不是 Group，它只是<strong>预留的空间</strong></li>\n<li>Gap 的位置会动态移动，用于优化插入/删除操作</li>\n</ul>\n<h4><strong>Gap 在 groups 数组中的存在方式</strong></h4>\n<p><strong>方式 1：未初始化的位置</strong></p>\n<pre><code>// groups 数组（初始状态，gap 在末尾）\nval groups = IntArray(20) // 分配 20 个位置\n// 假设已经存储了 3 个 Group（占用 15 个位置）\n// [Group1(5个)][Group2(5个)][Group3(5个)][_][_][_][_][_]\n// 索引0-4 索引5-9 索引10-14 15 16 17 18 19\n// ↑\n// gap 在这里</code></pre>\n<p><strong>方式 2：可覆盖的位置</strong></p>\n<pre><code>// 当 gap 移动到中间时\n// [Group1][Group2][_][_][Group3]\n// 0-4 5-9 10 11 12-16\n// ↑↑\n// gap 在这里（可以覆盖）\n// 这些位置（索引 10-11）的值可能是：\n// - 0（未初始化）\n// - 之前 Group 的残留数据（会被覆盖）\n// - 任意值（不重要，因为会被覆盖）</code></pre>\n<h4><strong>Gap 的表示方式</strong></h4>\n<p><strong>Gap 不是用特殊值标记的，而是通过位置范围来跟踪：</strong></p>\n<pre><code>class SlotTable {\nvar groups = IntArray(0)\nvar groupsSize = 0 // 实际使用的 Group 数量\n// Gap 的位置（内部维护）\nprivate var gapStart = 0 // Gap 的起始位置\nprivate var gapEnd = 0 // Gap 的结束位置\n// Gap 的大小\nfun gapSize(): Int = gapEnd - gapStart\n}</code></pre>\n<h4><strong>Gap 性能优化的原理</strong></h4>\n<p><strong>关键理解：</strong></p>\n<ul>\n<li>Gap 确实只用<strong>两个值</strong>（<code>gapStart</code> 和 <code>gapEnd</code>）来标记一个<strong>连续的空位区域</strong></li>\n<li>性能优化的关键在于：<strong>在 gap 位置的操作是 O(1)</strong>，而普通数组是 O(n)</li>\n</ul>\n<p><strong>性能对比：普通数组 vs Gap Buffer</strong></p>\n<p><strong>场景：在位置 i 插入一个 Group（占用 5 个位置）</strong></p>\n<p><strong>普通数组（慢）：</strong></p>\n<pre><code>// 数组：[A][B][C][D][E]\n// 0 1 2 3 4\n// 想在位置 2 插入 [X][X][X][X][X]\n// 需要移动后面的所有元素！\n// 时间复杂度：O(n) // n 是后面元素的数量</code></pre>\n<p><strong>Gap Buffer（快）：</strong></p>\n<pre><code>// 数组：[A][B][_][_][_][_][_][C][D][E]\n// 0 1 2 3 4 5 6 7 8 9\n// ↑ ↑\n// gapStart gapEnd\n// 如果 gap 就在位置 2，直接插入！\n// 时间复杂度：O(1) // 如果 gap 就在目标位置</code></pre>\n<p><strong>关键优化点：</strong></p>\n<ol>\n<li><strong>在 Gap 位置操作是 O(1)</strong>：如果 gap 正好在要插入的位置，直接插入，无需移动任何元素！</li>\n<li><strong>移动 Gap 的成本可以分摊</strong>：虽然移动 gap 需要 O(距离)，但这个成本可以分摊到多次操作中</li>\n<li><strong>智能策略</strong>：Compose 使用批量操作和预测策略来最小化移动成本</li>\n<li><strong>连续区域</strong>：gap 是一个连续的空位区域，两个值就足够描述</li>\n</ol>\n<p><strong>为什么只有两个值就够了？</strong></p>\n<p><strong>答案：因为 gap 是一个连续的区域！</strong></p>\n<pre><code>// Gap 的结构\ngapStart = 10 // Gap 的起始位置\ngapEnd = 20 // Gap 的结束位置\n// Gap 的大小\ngapSize = gapEnd - gapStart // = 10\n// Gap 覆盖的区域\n// [有效数据][_][_][_][_][_][_][_][_][_][有效数据]\n// ↑ ↑\n// gapStart gapEnd\n// (索引 10) (索引 20)</code></pre>\n<p><strong>关键点：</strong></p>\n<ul>\n<li><strong>一个连续区域</strong>：gap 是一个连续的空位，不是多个分散的空位</li>\n<li><strong>两个值足够</strong>：只需要 <code>gapStart</code> 和 <code>gapEnd</code> 就能完全描述这个区域</li>\n<li><strong>简单高效</strong>：两个值的维护成本很低，但带来的性能提升很大</li>\n</ul>\n<h3><strong>5. GroupInfo 详解</strong></h3>\n<p><strong>GroupInfo</strong> 是一个整数，用<strong>二进制位（bit）</strong>存储多个布尔标志，就像开关一样。</p>\n<p><strong>类比理解：</strong></p>\n<p>就像房间里的多个开关：</p>\n<ul>\n<li>开关1：灯是否亮（是/否）</li>\n<li>开关2：空调是否开（是/否）</li>\n<li>开关3：窗户是否开（是/否）</li>\n<li>…</li>\n</ul>\n<p>GroupInfo 用一个整数存储多个这样的开关状态！</p>\n<h4><strong>GroupInfo 存储哪些信息？</strong></h4>\n<p>GroupInfo 的每个二进制位代表一个标志：</p>\n<pre><code>位位置（从右到左）：\n位 0: 是否为 Node（UI 节点）\n位 1: 是否有 ObjectKey\n位 2: 是否有 Aux 数据\n位 3: 是否被标记（Mark）\n位 4-31: 节点数量（Node Count）</code></pre>\n<p><strong>示例：</strong></p>\n<pre><code>// 假设 GroupInfo = 0b00000001\n// 二进制：00000000 00000000 00000000 00000001\n// ↑ ↑\n// 高位 低位（位0）\n// = 1（是 Node）</code></pre>\n<h4><strong>GroupInfo 有什么用？</strong></h4>\n<p><strong>作用 1：快速判断 Group 的类型</strong></p>\n<pre><code>// 检查是否是 Node 组\nfun isNodeGroup(groupInfo: Int): Boolean {\nreturn (groupInfo and 0b1) != 0 // 检查位 0\n}\n// 检查是否有 ObjectKey\nfun hasObjectKey(groupInfo: Int): Boolean {\nreturn (groupInfo and 0b10) != 0 // 检查位 1\n}\n// 检查是否有 Aux 数据\nfun hasAuxData(groupInfo: Int): Boolean {\nreturn (groupInfo and 0b100) != 0 // 检查位 2\n}</code></pre>\n<p><strong>作用 2：存储节点数量</strong></p>\n<pre><code>// 获取节点数量（位 4-31）\nfun getNodeCount(groupInfo: Int): Int {\nreturn groupInfo shr 4 // 右移 4 位，获取高位\n}\n// 设置节点数量\nfun setNodeCount(groupInfo: Int, count: Int): Int {\nval flags = groupInfo and 0b1111 // 保留低 4 位（标志位）\nreturn flags or (count shl 4) // 设置高位（节点数量）\n}</code></pre>\n<p><strong>作用 3：标记状态</strong></p>\n<pre><code>// 检查是否被标记\nfun isMarked(groupInfo: Int): Boolean {\nreturn (groupInfo and 0b1000) != 0 // 检查位 3\n}\n// 设置标记\nfun markGroup(groupInfo: Int): Int {\nreturn groupInfo or 0b1000 // 设置位 3 为 1\n}</code></pre>\n<h4><strong>使用场景</strong></h4>\n<p><strong>使用场景 1：判断是否需要创建 LayoutNode</strong></p>\n<pre><code>fun processGroup(groups: IntArray, startIndex: Int) {\nval groupInfo = groups[startIndex + 1] // 获取 GroupInfo\n// 检查是否是 Node 组\nif (isNodeGroup(groupInfo)) {\n// 是 Node 组，需要创建 LayoutNode\nval layoutNode = createLayoutNode()\n// 存储到 slots 数组\nval dataAnchor = groups[startIndex + 4]\nslots[dataAnchor] = layoutNode\n} else {\n// 不是 Node 组，只是容器（如 Column、Row）\n// 不需要创建 LayoutNode\n}\n}</code></pre>\n<hr />\n<h2><strong>SlotTable 与 LayoutNode 的关系</strong></h2>\n<h3><strong>概述</strong></h3>\n<p><code>SlotTable</code> 和 <code>LayoutNode</code> 是 Compose 架构中两个核心组件，它们分别属于不同的层次：</p>\n<ul>\n<li><strong>SlotTable</strong>：Compose Runtime 层的数据结构，存储组合树（Composition Tree）的完整状态</li>\n<li><strong>LayoutNode</strong>：Compose UI 层的节点，代表一个可布局和可绘制的 UI 元素</li>\n</ul>\n<p>它们通过 <strong>Composer</strong> 和 <strong>Applier</strong> 机制连接在一起。</p>\n<h3><strong>1. 核心关系</strong></h3>\n<h4><strong>1.1 存储关系</strong></h4>\n<p><strong>LayoutNode 存储在 SlotTable 的 </strong><strong><code>slots</code></strong><strong> 数组中</strong></p>\n<pre><code>// SlotTable.kt 注释说明（第 63-65 行）\n// Node - a value of a node group that can be set independently of the slots of the group.\n// This is, for example, where the LayoutNode is stored by the slot table when\n// emitting using the UIEmitter.</code></pre>\n<p><strong>关键点：</strong></p>\n<ul>\n<li>当 Group 的 <code>GroupInfo</code> 标记为 <code>isNode = true</code> 时，对应的 <code>LayoutNode</code> 存储在 <code>slots</code> 数组中</li>\n<li>存储位置由 Group 的 <code>DataAnchor</code> 指向</li>\n<li>通过 <code>groups.nodeIndex(index)</code> 可以获取 LayoutNode 在 slots 数组中的索引</li>\n</ul>\n<h4><strong>1.2 数据结构映射</strong></h4>\n<pre><code>SlotTable (Runtime 层)\n├── groups 数组\n│ └── Group (5个整数)\n│ ├── Key\n│ ├── GroupInfo (包含 isNode 标志)\n│ ├── ParentAnchor\n│ ├── Size\n│ └── DataAnchor → 指向 slots 数组\n│\n└── slots 数组\n└── [index] = LayoutNode (当 isNode = true 时)</code></pre>\n<h3><strong>2. 创建流程</strong></h3>\n<h4><strong>2.1 Composer 创建 LayoutNode</strong></h4>\n<p>当 Composable 函数调用 <code>Layout</code> 或 <code>ComposeNode</code> 时：</p>\n<pre><code>// Composer.kt 第 1670-1677 行\noverride fun &lt;T&gt; createNode(factory: () -&gt; T) {\nvalidateNodeExpected()\nruntimeCheck(inserting) { \"createNode() can only be called when inserting\" }\nval insertIndex = nodeIndexStack.peek()\nval groupAnchor = writer.anchor(writer.parent)\ngroupNodeCount++\ninsertFixups.createAndInsertNode(factory, insertIndex, groupAnchor)\n}</code></pre>\n<p><strong>流程：</strong></p>\n<ol>\n<li><code>createNode</code> 被调用，传入 <code>factory: () -&gt; LayoutNode</code></li>\n<li>创建一个新的 Group，标记 <code>isNode = true</code></li>\n<li>调用 <code>factory()</code> 创建 <code>LayoutNode</code> 实例</li>\n<li>将 <code>LayoutNode</code> 存储到 <code>slots</code> 数组中</li>\n<li>通过 <code>DataAnchor</code> 建立 Group 和 LayoutNode 的关联</li>\n</ol>\n<h4><strong>2.2 实际代码示例</strong></h4>\n<pre><code>// Layout.kt 中的 Column 实现\n@Composable\nfun Column(\nmodifier: Modifier = Modifier,\ncontent: @Composable ColumnScope.() -&gt; Unit\n) {\nReusableComposeNode&lt;ComposeUiNode, Applier&lt;Any&gt;&gt;(\nfactory = { LayoutNode() }, // ← 创建 LayoutNode\nupdate = { /* ... */ },\ncontent = content\n)\n}</code></pre>\n<p><strong>执行流程：</strong></p>\n<pre><code>1. Column() 被调用\n↓\n2. ReusableComposeNode 调用 Composer.createNode { LayoutNode() }\n↓\n3. Composer 创建 Group，设置 isNode = true\n↓\n4. 调用 factory() 创建 LayoutNode 实例\n↓\n5. 将 LayoutNode 存储到 slots[DataAnchor]\n↓\n6. Group 的 DataAnchor 指向 slots 数组中的 LayoutNode</code></pre>\n<h3><strong>3. 访问机制</strong></h3>\n<h4><strong>3.1 从 SlotTable 读取 LayoutNode</strong></h4>\n<pre><code>// SlotTable.kt 第 1229-1231 行\nprivate fun IntArray.node(index: Int) = if (isNode(index)) {\nslots[nodeIndex(index)] // ← 从 slots 数组获取 LayoutNode\n} else Composer.Empty</code></pre>\n<p><strong>关键方法：</strong></p>\n<ul>\n<li><code>groups.isNode(index)</code>：检查 Group 是否为 Node 组</li>\n<li><code>groups.nodeIndex(index)</code>：获取 LayoutNode 在 slots 数组中的索引</li>\n<li><code>slots[nodeIndex]</code>：获取实际的 LayoutNode 实例</li>\n</ul>\n<h4><strong>3.2 从 LayoutNode 反向查找 SlotTable</strong></h4>\n<p>LayoutNode 本身不直接存储对 SlotTable 的引用，但可以通过以下方式关联：</p>\n<ol>\n<li><strong>通过 Composition 上下文</strong>：LayoutNode 属于某个 Composition，而 Composition 持有 SlotTable</li>\n<li><strong>通过 Applier</strong>：Applier 维护 LayoutNode 树，同时知道对应的 SlotTable</li>\n</ol>\n<h3><strong>4. 生命周期关系</strong></h3>\n<h4><strong>4.1 创建阶段</strong></h4>\n<pre><code>Composition 初始化\n↓\nSlotTable 创建（空）\n↓\nComposer 执行 Composable 函数\n↓\n遇到 Layout/ComposeNode\n↓\n创建 Group (isNode = true)\n↓\n创建 LayoutNode 实例\n↓\n存储到 slots 数组\n↓\nApplier 将 LayoutNode 添加到树中</code></pre>\n<h4><strong>4.2 重组阶段</strong></h4>\n<pre><code>状态变化触发重组\n↓\nComposer 比较新旧 SlotTable\n↓\n发现 Group 需要更新\n↓\n从 slots 数组读取现有 LayoutNode\n↓\n调用 update 回调更新 LayoutNode\n↓\nLayoutNode 标记为需要重新测量/布局</code></pre>\n<h4><strong>4.3 删除阶段</strong></h4>\n<pre><code>Composable 被移除\n↓\nSlotTable 删除对应的 Group\n↓\n从 slots 数组移除 LayoutNode 引用\n↓\nApplier 从树中移除 LayoutNode\n↓\nLayoutNode 被回收</code></pre>\n<h3><strong>5. 数据同步机制</strong></h3>\n<h4><strong>5.1 状态同步</strong></h4>\n<p><strong>SlotTable 存储的状态 → LayoutNode 的属性</strong></p>\n<pre><code>// 示例：Modifier 更新\n@Composable\nfun MyComposable(modifier: Modifier) {\nLayout(content = {}) { measurables, constraints -&gt;\n// ...\n}\n}\n// 重组时：\n// 1. SlotTable 中存储的 modifier 值变化\n// 2. Composer 检测到变化\n// 3. 调用 update 回调\n// 4. LayoutNode.modifier 被更新</code></pre>\n<h4><strong>5.2 结构同步</strong></h4>\n<p><strong>SlotTable 的 Group 树 ↔ LayoutNode 树</strong></p>\n<pre><code>SlotTable Groups 树 LayoutNode 树\n┌─────────────────┐ ┌──────────────┐\n│ Group (Column) │ ←──→ │ LayoutNode │\n│ ├─ Group (T1)│ ←──→ │ ├─ LayoutNode│\n│ └─ Group (T2)│ ←──→ │ └─ LayoutNode│\n└─────────────────┘ └──────────────┘</code></pre>\n<p><strong>同步机制：</strong></p>\n<ul>\n<li>Applier 负责维护两棵树的一致性</li>\n<li>当 SlotTable 变化时，Applier 更新 LayoutNode 树</li>\n<li>通过 <code>Applier.insert</code>、<code>Applier.remove</code>、<code>Applier.move</code> 等方法</li>\n</ul>\n<h3><strong>6. 关键代码位置</strong></h3>\n<h4><strong>6.1 SlotTable 相关</strong></h4>\n<ul>\n<li><strong>定义</strong>：<code>compose/runtime/runtime/src/commonMain/kotlin/androidx/compose/runtime/SlotTable.kt</code></li>\n<li><strong>Node 存储</strong>：第 1229-1231 行（<code>node()</code> 方法）</li>\n<li><strong>Node 索引</strong>：<code>groups.nodeIndex(index)</code> 方法</li>\n</ul>\n<h4><strong>6.2 LayoutNode 相关</strong></h4>\n<ul>\n<li><strong>定义</strong>：<code>compose/ui/ui/src/commonMain/kotlin/androidx/compose/ui/node/LayoutNode.kt</code></li>\n<li><strong>实现 ComposeNodeLifecycleCallback</strong>：第 88 行</li>\n</ul>\n<h4><strong>6.3 连接点</strong></h4>\n<ul>\n<li><strong>Composer.createNode</strong>：<code>compose/runtime/runtime/src/commonMain/kotlin/androidx/compose/runtime/Composer.kt</code> 第 1670 行</li>\n<li><strong>Applier</strong>：负责将 SlotTable 的变化应用到 LayoutNode 树</li>\n</ul>\n<h3><strong>7. 总结</strong></h3>\n<h4><strong>7.1 核心关系</strong></h4>\n<ol>\n<li><strong>存储关系</strong>：LayoutNode 存储在 SlotTable 的 <code>slots</code> 数组中</li>\n<li><strong>创建关系</strong>：Composer 通过 <code>createNode</code> 创建 LayoutNode 并存储到 SlotTable</li>\n<li><strong>访问关系</strong>：通过 Group 的 <code>DataAnchor</code> 和 <code>nodeIndex</code> 访问 LayoutNode</li>\n<li><strong>同步关系</strong>：Applier 负责保持 SlotTable 和 LayoutNode 树的一致性</li>\n</ol>\n<h4><strong>7.2 设计优势</strong></h4>\n<ol>\n<li><strong>分离关注点</strong>：</li>\n</ol>\n<ul>\n<li>SlotTable 专注于状态管理和结构存储</li>\n<li>LayoutNode 专注于布局和绘制</li>\n</ul>\n<ol>\n<li><strong>性能优化</strong>：</li>\n</ol>\n<ul>\n<li>SlotTable 使用紧凑的数组结构</li>\n<li>LayoutNode 只在需要时才创建</li>\n</ul>\n<ol>\n<li><strong>增量更新</strong>：</li>\n</ol>\n<ul>\n<li>通过比较 SlotTable 找出变化</li>\n<li>只更新受影响的 LayoutNode</li>\n</ul>\n<h4><strong>7.3 类比理解</strong></h4>\n<p><strong>SlotTable 就像\"设计图纸\"</strong>：</p>\n<ul>\n<li>存储了 UI 的完整结构和状态</li>\n<li>描述了每个组件的类型、参数、状态值</li>\n</ul>\n<p><strong>LayoutNode 就像\"实际建筑\"</strong>：</p>\n<ul>\n<li>根据设计图纸建造的实际 UI 元素</li>\n<li>负责实际的布局、测量、绘制</li>\n</ul>\n<p><strong>Composer 就像\"建筑师\"</strong>：</p>\n<ul>\n<li>根据设计图纸（SlotTable）建造建筑（LayoutNode）</li>\n<li>当图纸变化时，更新或重建建筑</li>\n</ul>\n<hr />\n<h2><strong>SlotTable 的使用方式</strong></h2>\n<h3><strong>基本使用模式</strong></h3>\n<p>虽然开发者通常不直接使用 SlotTable，但了解其使用模式有助于理解 Compose 的工作原理：</p>\n<h3><strong>1. 读取模式（Reader）</strong></h3>\n<pre><code>slotTable.read { reader -&gt;\n// 遍历组合树\nreader.startGroup()\n// 读取当前组的数据\nval oldValue = reader.next() // 读取第一个 slot\nval lambda = reader.next() // 读取第二个 slot\n// 处理子组\nwhile (!reader.isGroupEnd) {\n// 递归处理子组...\n}\nreader.endGroup()\n}</code></pre>\n<p><strong>特点：</strong></p>\n<ul>\n<li>支持多个 Reader 同时读取</li>\n<li>不能在有 Writer 时读取</li>\n<li>使用期间不能写入</li>\n</ul>\n<h3><strong>2. 写入模式（Writer）</strong></h3>\n<pre><code>// 写入新的组合树状态\nslotTable.write { writer -&gt;\nwriter.startGroup(key = composableKey)\n// 写入/更新数据\nwriter.update(newValue) // 更新第一个 slot\nwriter.update(newLambda) // 更新第二个 slot\n// 处理子组\n// ...\nwriter.endGroup()\n}</code></pre>\n<p><strong>特点：</strong></p>\n<ul>\n<li>只能有一个 Writer 同时写入</li>\n<li>写入时不能有 Reader</li>\n<li>写入完成后，Gap 会被移动到末尾</li>\n</ul>\n<h3><strong>3. 完整的重组流程</strong></h3>\n<pre><code>// 1. 读取旧状态\nslotTable.read { reader -&gt;\n// 比较结构，识别变化\n}\n// 2. 写入新状态\nslotTable.write { writer -&gt;\n// 更新变化的部分\nif (hasChanges) {\nwriter.update(newValue)\n} else {\nwriter.skip() // 跳过未变化的部分\n}\n}</code></pre>\n<hr />\n<h2><strong>Composition 初始化流程</strong></h2>\n<h3><strong>整体流程</strong></h3>\n<p>当调用 <code>setContent { ... }</code> 时，Compose 会执行以下步骤：</p>\n<pre><code>1. 创建 Composition\n└─&gt; 创建 SlotTable（如果首次）\n└─&gt; 创建 Composer\n2. 开始 Composition\n└─&gt; startRoot() ← 这是我们要重点分析的\n3. 执行 Composable 函数\n└─&gt; 构建组合树\n└─&gt; 填充 SlotTable\n4. 结束 Composition\n└─&gt; endRoot()\n└─&gt; 应用变化到 UI</code></pre>\n<h3><strong>startRoot() 的位置</strong></h3>\n<p><code>startRoot()</code> 是 Composition 的<strong>入口方法</strong>，在每个 Composition 开始时都会被调用一次。</p>\n<hr />\n<h2><strong>startRoot() 方法详解</strong></h2>\n<h3><strong>完整代码</strong></h3>\n<pre><code>@OptIn(InternalComposeApi::class)\nprivate fun startRoot() {\nOhosTrace.traceSync(\"Composer startRoot\", {\n// 1. 打开 SlotTable Reader\nreader = slotTable.openReader()\n// 2. 开始根组\nstartGroup(rootKey)\n// 3. 父上下文管理\nparentContext.startComposing()\nparentProvider = parentContext.getCompositionLocalScope()\nprovidersInvalidStack.push(providersInvalid.asInt())\nprovidersInvalid = changed(parentProvider)\nproviderCache = null\n// 4. 调试信息收集\nif (!forceRecomposeScopes) {\nforceRecomposeScopes = parentContext.collectingParameterInformation\n}\n// 5. 源码信息收集\nif (!sourceInformationEnabled) {\nsourceInformationEnabled = parentContext.collectingSourceInformation\n}\n// 6. 检查表注册\nparentProvider.read(LocalInspectionTables)?.let {\nit.add(slotTable)\nparentContext.recordInspectionTable(it)\n}\n// 7. 开始父上下文组\nstartGroup(parentContext.compoundHashKey)\n})\n}</code></pre>\n<h3><strong>逐步解析</strong></h3>\n<h4><strong>步骤 1: 打开 SlotTable Reader</strong></h4>\n<pre><code>reader = slotTable.openReader()</code></pre>\n<p><strong>作用：</strong></p>\n<ul>\n<li>打开 SlotTable 的读取通道</li>\n<li>准备读取现有的组合树状态</li>\n<li>如果这是首次组合，SlotTable 可能是空的</li>\n</ul>\n<p><strong>要点：</strong></p>\n<ul>\n<li>Reader 用于读取之前保存的状态</li>\n<li>在重组时，可以通过 Reader 比较新旧结构</li>\n</ul>\n<h4><strong>步骤 2: 开始根组</strong></h4>\n<pre><code>startGroup(rootKey)</code></pre>\n<p><strong>作用：</strong></p>\n<ul>\n<li>在 SlotTable 中创建一个根组（Root Group）</li>\n<li><code>rootKey</code> 是一个特殊的键值，标识这是整个 Composition 的根</li>\n</ul>\n<p><strong>结构示意：</strong></p>\n<pre><code>SlotTable:\nGroup(rootKey) ← 根组开始\n└─&gt; [后续所有 composable 组都会是这个组的子组]</code></pre>\n<h4><strong>步骤 3: 父上下文管理</strong></h4>\n<pre><code>parentContext.startComposing()\nparentProvider = parentContext.getCompositionLocalScope()\nprovidersInvalidStack.push(providersInvalid.asInt())\nprovidersInvalid = changed(parentProvider)\nproviderCache = null</code></pre>\n<p><strong>详细解释：</strong></p>\n<ol>\n<li><strong><code>parentContext.startComposing()</code></strong></li>\n</ol>\n<ul>\n<li>通知父上下文开始组合</li>\n<li>用于嵌套 Composition 的场景</li>\n</ul>\n<ol>\n<li><strong><code>parentProvider = parentContext.getCompositionLocalScope()</code></strong></li>\n</ol>\n<ul>\n<li>获取父级的 <code>CompositionLocal</code> 作用域</li>\n<li>CompositionLocal 用于向下传递上下文值（类似 Context in Android）</li>\n<li>例如：<code>LocalContext</code>、<code>LocalConfiguration</code> 等</li>\n</ul>\n<ol>\n<li><strong><code>providersInvalidStack.push(...)</code></strong><strong> 和 </strong><strong><code>providersInvalid = changed(...)</code></strong></li>\n</ol>\n<ul>\n<li><strong>作用：</strong> 检查 CompositionLocal 是否变化</li>\n<li><strong>机制：</strong></li>\n<li>将旧的 <code>providersInvalid</code> 状态压栈保存</li>\n<li>检查新的 <code>parentProvider</code> 是否有变化</li>\n<li>如果有变化，<code>providersInvalid</code> 会被标记，触发相关 composable 重组</li>\n<li><strong>为什么需要栈？</strong> 支持嵌套的 CompositionLocal 作用域</li>\n</ul>\n<ol>\n<li><strong><code>providerCache = null</code></strong></li>\n</ol>\n<ul>\n<li>清空 CompositionLocal 的缓存</li>\n<li>确保使用最新的上下文值</li>\n</ul>\n<h4><strong>步骤 4: 调试信息收集</strong></h4>\n<pre><code>if (!forceRecomposeScopes) {\nforceRecomposeScopes = parentContext.collectingParameterInformation\n}</code></pre>\n<p><strong>作用：</strong></p>\n<ul>\n<li>如果父上下文正在收集参数信息（用于调试工具），启用强制重组范围</li>\n<li>用于 Android Studio 的 Compose 调试功能</li>\n<li>可以显示哪些 composable 的参数发生了变化</li>\n</ul>\n<p><strong>使用场景：</strong></p>\n<ul>\n<li>Layout Inspector</li>\n<li>Recomposition Count 调试</li>\n<li>Parameter Tracking</li>\n</ul>\n<h4><strong>步骤 5: 源码信息收集</strong></h4>\n<pre><code>if (!sourceInformationEnabled) {\nsourceInformationEnabled = parentContext.collectingSourceInformation\n}</code></pre>\n<p><strong>作用：</strong></p>\n<ul>\n<li>启用源码信息收集功能</li>\n<li>用于在调试时显示 composable 的来源位置（文件名、行号等）</li>\n<li>存储在 <code>GroupSourceInformation</code> 中</li>\n</ul>\n<p><strong>示例：</strong></p>\n<pre><code>// 调试工具可以显示：\n// MyComposable.kt:42 ← 这个 composable 定义在哪个文件的哪一行</code></pre>\n<h4><strong>步骤 6: 检查表注册</strong></h4>\n<pre><code>parentProvider.read(LocalInspectionTables)?.let {\nit.add(slotTable)\nparentContext.recordInspectionTable(it)\n}</code></pre>\n<p><strong>作用：</strong></p>\n<ul>\n<li>将当前 SlotTable 注册到检查表（Inspection Table）</li>\n<li>用于 Android Studio 的 <strong>Composition Inspector</strong></li>\n<li>允许开发工具实时查看组合树的结构</li>\n</ul>\n<p><strong>检查表的作用：</strong></p>\n<ul>\n<li>显示当前 Composition 的完整树结构</li>\n<li>显示每个 composable 的状态值</li>\n<li>显示重组次数和原因</li>\n</ul>\n<h4><strong>步骤 7: 开始父上下文组</strong></h4>\n<pre><code>startGroup(parentContext.compoundHashKey)</code></pre>\n<p><strong>作用：</strong></p>\n<ul>\n<li>开始一个用于管理父上下文的作用域组</li>\n<li><code>compoundHashKey</code> 是父上下文的唯一标识</li>\n<li>这个组用于隔离不同嵌套层级的 CompositionLocal 值</li>\n</ul>\n<p><strong>结构示意：</strong></p>\n<pre><code>SlotTable:\nGroup(rootKey) ← 步骤 2 创建的根组\nGroup(parentContextKey) ← 步骤 7 创建的父上下文组\n└─&gt; [实际的 UI composable 组]</code></pre>\n<p><strong>为什么需要这个组？</strong></p>\n<ul>\n<li>管理 CompositionLocal 的层级作用域</li>\n<li>确保每个层级有独立的上下文值</li>\n<li>支持嵌套的 <code>CompositionLocalProvider</code></li>\n</ul>\n<hr />\n<h2><strong>实际应用示例</strong></h2>\n<h3><strong>示例 1: 首次组合</strong></h3>\n<pre><code>// 用户代码\nsetContent {\nColumn {\nText(\"Hello\")\nButton(onClick = {}) {\nText(\"Click\")\n}\n}\n}</code></pre>\n<p><strong>执行流程：</strong></p>\n<ol>\n<li><strong>startRoot()</strong> 被调用</li>\n</ol>\n<ul>\n<li>创建根组和父上下文组</li>\n<li>初始化 CompositionLocal 作用域</li>\n</ul>\n<ol>\n<li><strong>Column { … }</strong> 被调用</li>\n</ol>\n<ul>\n<li>创建 Column 组（key = Column 的 hash）</li>\n<li>在 slots 中存储 Column 的参数（content lambda）</li>\n</ul>\n<ol>\n<li><strong>Text(\"Hello\")</strong> 被调用</li>\n</ol>\n<ul>\n<li>创建 Text 组（key = Text 的 hash）</li>\n<li>在 slots 中存储参数（\"Hello\"）</li>\n<li>创建 LayoutNode 用于渲染</li>\n</ul>\n<ol>\n<li><strong>Button { … }</strong> 被调用</li>\n</ol>\n<ul>\n<li>创建 Button 组</li>\n<li>存储 onClick lambda 和 content lambda</li>\n</ul>\n<ol>\n<li><strong>endRoot()</strong> 被调用</li>\n</ol>\n<ul>\n<li>关闭 Reader</li>\n<li>应用变化到 UI 层</li>\n</ul>\n<h3><strong>示例 2: 重组场景</strong></h3>\n<pre><code>var count by remember { mutableStateOf(0) }\nColumn {\nText(\"Count: $count\") // 当 count 变化时，这个 Text 需要重组\nButton(onClick = { count++ }) {\nText(\"Increment\")\n}\n}</code></pre>\n<p><strong>重组流程：</strong></p>\n<ol>\n<li><strong>startRoot()</strong> 被调用</li>\n</ol>\n<ul>\n<li>打开 Reader，读取现有的 SlotTable</li>\n</ul>\n<ol>\n<li><strong>Column { … }</strong> 被比较</li>\n</ol>\n<ul>\n<li>Reader 找到 Column 组</li>\n<li>比较 key 是否匹配 → 匹配，继续</li>\n</ul>\n<ol>\n<li><strong>Text(\"Count: $count\")</strong> 被比较</li>\n</ol>\n<ul>\n<li>Reader 找到 Text 组</li>\n<li>读取旧的 count 值（存储在 slot 中）</li>\n<li>比较新旧 count 值 → <strong>不匹配！</strong></li>\n<li>标记该组需要重组</li>\n</ul>\n<ol>\n<li><strong>重组执行</strong></li>\n</ol>\n<ul>\n<li>Writer 更新 Text 组的 slot</li>\n<li>新的 count 值被写入</li>\n</ul>\n<ol>\n<li><strong>Button { … }</strong> 被比较</li>\n</ol>\n<ul>\n<li>没有变化，跳过</li>\n</ul>\n<h3><strong>示例 3: CompositionLocal 使用</strong></h3>\n<pre><code>// 提供上下文值\nCompositionLocalProvider(LocalContentAlpha provides 0.5f) {\nColumn {\nText(\"Alpha: ${LocalContentAlpha.current}\") // 使用上下文值\n}\n}</code></pre>\n<p><strong>startRoot() 中的处理：</strong></p>\n<ol>\n<li><strong>获取父上下文</strong></li>\n</ol>\n<pre><code>parentProvider = parentContext.getCompositionLocalScope()</code></pre>\n<ul>\n<li>获取包含 <code>LocalContentAlpha = 0.5f</code> 的作用域</li>\n</ul>\n<ol>\n<li><strong>检查变化</strong></li>\n</ol>\n<pre><code>providersInvalid = changed(parentProvider)</code></pre>\n<ul>\n<li>如果 <code>LocalContentAlpha</code> 的值变化，标记需要重组</li>\n</ul>\n<ol>\n<li><strong>创建作用域组</strong></li>\n</ol>\n<pre><code>startGroup(parentContext.compoundHashKey)</code></pre>\n<ul>\n<li>创建一个组来管理这个 CompositionLocal 作用域</li>\n</ul>\n<h3><strong>示例 4: 重组优化</strong></h3>\n<pre><code>@Composable\nfun MyScreen() {\nvar count by remember { mutableStateOf(0) }\nColumn {\nText(\"Count: $count\") // ← 只有这个会重组\nButton(onClick = { count++ }) {\nText(\"Increment\")\n}\n}\n}</code></pre>\n<p><strong>执行流程：</strong></p>\n<ol>\n<li>状态变化：<code>count</code> 从 0 变为 1</li>\n<li>SlotTable 比较：发现 Text 的 Group 需要更新</li>\n<li>读取 LayoutNode：从 <code>slots[nodeIndex]</code> 获取 Text 的 LayoutNode</li>\n<li>更新内容：调用 <code>update</code> 回调更新 Text 的文本</li>\n<li>标记重绘：LayoutNode 标记为需要重绘</li>\n</ol>\n<h3><strong>示例 5: 节点复用</strong></h3>\n<pre><code>@Composable\nfun List(items: List&lt;Item&gt;) {\nitems.forEach { item -&gt;\nItemRow(item) // ← 相同的 key 会复用 LayoutNode\n}\n}</code></pre>\n<p><strong>执行流程：</strong></p>\n<ol>\n<li>第一次组合：为每个 item 创建 Group 和 LayoutNode</li>\n<li>列表变化：添加/删除 item</li>\n<li>SlotTable 比较：通过 key 匹配新旧 Group</li>\n<li>复用 LayoutNode：如果 key 匹配，复用现有的 LayoutNode</li>\n<li>更新内容：只更新变化的部分</li>\n</ol>\n<hr />\n<h2><strong>调试技巧</strong></h2>\n<h3><strong>1. 查看 SlotTable 内容</strong></h3>\n<pre><code>// 在调试器中\ncomposition.slotTable.groups // 查看 groups 数组\ncomposition.slotTable.slots // 查看 slots 数组（包含 LayoutNode）</code></pre>\n<h3><strong>2. 查看 LayoutNode 树</strong></h3>\n<pre><code>// 从 Composition 获取根 LayoutNode\nval rootNode = (composition as? ControlledComposition)?.root\nrootNode?.forEach { node -&gt;\nprintln(\"LayoutNode: ${node.javaClass.simpleName}\")\n}</code></pre>\n<h3><strong>3. 验证关联关系</strong></h3>\n<pre><code>// 验证 SlotTable 中的 LayoutNode 和实际的 LayoutNode 树是否一致\nval slotTableNodes = composition.slotTable.slots.filterIsInstance&lt;LayoutNode&gt;()\nval layoutTreeNodes = rootNode?.collectAllNodes() ?: emptyList()\n// 比较两个列表是否一致</code></pre>\n<hr />\n<h2><strong>常见问题</strong></h2>\n<h3><strong>Q1: 为什么 LayoutNode 不直接存储在 Group 中？</strong></h3>\n<p><strong>A:</strong> 性能考虑。使用数组存储可以：</p>\n<ul>\n<li>减少内存碎片</li>\n<li>提高缓存局部性</li>\n<li>支持批量操作</li>\n</ul>\n<h3><strong>Q2: SlotTable 和 LayoutNode 树是否总是同步？</strong></h3>\n<p><strong>A:</strong> 在正常流程中是的，但存在短暂的异步窗口：</p>\n<ul>\n<li>SlotTable 先更新（重组阶段）</li>\n<li>然后通过 Applier 应用到 LayoutNode 树（应用阶段）</li>\n</ul>\n<h3><strong>Q3: 如何知道一个 LayoutNode 对应哪个 Group？</strong></h3>\n<p><strong>A:</strong> 通过 Applier 维护的映射关系，或者遍历 SlotTable 查找 <code>slots[nodeIndex] == layoutNode</code> 的 Group。</p>\n<h3><strong>Q4: Gap 是否存在于 groups 数组中？</strong></h3>\n<p><strong>A:</strong> 是的！Gap 确实存在于 <code>groups</code> 数组中，但它是<strong>未使用的空间</strong>，不是有效的 Group 数据。</p>\n<p><strong>关键点：</strong></p>\n<ol>\n<li><strong>Gap 是数组中的空位</strong>：未使用的空间，不是有效的 Group 数据</li>\n<li><strong>Gap 的位置会动态移动</strong>：根据插入/删除操作的需要移动</li>\n<li><strong>Gap 中的值不重要</strong>：可能是 0、未初始化值或残留数据</li>\n<li><strong>通过位置范围跟踪</strong>：使用 <code>gapStart</code> 和 <code>gapEnd</code> 来标记 gap 的位置</li>\n<li><strong>两个数组都有 gap</strong>：<code>groups</code> 数组和 <code>slots</code> 数组都有各自的 gap</li>\n<li><strong>性能优化</strong>：在 gap 位置操作是 O(1)，移动成本可以分摊，实际性能更好</li>\n</ol>\n<hr />\n<h2><strong>总结</strong></h2>\n<h3><strong>SlotTable 的作用</strong></h3>\n<ol>\n<li><strong>状态存储</strong>：保存所有 composable 的状态值</li>\n<li><strong>结构管理</strong>：维护组合树的完整结构</li>\n<li><strong>差异检测</strong>：通过比较实现增量重组</li>\n<li><strong>性能优化</strong>：使用 Gap Buffer 优化更新性能</li>\n</ol>\n<h3><strong>startRoot() 的作用</strong></h3>\n<ol>\n<li><strong>初始化组合</strong>：创建根组和父上下文组</li>\n<li><strong>上下文管理</strong>：设置 CompositionLocal 作用域</li>\n<li><strong>调试支持</strong>：启用调试工具所需的信息收集</li>\n<li><strong>检查工具</strong>：注册 SlotTable 供开发工具使用</li>\n</ol>\n<h3><strong>SlotTable 与 LayoutNode 的关系</strong></h3>\n<ol>\n<li><strong>存储关系</strong>：LayoutNode 存储在 SlotTable 的 <code>slots</code> 数组中</li>\n<li><strong>创建关系</strong>：Composer 通过 <code>createNode</code> 创建 LayoutNode 并存储到 SlotTable</li>\n<li><strong>访问关系</strong>：通过 Group 的 <code>DataAnchor</code> 和 <code>nodeIndex</code> 访问 LayoutNode</li>\n<li><strong>同步关系</strong>：Applier 负责保持 SlotTable 和 LayoutNode 树的一致性</li>\n</ol>\n<h3><strong>关键要点</strong></h3>\n<ul>\n<li><strong>SlotTable 是 Compose 的核心</strong>：几乎所有 Compose 特性都依赖于它</li>\n<li><strong>增量重组的基础</strong>：通过 SlotTable 的比较实现高效的 UI 更新</li>\n<li><strong>状态管理的关键</strong>：所有状态都存储在 SlotTable 的 slots 中</li>\n<li><strong>开发工具的支撑</strong>：Composition Inspector 等工具依赖 SlotTable</li>\n<li><strong>设计图纸与建筑</strong>：SlotTable 是设计图纸，LayoutNode 是实际建筑，Composer 是建筑师</li>\n</ul>\n<p>理解 SlotTable、LayoutNode 和 startRoot() 的工作原理，有助于：</p>\n<ul>\n<li>更好地理解 Compose 的重组机制</li>\n<li>优化性能（避免不必要的重组）</li>\n<li>调试 Compose 相关问题</li>\n<li>深入理解 Compose 的设计哲学</li>\n</ul>\n<hr />\n<h2><strong>参考资料</strong></h2>\n<ol>\n<li>SlotTable.kt - Compose Runtime 核心数据结构</li>\n<li>LayoutNode.kt - Compose UI 布局节点</li>\n<li>Composer.kt - 组合执行器</li>\n<li>Applier.kt - 应用器，负责同步 SlotTable 和 LayoutNode 树</li>\n<li>Compose 官方文档：重组</li>\n</ol>\n<p><strong>目录</strong></p>\n<figure class=\"doc-figure\"><img src=\"../knowledge-map-assets/slottable-composition-8939c899-20aaff7a36.png\" alt=\"SlotTable 与 Composition 完整详解 图示\" /></figure>"
        }
      ],
      "estimated_minutes": 69
    },
    {
      "module_id": "module-10d487ca",
      "title": "指令录制与绘制机制",
      "source_path": "principle-analysis/指令录制与绘制机制.docx",
      "source_file_hash": "10d487ca7abcb7a0c07c49f0f5452901de336e49",
      "split_mode": "auto",
      "render_version": 11,
      "difficulty": 3,
      "summary": "OHRender 融合渲染原理讲解文档 本文档详细讲解 CMP（Compose Multiplatform）对接 OHRender 实现 OHOS 统一 渲染方案中的指令录制...",
      "sections": [
        {
          "section_id": "ac1751a22b",
          "title": "指令录制与绘制机制",
          "summary": "OHRender 融合渲染原理讲解文档 本文档详细讲解 CMP（Compose Multiplatform）对接 OHRender 实现 OHOS 统一 渲染方案中的指令录制...",
          "key_points": [
            "单次绘制操作的脏区更新（updateDrawBounds）",
            "最终脏区的生成（getFinishDrawBounds）"
          ],
          "estimated_minutes": 90,
          "content": "OHRender 融合渲染原理讲解文档\n\n本文档详细讲解 CMP（Compose Multiplatform）对接 OHRender 实现 OHOS 统一 渲染方案中的指令录制与绘制机制。\n\n第一部分：概述与背景\n\n1.1 什么是融合渲染\n\n融合渲染 是指将 Compose Multiplatform 的绘制命令转换为 OHOS（OpenHarmony OS）原生渲染指令的技术方案。其核心目标是：\n\n跨平台一致性：使用统一的 Compose UI 代码，在 OHOS 平台获得原生渲染性能\n\n高性能：利用 OHOS 的 RenderService 进行硬件加速渲染\n\n细粒度更新：支持按节点级别的脏区管理，避免全屏重绘\n\n1.2 技术架构总览\n\n┌─────────────────────────────────────────────────────────────────┐ │ Compose UI (Kotlin) │ │ 声明式 UI 定义 @Composable │ └────────────────────────────┬────────────────────────────────────┘ │ ▼ ┌─────────────────────────────────────────────────────────────────┐ │ RenderNodeLayer (Kotlin) │ │ 图层管理 + Picture 录制/缓存 │ └────────────────────────────┬────────────────────────────────────┘ │ JNI ▼ ┌─────────────────────────────────────────────────────────────────┐ │ SkPictureRecorder (C++) │ │ 创建 Canvas + 录制绘制命令 + 生成 Picture │ └────────────────────────────┬────────────────────────────────────┘ │ ▼ ┌─────────────────────────────────────────────────────────────────┐ │ SkOHPicture + OHRenderNode (C++) │ │ Picture/Node 模式决策 + 渲染节点树管理 │ └────────────────────────────┬────────────────────────────────────┘ │ ▼ ┌─────────────────────────────────────────────────────────────────┐ │ OHOS RenderService │ │ 硬件加速渲染 │ └─────────────────────────────────────────────────────────────────┘\n\n第二部分：核心概念\n\n本部分按照依赖关系由底向上的顺序介绍 6 个核心类。\n\n2.1 OH_Drawing_RecordCmd（底层）\n\n定位：OHOS 原生绘制命令的容器\n\n// OHOS 系统提供的绘制命令录制 API OH_Drawing_RecordCmdUtils* recorder; OH_Drawing_Canvas* canvas; OH_Drawing_RecordCmd* recordCmd; ​ // 开始录制 OH_Drawing_RecordCmdUtilsBeginRecording(recorder, width, height, &canvas); ​ // 在 canvas 上执行绘制操作... ​ // 结束录制，获取命令 OH_Drawing_RecordCmdUtilsFinishRecording(recorder, &recordCmd);\n\n特点：\n\n由 OHOS 系统管理生命周期\n\n可被多次回放执行\n\n支持嵌套回放（OH_Drawing_CanvasDrawRecordCmdNesting）\n\n2.2 OHRenderNode（渲染节点）\n\n定位：渲染节点，管理绘制命令和节点树结构\n\nclass OHRenderNode { // === 标识 === int fNodeId; // 节点唯一 ID // === 绘制区域 === SkRect fNowFrame; // 当前帧边界（用于布局） SkRect fRealFrame; // 实际绘制边界（脏区） bool fNoLimitSize; // 是否无尺寸限制 // === 绘制命令 === OH_Drawing_RecordCmd* fPictureCmd; // 录制的绘制命令 // === 节点树结构 === std::shared_ptr<OHRenderNode> fParent; // 父节点 std::list<std::shared_ptr<OHRenderNode>> fChildList; // 子节点列表 // === 变换与状态 === SkMatrix fFatherMatrix; // 相对父节点的变换矩阵 bool fDrawInPicture; // 模式标志：true=Picture模式, false=Node模式 bool fVisible; // 可见性 };\n\n核心方法：\n\n方法\n\n作用\n\npictureDraw()\n\nPicture 模式下执行绘制\n\nnodeDraw()\n\nNode 模式下执行绘制\n\nappendChild()\n\n添加子节点\n\nmakeClone()\n\n克隆节点（用于多实例场景）\n\n2.3 SkCanvas（绘制接口）\n\n定位：绘制命令的录制接口，是 Skia 绘制 API 与 OHOS OH_Drawing API 之间的核心桥接层\n\n核心职责：\n\n命令转换：将 Skia 绘制调用转换为 OH_Drawing 调用\n\n脏区跟踪：动态计算实际绘制边界，用于优化渲染\n\n状态管理：管理变换矩阵、裁剪区域、画笔状态等\n\n嵌套支持：支持 SubCanvas 机制处理嵌套 Layer\n\nclass SkCanvas { // === 底层画布 === OH_Drawing_Canvas*; // OHOS 原生画布（实际执行绘制） // === 关联节点 === OHRenderNode* fOHNode; // 当前关联的渲染节点 // === 变换状态 === SkMatrix fInitMatrix; // 初始变换矩阵 SkMatrix fTotalMatrix; // 累积变换矩阵 std::vector<SkMatrix> fMatrixStack; // 矩阵栈（save/restore） // === 裁剪状态 === SkRect fClipBounds; // 当前裁剪边界 std::vector<SkRect> fClipStack; // 裁剪栈 // === 脏区跟踪 === SkRect fRecordCull; // 录制时指定的边界 SkRect fDrawBounds; // 实际绘制边界（动态计算） bool fHasDrawBounds; // 是否有有效绘制边界 // === 子画布（嵌套录制） === SkCanvas* fSubCanvas; // 子画布（嵌套 Layer 使用） SkPictureRecorder* fSubRecorder; // 子录制器 std::vector<sk_sp<SkPicture>> fSubPics; // 已完成的子 Picture 列表 // === 状态标志 === bool fIsPlayingBack; // 是否正在回放子 Picture bool fForceDrawInPicture; // 是否强制 Picture 模式 int fSaveLayerDepth; // SaveLayer 嵌套深度 };\n\n核心方法：\n\n方法\n\n作用\n\nsave() / restore()\n\n保存/恢复画布状态（矩阵、裁剪）\n\ntranslate()\n\n平移变换\n\nrotate()\n\n旋转变换\n\nscale()\n\n缩放变换\n\nconcat()\n\n连接变换矩阵\n\nclipRect()\n\n矩形裁剪\n\nclipPath()\n\n路径裁剪\n\ndrawRect()\n\n绘制矩形\n\ndrawPath()\n\n绘制路径\n\ndrawImage()\n\n绘制图像\n\ndrawText()\n\n绘制文本\n\ndrawPicture()\n\n绘制 Picture（触发回放）\n\nsaveLayer()\n\n创建离屏图层\n\nbeginSubCanvas()\n\n创建子画布（嵌套录制）\n\nfinishSubCanvas()\n\n完成子画布录制\n\ngetFinishDrawBounds()\n\n获取最终脏区边界\n\ngetOHNode()\n\n获取关联的 OHRenderNode\n\n绘制命令转换示例：\n\n// 示例 1：绘制矩形 void SkCanvas::drawRect(const SkRect& rect, const SkPaint& paint) { // 1. 转换画笔 OH_Drawing_Brush* brush = paint.asBrush(); OH_Drawing_Pen* pen = paint.asPen(); // 2. 设置画笔到 OH_Drawing_Canvas if (brush) OH_Drawing_CanvasAttachBrush(fOHCanvas, brush); if (pen) OH_Drawing_CanvasAttachPen(fOHCanvas, pen); // 3. 转换矩形并绘制 OH_Drawing_Rect* ohRect = toOHRect(rect); OH_Drawing_CanvasDrawRect(fOHCanvas, ohRect); // 4. 更新脏区边界 updateDrawBounds(rect); // 5. 清理 OH_Drawing_RectDestroy(ohRect); if (brush) OH_Drawing_CanvasDetachBrush(fOHCanvas); if (pen) OH_Drawing_CanvasDetachPen(fOHCanvas); } ​ // 示例 2：绘制路径 void SkCanvas::drawPath(const SkPath& path, const SkPaint& paint) { OH_Drawing_Path* ohPath = path.toOHPath(); OH_Drawing_CanvasDrawPath(fOHCanvas, ohPath); // 使用路径边界更新脏区 updateDrawBounds(path.getBounds()); } ​ // 示例 3：绘制图像 void SkCanvas::drawImage(const sk_sp<SkImage>& image, SkScalar x, SkScalar y, const SkPaint* paint) { OH_Drawing_Image* ohImage = image->toOHImage(); OH_Drawing_CanvasDrawImage(fOHCanvas, ohImage, x, y, ...); // 计算图像绘制边界 SkRect bounds = SkRect::MakeXYWH(x, y, image->width(), image->height()); updateDrawBounds(bounds); }\n\n脏区跟踪机制：\n\n// 每次绘制操作都会更新脏区 void SkCanvas::updateDrawBounds(const SkRect& bounds) { // 将绘制区域通过当前变换矩阵映射 SkRect mappedBounds; fTotalMatrix.mapRect(&mappedBounds, bounds); // 与裁剪区域求交 if (!mappedBounds.intersect(fClipBounds)) { return; // 被完全裁剪，不影响脏区 } // 合并到总脏区 if (fHasDrawBounds) { fDrawBounds.join(mappedBounds); } else { fDrawBounds = mappedBounds; fHasDrawBounds = true; } } ​ // 获取最终脏区（录制结束时调用） std::optional<SkRect> SkCanvas::getFinishDrawBounds() { if (!fHasDrawBounds) { return std::nullopt; // 无绘制内容 } // 反向映射到录制坐标系 SkMatrix inverse; if (fInitMatrix.invert(&inverse)) { SkRect result; inverse.mapRect(&result, fDrawBounds); return result; } return fDrawBounds; }\n\n脏区跟踪的核心原理是动态记录所有绘制操作实际影响的有效区域，通过结合变换矩阵、裁剪区域和区域合并策略，最终生成需要更新或处理的区域集合。以下是基于代码的具体实现逻辑解析：\n\n1. 单次绘制操作的脏区更新（updateDrawBounds）\n\n每次绘制操作（如画线、填充图形等）触发此函数，核心步骤如下：\n\n变换映射：将绘制的原始边界 bounds 通过当前总变换矩阵 fTotalMatrix 映射到目标空间（例如画布可能经过平移、旋转、缩放等变换，需将绘制区域转换到实际生效的坐标系）。得到 mappedBounds。\n\n裁剪过滤：将映射后的区域 mappedBounds 与当前画布的裁剪区域 fClipBounds 求交。若完全被裁剪（无交集），则此次绘制不影响脏区，直接返回；否则保留交集部分（即实际可见的绘制区域）。\n\n合并脏区：将过滤后的有效区域合并到总脏区 fDrawBounds 中。若总脏区尚未初始化（fHasDrawBounds 为 false），则直接赋值；否则通过 join 操作合并两个区域（取并集）。\n\n2. 最终脏区的生成（getFinishDrawBounds）\n\n绘制操作全部完成后（如录制结束），调用此函数获取最终脏区：\n\n无绘制内容判断：若总脏区未初始化（fHasDrawBounds 为 false），返回 std::nullopt 表示无有效绘制。\n\n坐标系反向映射：由于脏区 fDrawBounds 是在经过初始矩阵 fInitMatrix 变换后的坐标系中记录的，需通过其逆矩阵 inverse 将脏区反向映射回原始录制坐标系（确保脏区与用户最初操作的坐标系一致）。若逆矩阵不存在（不可逆），则直接返回当前脏区。\n\n关键设计思想\n\n变换感知：脏区始终跟踪“实际生效”的绘制区域，而非原始绘制指令的边界。例如，一个被缩放的圆形，其脏区会是缩放后的椭圆区域。\n\n裁剪优化：仅保留被裁剪区域覆盖的部分，避免无效区域的冗余记录。\n\n区域合并：通过逐步合并每次绘制的有效区域，最终得到所有需要处理的区域的并集（总脏区）。\n\n坐标系一致性：最终脏区反向映射回原始坐标系，保证结果与用户视角一致，便于后续处理（如重绘、碰撞检测等）。\n\n总结\n\n脏区跟踪通过变换映射→裁剪过滤→区域合并的流程，动态维护所有绘制操作的实际有效区域，最终输出一个紧凑的、坐标对齐的区域集合，用于高效处理需要更新的内容（如界面重绘、离屏渲染等）。\n\n状态保存与恢复：\n\nvoid SkCanvas::save() { // 保存变换矩阵 fMatrixStack.push_back(fTotalMatrix); // 保存裁剪区域 fClipStack.push_back(fClipBounds); // 调用 OH_Drawing 保存 OH_Drawing_CanvasSave(fOHCanvas); } ​ void SkCanvas::restore() { // 恢复变换矩阵 if (!fMatrixStack.empty()) { fTotalMatrix = fMatrixStack.back(); fMatrixStack.pop_back(); } // 恢复裁剪区域 if (!fClipStack.empty()) { fClipBounds = fClipStack.back(); fClipStack.pop_back(); } // 调用 OH_Drawing 恢复 OH_Drawing_CanvasRestore(fOHCanvas); }\n\n2.4 SkPicture / SkOHPicture（绘制命令容器）\n\n定位：不可变的绘制命令容器，支持多次回放\n\nclass SkOHPicture final : public SkPicture { // === 边界信息 === SkRect fCull; // 裁剪边界（脏区） bool fNoLimitDraw; // 无限制绘制标志 // === 绘制命令 === OHDrawingRecordCmdSPtr fOHRecordCmd; // OH 绘制命令（智能指针） // === 节点管理 === std::shared_ptr<OHRenderNode> fOriginNode; // 原始节点 mutable std::shared_ptr<OHRenderNode> fNowCacheNode;// 当前使用的节点 // 克隆节点缓存 mutable std::list<std::shared_ptr<OHRenderNode>> fCacheCloneNodes; // 未使用节点池 mutable std::list<std::shared_ptr<OHRenderNode>> fUnusedCloneNodes; // === 状态标志 === mutable bool fPlaybackInNode; // 是否在 Node 模式回放 bool fCanPlaybackInPicture; // 是否可以在 Picture 模式回放 // === 子 Picture === std::vector<sk_sp<SkPicture>> fSubPics; // 嵌套的子 Picture };\n\n核心方法：\n\n// 回放方法 - 核心决策逻辑所在 void playback(SkCanvas* canvas, AbortCallback* callback) const override;\n\n2.5 SkPictureRecorder（命令录制器）\n\n定位：管理 Canvas 和 OHRenderNode 的创建，生成 SkOHPicture\n\nclass SkPictureRecorder { // === 录制器 === OH_Drawing_RecordCmdUtils* fOHRecorder; // OHOS 录制工具 // === 当前录制状态 === SkCanvas* fRecordCanvas; // 当前录制用的 Canvas bool fActivelyRecording; // 是否正在录制 SkRect fCullRect; // 录制边界 // === 节点管理 === std::shared_ptr<OHRenderNode> fNowOHNode; // 当前关联的节点 };\n\n核心 API：\n\n// 开始录制，返回可用于绘制的 Canvas SkCanvas* beginRecording(const SkRect& bounds); ​ // 结束录制，生成 Picture sk_sp<SkPicture> finishRecordingAsPicture();\n\n2.6 OwnedLayer / RenderNodeLayer（Compose 图层）\n\n定位：Compose UI 层的图层抽象，管理变换、裁剪、透明度等属性\n\ninternal class RenderNodeLayer( private var density: Density, private val invalidateParentLayer: () -> Unit, private val drawBlock: (Canvas) -> Unit, private val onDestroy: () -> Unit = {} ) : OwnedLayer { // === Picture 录制 === private val pictureRecorder = PictureRecorder() private var picture: Picture? = null // 缓存的 Picture // === 图层属性 === internal val matrix = Matrix() // 变换矩阵 private var transformOrigin: TransformOrigin private var translationX/Y/Z: Float private var rotationX/Y/Z: Float private var scaleX/Y: Float private var alpha: Float // 透明度 private var clip: Boolean // 裁剪开关 private var shadowElevation: Float // 阴影高度 // === 核心方法 === override fun drawLayer(canvas: Canvas) { ... } override fun invalidate() { ... } }\n\n2.7 核心概念关系图\n\n第三部分：对象关系\n\n3.1 数量关系概述\n\n源对象\n\n目标对象\n\n关系\n\n说明\n\nOwnedLayer\n\nSkPictureRecorder\n\n1:1\n\n每个 Layer 持有一个 Recorder\n\nOwnedLayer\n\nSkOHPicture\n\n1:0..1\n\n缓存的 Picture，invalidate 时清空\n\nSkOHPicture\n\nOHRenderNode (Origin)\n\n1:1\n\n创建时关联的原始节点\n\nSkOHPicture\n\nOHRenderNode (Cache)\n\n1:N\n\n多次 Node 模式回放时创建克隆\n\nOHRenderNode\n\nOHRenderNode (Child)\n\n1:N\n\n父子节点树结构\n\n3.2 类图\n\n图例说明：\n\n层级\n\n语言\n\n说明\n\nCMP 层\n\nKotlin\n\nCompose Multiplatform 框架层，定义图层接口和绘制逻辑\n\nSkiko 层\n\nKotlin\n\nSkia Kotlin 绑定层，提供跨平台 Canvas/Picture API\n\nOHRender 层\n\nC++\n\nOHOS 渲染适配层，实现 Skia API 到 OH_Drawing API 的转换\n\n跨层调用关系：\n\nRenderNodeLayer (Kotlin) │ │ 持有 Skiko 对象 ▼ PictureRecorder / Canvas / Picture (Skiko Kotlin) │ │ JNI 调用 ▼ SkPictureRecorder / SkCanvas / SkOHPicture (C++) │ │ API 转换 ▼ OH_Drawing_Canvas / OH_Drawing_RecordCmd (OHOS System)\n\n3.3 一个 OwnedLayer 是否一定对应一个 OHRenderNode？\n\n答案：是的，但不是简单的 1:1\n\n每个 OwnedLayer（即 RenderNodeLayer）在录制时会：\n\n必定关联一个原始节点（fOriginNode）\n\n但在回放时可能创建多个克隆节点\n\nOwnedLayer └── SkOHPicture ├── fOriginNode ─────────────────→ OHRenderNode #1 (原始) ├── fCacheCloneNodes[0] ─────────→ OHRenderNode #2 (克隆) └── fCacheCloneNodes[1] ─────────→ OHRenderNode #3 (克隆)\n\n3.4 是否会存在多个 OwnedLayer 绘制在同一个 OHRenderNode？\n\n答案：会的，在 Picture 模式下\n\n当子 Layer 选择 Picture 模式 回放时，其绘制命令会被聚合到父节点的 OH_Drawing_RecordCmd 中：\n\nLayer A (父) │ ├── 自身绘制命令 │ └── Layer B (子, Picture 模式) │ └── 绘制命令 ──聚合──→ Layer A 的 OHRenderNode\n\n示意图：\n\n第四部分：录制流程\n\n4.1 录制流程总览\n\n4.2 录制入口：RenderNodeLayer.drawLayer()\n\n// 文件: RenderNodeLayer.skiko.kt ​ override fun drawLayer(canvas: Canvas) { // 🎯 步骤 1：检查缓存 if (picture == null) { val bounds = size.toSize().toRect() // 🎯 步骤 2：开始录制 // 使用极大边界，实际脏区由 C++ 层计算 val pictureCanvas = pictureRecorder.beginRecording( org.jetbrains.skia.Rect.makeLTRB( l = -(1 shl 30).toFloat(), t = -(1 shl 30).toFloat(), r = ((1 shl 30)-1).toFloat(), b = ((1 shl 30)-1).toFloat() ) ) // 🎯 步骤 3：执行绘制 performDrawLayer(pictureCanvas.asComposeCanvas(), bounds) // 🎯 步骤 4：完成录制 picture = pictureRecorder.finishRecordingAsPicture() } // 🎯 步骤 5：应用变换并绘制 Picture canvas.save() canvas.concat(matrix) canvas.translate(position.x.toFloat(), position.y.toFloat()) canvas.nativeCanvas.drawPicture(picture!!, null, null) canvas.restore() }\n\n4.3 Canvas 创建：beginRecording()\n\n// 文件: SkPictureRecorder.cpp ​ SkCanvas* SkPictureRecorder::beginRecording(const SkRect& userCullRect, sk_sp<SkBBoxHierarchy> bbh) { const SkRect cullRect = userCullRect.isEmpty() ? SkRect::MakeEmpty() : userCullRect; // 防止重复录制 if (fRecordCanvas) { return nullptr; } // 🎯 步骤 1：开始 OH_Drawing 录制 OH_Drawing_Canvas *ohCanvas = nullptr; OH_Drawing_RecordCmdUtilsBeginRecording(fOHRecorder, ullRect.width(), cullRect.height(), &ohCanvas); if (!ohCanvas) { return nullptr; } ​ // 🎯 步骤 2：创建或复用 OHRenderNode if (fNowOHNode == nullptr || fNowOHNode->getPicture() != nullptr) { fNowOHNode = OHRenderNode::CreateNormalNode(); } // 🎯 步骤 3：创建 SkCanvas（包装 OH_Drawing_Canvas） fRecordCanvas = new SkCanvas(ohCanvas, fNowOHNode.get()); fRecordCanvas->setRecordCull(cullRect); // ... 更多初始化 ... fActivelyRecording = true; return fRecordCanvas; }\n\n4.4 命令转换示例\n\n// 文件: SkCanvas.cpp ​ void SkCanvas::drawRect(const SkRect& rect, const SkPaint& paint) { // 获取 OH_Drawing 画笔 OH_Drawing_Brush* brush = paint.asBrush(); OH_Drawing_Pen* pen = paint.asPen(); // 设置画笔 if (brush) OH_Drawing_CanvasAttachBrush(fOHCanvas, brush); if (pen) OH_Drawing_CanvasAttachPen(fOHCanvas, pen); // 转换为 OH_Drawing 命令 OH_Drawing_Rect* ohRect = OH_Drawing_RectCreate(); OH_Drawing_RectSetLeft(ohRect, rect.fLeft); OH_Drawing_RectSetTop(ohRect, rect.fTop); OH_Drawing_RectSetRight(ohRect, rect.fRight); OH_Drawing_RectSetBottom(ohRect, rect.fBottom); // 执行绘制 OH_Drawing_CanvasDrawRect(fOHCanvas, ohRect); // 🎯 更新脏区边界 updateDrawBounds(rect); // 清理 OH_Drawing_RectDestroy(ohRect); if (brush) OH_Drawing_CanvasDetachBrush(fOHCanvas); if (pen) OH_Drawing_CanvasDetachPen(fOHCanvas); }\n\n4.5 脏区计算：getFinishDrawBounds()\n\n// 文件: SkCanvas.cpp std::optional<SkRect> SkCanvas::getFinishDrawBounds() { if (!fHasDrawBounds) { return std::nullopt; // 无绘制内容 } // 应用录制时的变换矩阵，将脏区映射到正确坐标系 SkMatrix inverse; if (fInitMatrix.invert(&inverse)) { SkRect mappedBounds; inverse.mapRect(&mappedBounds, fDrawBounds); return mappedBounds; } return fDrawBounds; }\n\n4.6 Picture 生成：finishRecordingAsPicture()\n\n// 文件: SkPictureRecorder.cpp sk_sp<SkPicture> SkPictureRecorder::finishRecordingAsPicture() { fActivelyRecording = false; if (!fRecordCanvas) { return nullptr; } // 🎯 步骤 1：处理子 Canvas（嵌套录制场景） if (fRecordCanvas->fSubCanvas) { fRecordCanvas->finishSubCanvas(); } if (fNowOHNode) { fNowOHNode->finishChildAdd(); } // 🎯 步骤 2：获取脏区边界 OH_Drawing_RecordCmd* recordCmd = nullptr; auto paintArea = fRecordCanvas->getFinishDrawBounds(); bool noLimitDraw = false; if (paintArea.has_value()) { // 有明确绘制边界 if (fNowOHNode) { fNowOHNode->setRealFrame(paintArea.value(), false); } fCullRect = paintArea.value(); } else { // 无限制绘制（可能是无绘制内容或全屏绘制） auto noLimitRect = SkRect::MakeWH(NODE_SIZE_ALIGNMENT, NODE_SIZE_ALIGNMENT); if (fNowOHNode) { fNowOHNode->setRealFrame(noLimitRect, true); } noLimitDraw = true; } // 🎯 步骤 3：完成 OH_Drawing 录制 OH_Drawing_RecordCmdUtilsFinishRecording(fOHRecorder, &recordCmd); // 🎯 步骤 4：收集子 Picture auto subPics = fRecordCanvas->takeSubPics(); // 🎯 步骤 5：计算内容哈希（用于缓存复用） uint64_t pictureHash = calculateHash(); // 🎯 步骤 6：创建 SkOHPicture return sk_make_sp<SkOHPicture>( fCullRect, // 脏区边界 noLimitDraw, // 无限制绘制标志 recordCmd, // OH 绘制命令 fNowOHNode, // 关联节点 std::move(subPics), // 子 Picture 列表 cost, // 绘制成本 fDisableRecycleNode, // 禁用节点回收 pictureHash // 内容哈希 ); }\n\n第五部分：回放流程与模式决策\n\n5.1 两种模式对比\n\n特性\n\nPicture 模式\n\nNode 模式\n\n渲染方式\n\n直接在 Canvas 上执行命令\n\n独立 RenderNode 挂载\n\n脏区管理\n\n父节点统一管理\n\n独立脏区\n\n变换支持\n\n继承父节点变换\n\n独立变换矩阵\n\n内存占用\n\n较低\n\n较高（节点对象开销）\n\n适用场景\n\n静态/简单内容\n\n动态/复杂/频繁变化\n\n是否可逆\n\n可回退到 Node\n\n不可逆，一旦分裂无法聚合\n\n5.2 模式决策流程图\n\n5.3 回放核心代码：playback()\n\n// 文件: SkPictureRecorder.cpp (SkOHPicture 类) void playback(SkCanvas* canvas, AbortCallback* callback) const override { // 获取父节点 auto canvas_node = canvas->getOHNode(); // === 模式决策 === bool should_paint_in_picture = false; // 条件 1：无父节点或无原始节点 if (!canvas_node || !fOriginNode) { should_paint_in_picture = true; } // 条件 2：强制 Picture 模式 else if (canvas->isForceDrawInPicture()) { should_paint_in_picture = true; } // 条件 3：在 SaveLayer 中且支持嵌套命令 else if (canvas->isInSaveLayer() && OHDrawingAPI::support_OH_Drawing_CanvasDrawRecordCmdNesting) { should_paint_in_picture = true; } // 条件 4：无限制绘制且无子节点 else if (fNoLimitDraw && !fOriginNode->hasChildren()) { should_paint_in_picture = true; } // 条件 5：之前在 Picture 模式，检查是否需要转为 Node 模式 else if (!fPlaybackInNode && fCanPlaybackInPicture) { // 计算绘制区域与父节点的相交情况 SkRect drawArea = calculateDrawArea(canvas); SkRect parentArea = canvas_node->getPaintArea(); // 如果不相交，可以继续使用 Picture 模式 if (!drawArea.intersects(parentArea)) { should_paint_in_picture = true; } } // === 执行回放 === if (should_paint_in_picture) { // 🟢 Picture 模式：直接执行命令 fNowCacheNode->pictureDraw(canvas->getOHCanvas(), true); fPlaybackInNode = false; } else { // 🟠 Node 模式：挂载独立节点 if (!fNowCacheNode) { fNowCacheNode = generateNewNode(); } // 设置父子关系 fNowCacheNode->setParent(canvas_node); fNowCacheNode->updateFatherMatrix(canvas->getTotalMatrix()); fNowCacheNode->setPaintArea(calculatePaintArea(canvas)); // 挂载到父节点 canvas_node->appendChild(fNowCacheNode); fPlaybackInNode = true; fNowCacheNode->setDrawInPicture(false); // 标记为 Node 模式 } }\n\n5.4 分帧分裂优化机制\n\n5.4.1 什么是分帧分裂？\n\n在 OHRender 中，当一个 Picture 从 Picture 模式切换到 Node 模式时，这个过程被称为\"节点分裂\"。为了避免一帧内创建大量节点导致的性能尖峰，OHRender 采用了分帧分裂策略：\n\n核心思想：每帧尽可能只分裂一个节点，将节点创建的开销分散到多帧中，实现渐进式的节点树构建。\n\n问题场景：\n\n// 复杂嵌套结构 Box(Modifier.graphicsLayer { /* Layer A */ }) { Column { // 100 个子元素，每个都有 graphicsLayer repeat(100) { i -> Box(Modifier.graphicsLayer { /* Layer B-$i */ }) { Text(\"Item $i\") } } } }\n\n问题：如果在一帧内将所有 100 个 Picture 都分裂成 Node，会导致：\n\nCPU 峰值：大量节点对象创建和内存分配\n\n帧时间超标：可能导致掉帧\n\n内存压力：瞬间分配大量节点对象\n\n解决方案：使用 needDelayChildAppend 标志，控制节点分裂的速度。\n\n5.4.2 分帧分裂的工作原理\n\n核心数据结构（OHRenderNode）：\n\nclass OHRenderNode { // === 子节点管理 === std::list<std::shared_ptr<OHRenderNode>> fChildList; // 持久化存储 std::list<std::shared_ptr<OHRenderNode>> fChildOrderList;// 本次录制的绘制顺序 std::list<std::shared_ptr<OHRenderNode>> fChildAppend; // 本次新添加的子节点 // === 分帧分裂控制标志 === bool fNeedDelayChildAppend = true; // 本帧是否有新子节点插入 };\n\n生命周期流程：\n\n5.4.3 关键代码实现\n\n步骤 1：录制开始，重置标志\n\n// 文件: OHRenderNode.cpp, L601-613 ​ void OHRenderNode::restartChildAdd() { // 🎯 重置分帧分裂标志 fNeedDelayChildAppend = false; // 清空本次录制的临时列表 fChildOrderList.clear(); fChildAppend.clear(); }\n\n步骤 2：添加子节点，设置标志\n\n// 文件: OHRenderNode.cpp, L672-720 ​ void OHRenderNode::appendChild(std::shared_ptr<OHRenderNode> child) { // ... 前置检查 ... // 🎯 记录到本次绘制顺序列表 fChildOrderList.push_back(child); // 🎯 检查是否是新插入的子节点 bool isNewChild = (std::find(fChildList.begin(), fChildList.end(), child) == fChildList.end()); if (isNewChild) { // 🎯 记录到新增列表 fChildAppend.push_back(child); // 🔥 设置标志：本帧有新子节点插入！ fNeedDelayChildAppend = true; } }\n\n步骤 3：录制结束，重排序\n\n// 文件: OHRenderNode.cpp, L615-669 ​ void OHRenderNode::finishChildAdd() { if (fChildOrderList.empty()) { return; } // 🎯 将新增节点合并到持久化列表 for (auto& newChild : fChildAppend) { fChildList.push_back(newChild); } // 🎯 根据本次绘制顺序重排子节点 // （省略复杂的重排序逻辑...） }\n\n步骤 4：回放时检查标志，控制分裂\n\n// 文件: SkPictureRecorder.cpp, L230-242 (SkOHPicture::playback) ​ const auto refinePictureModeByHeuristics = [&]() { if (should_paint_in_picture) { return; // 已经决定用 Picture 模式 } if (!canvas_node || !fOriginNode || !fNowCacheNode) { return; } if (!fCanPlaybackInPicture || fPlaybackInNode || !OHDrawingAPI::support_OH_Drawing_CanvasDrawRecordCmdNesting) { return; } ​ auto father_paint_area = canvas_node->getPaintChildArea(); SkRect temp; const bool node_can_draw_in_father = (paint_area.has_value() && father_paint_area.has_value() && !(temp.intersect(father_paint_area.value(), paint_area.value()) && temp.width() > 0.1f && temp.height() > 0.1f)); ​ const bool matrix_changed = fNowCacheNode->updateFatherMatrix(father_matrix); const bool record_delta_changed = (fOriginNode->updateDeltaChangedCnt(canvas_node->getRecordCnt()) >= 3); const bool prefer_playback_in_node = (matrix_changed || record_delta_changed || canvas_node->getAllNodeChildrenNum() > 0); ​ // 分帧分裂控制核心逻辑： // 当父节点本帧刚添加了新子节点时，我们正处于分帧分裂的过程中； // 子节点顺序仍在确定中，所以仅当新子节点不与其他绘制子节点重叠时， // 才回退到 Picture 模式（避免创建又一个节点）。 if (!prefer_playback_in_node || (node_can_draw_in_father && canvas_node->needDelayChildAppend())) { should_paint_in_picture = true; } };\n\n5.4.4 分帧分裂的执行流程图\n\n5.4.5 分帧分裂的效果对比\n\n场景：父节点下有 10 个子 Picture，首次渲染时需要决策是否分裂。\n\n无分帧分裂限制（假设所有条件都满足）：\n\n帧 1: Picture 1 → Node 1 (分裂) Picture 2 → Node 2 (分裂) Picture 3 → Node 3 (分裂) ... Picture 10 → Node 10 (分裂) 结果: 一帧内创建 10 个节点，CPU 峰值！\n\n有分帧分裂控制：\n\n帧 1: restartChildAdd() → fNeedDelayChildAppend = false Picture 1 → Node 1 (分裂) ✓ └─ fNeedDelayChildAppend = true Picture 2 → Picture 模式 (因为 needDelayChildAppend = true) Picture 3 → Picture 模式 (因为 needDelayChildAppend = true) ... Picture 10 → Picture 模式 帧 2: restartChildAdd() → fNeedDelayChildAppend = false Picture 1 → 已分裂，直接挂载 Picture 2 → Node 2 (分裂) ✓ └─ fNeedDelayChildAppend = true Picture 3 → Picture 模式 (因为 needDelayChildAppend = true) ... 帧 3: Picture 3 → Node 3 (分裂) ✓ ... 结果: 每帧只分裂 1 个节点，开销平滑！\n\n性能对比：\n\n指标\n\n无分帧分裂限制\n\n有分帧分裂控制\n\n首帧 CPU 峰值\n\n极高（创建 N 个节点）\n\n低（创建 1 个节点）\n\n首帧时间\n\n可能掉帧（>16.6ms）\n\n正常（<16.6ms）\n\n完全分裂时间\n\n1 帧\n\nN 帧\n\n用户体验\n\n卡顿一下后流畅\n\n始终流畅\n\n内存分配曲线\n\n尖峰\n\n平滑上升\n\n5.4.6 特殊情况：不重叠子节点的快速通道\n\n即使 needDelayChildAppend = true，如果新子节点与父节点的其他绘制子节点不重叠，也可以立即分裂：\n\n// 核心判断逻辑 const bool node_can_draw_in_father = (paint_area.has_value() && father_paint_area.has_value() && !(temp.intersect(father_paint_area.value(), paint_area.value()) && temp.width() > 0.1f && temp.height() > 0.1f)); ​ // 如果不重叠，即使 needDelayChildAppend = true，也可以分裂 if (!prefer_playback_in_node || (node_can_draw_in_father && canvas_node->needDelayChildAppend())) { should_paint_in_picture = true; } else { // Node 模式分裂 }\n\n5.4.7 命名讨论与改进建议\n\n当前命名：fNeedDelayChildAppend\n\n问题：\n\n\"Delay\" 含义不明确，看起来像是延迟添加子节点\n\n没有体现\"分帧分裂\"的核心意图\n\n建议命名：fHasNewChildThisFrame 或 fChildOrderUnstable\n\n原因：\n\n更直接地表达\"本帧有新子节点\"的语义\n\n强调子节点顺序尚未稳定，需要延迟其他节点的分裂\n\n如果采用新命名，代码会更易读：\n\n// 当前代码（语义模糊） if (!prefer_playback_in_node || (node_can_draw_in_father && canvas_node->needDelayChildAppend())) { should_paint_in_picture = true; } ​ // 改进后（语义清晰） if (!prefer_playback_in_node || (node_can_draw_in_father && canvas_node->hasNewChildThisFrame())) { should_paint_in_picture = true; }\n\n5.4.8 总结\n\n分帧分裂机制是 OHRender 实现高性能渲染的关键优化：\n\n问题：一帧内分裂大量节点导致性能尖峰\n\n方案：使用 needDelayChildAppend 标志，每帧尽量只分裂一个节点\n\n实现：\n\n录制开始时重置标志（restartChildAdd）\n\n添加子节点时设置标志（appendChild）\n\n回放时检查标志，控制分裂速度（playback）\n\n录制结束时合并新增节点（finishChildAdd）\n\n效果：将节点创建开销分散到多帧，实现流畅的渲染体验\n\n特殊情况：不重叠的子节点可以快速通道，立即分裂\n\n5.5 为什么节点分裂后无法聚合？\n\n核心原因：一旦节点进入 Node 模式（fDrawInPicture = false），后续回放时会优先保持 Node 模式。\n\n代码证据：\n\n// 文件: OHRenderNode.h // 状态标志：初始为 true（尝试 Picture 模式） bool fDrawInPicture = true; // 判断是否在 Node 模式 bool isInNode() { return !fDrawInPicture; }\n\n// 文件: SkPictureRecorder.cpp (SkOHPicture 构造函数) SkOHPicture(...) { // 构造时记录节点的初始模式状态 fPlaybackInNode = node->isInNode(); // 如果节点已经在 Node 模式，则不允许回退到 Picture 模式 fCanPlaybackInPicture = !fPlaybackInNode; }\n\n不可逆的原因：\n\n状态锁定：一旦 fDrawInPicture = false，fCanPlaybackInPicture 也会被设为 false\n\n子节点依赖：Node 模式下可能已创建子节点，回退会破坏节点树结构\n\n设计意图：避免频繁的模式切换带来的性能抖动\n\n时间轴: T1: Picture 模式 (fDrawInPicture = true) │ ▼ 触发条件满足，切换到 Node 模式 T2: Node 模式 (fDrawInPicture = false) │ ╳ 无法回退！fCanPlaybackInPicture = false T3: Node 模式 (fDrawInPicture = false) │ ▼ T4: Node 模式 (永久保持)\n\n5.6 pictureDraw vs nodeDraw\n\n// Picture 模式：直接执行绘制命令 uint64_t OHRenderNode::pictureDraw(OH_Drawing_Canvas *canvas, bool needCache) { if (fPictureCmd) { // 使用缓存的命令树（如果有） if (fPictureTreeCmdCache) { OHDrawingAPI::OH_Drawing_CanvasDrawRecordCmdNesting( canvas, fPictureTreeCmdCache.get()); return fPictureTreeHash; } // 执行自身命令 OHDrawingAPI::OH_Drawing_CanvasDrawRecordCmdNesting(canvas, fPictureCmd.get()); // 递归处理子节点 for (auto& child : fChildList) { if (child->fVisible) { OH_Drawing_CanvasSave(canvas); OH_Drawing_CanvasConcatMatrix(canvas, child->fFatherMatrix); child->pictureDraw(canvas, needCache); OH_Drawing_CanvasRestore(canvas); } } } return 0; }\n\n// Node 模式：通过 NodeImpl 执行绘制 void OHRenderNode::nodeDraw(OH_Drawing_Canvas *oh_canvas) { if (fNodeImpl) { fNodeImpl->nodeDraw(oh_canvas, this); } }\n\n第六部分：嵌套录制机制\n\n6.1 嵌套场景说明\n\n当 Compose UI 中存在嵌套的 graphicsLayer 时，会产生嵌套录制：\n\n// Compose UI 嵌套结构示例 Box(modifier = Modifier.graphicsLayer { /* Layer A */ }) { Text(\"Header\") Box(modifier = Modifier.graphicsLayer { /* Layer B */ }) { Image(...) Box(modifier = Modifier.graphicsLayer { /* Layer C */ }) { Text(\"Content\") } } Text(\"Footer\") }\n\n6.2 SubCanvas 机制\n\nOHRender 使用 SubCanvas（子画布） 机制处理嵌套录制：\n\n6.3 关键代码：beginSubCanvas 和 finishSubCanvas\n\n// 文件: SkCanvas.cpp // 创建子画布 void SkCanvas::beginSubCanvas(const SkRect& bounds) { // 保存当前状态 save(); // 创建子录制器 fSubRecorder = new SkPictureRecorder(); // 开始子录制 fSubCanvas = fSubRecorder->beginRecording(bounds); // 传递当前变换矩阵到子画布 fSubCanvas->concat(getTotalMatrix()); } // 完成子画布录制 void SkCanvas::finishSubCanvas() { // 1. 完成子录制，生成 Picture sk_sp<SkPicture> subPic = fSubRecorder->finishRecordingAsPicture(); // 2. 保存到子 Picture 列表 fSubPics.push_back(subPic); // 清理子画布 fSubCanvas = nullptr; fSubRecorder = nullptr; // 🔥 3. 立即回放子 Picture！ fIsPlayingBack = true; markSubPicPlayback(true); this->drawPicture(subPic); // ← 触发 playback() markSubPicPlayback(false); fIsPlayingBack = false; // 4. 恢复状态 restore(); }\n\n6.4 嵌套录制的时序\n\n关键点：子 Layer 的 Picture 在父 Layer 录制完成之前就已经回放完成。\n\n时间轴: Layer A 录制 ┌─────────────────────────────────────────┐ │ │ T1 ──────▶│ beginRecording() │ │ draw(\"Header\") │ │ │ T2 ──────▶│ ┌─── Layer B 录制 ───────────────────┐ │ │ │ beginRecording() │ │ │ │ draw(Image) │ │ │ │ finishRecording() → Picture B │ │ T3 ──────▶│ │ │ │ │ │ playback(Picture B) ← 立即回放！ │ │ │ └────────────────────────────────────┘ │ │ │ T4 ──────▶│ draw(\"Footer\") │ │ finishRecording() → Picture A │ └─────────────────────────────────────────┘\n\n6.5 数据结构转化\n\n嵌套录制过程中，数据结构的转化关系：\n\n6.6 嵌套场景的模式决策\n\n在嵌套场景中，模式决策会逐层独立进行：\n\n第七部分：节点克隆与复用\n\n7.1 为什么需要节点克隆？\n\n在以下场景中，一个 Picture 可能需要多个 OHRenderNode：\n\n过渡动画（Crossfade）：新旧内容同时显示\n\nLazyList 复用：同一模板渲染多个 item\n\n并发回放：多个线程同时回放同一 Picture\n\n7.2 节点管理结构\n\nclass SkOHPicture { // 原始节点（创建时关联） std::shared_ptr<OHRenderNode> fOriginNode; // 当前使用的节点（回放时动态获取） mutable std::shared_ptr<OHRenderNode> fNowCacheNode; // 所有克隆节点的缓存列表 mutable std::list<std::shared_ptr<OHRenderNode>> fCacheCloneNodes; // 未使用的克隆节点列表（复用池） mutable std::list<std::shared_ptr<OHRenderNode>> fUnusedCloneNodes; };\n\n7.3 节点获取逻辑：generateNewNode()\n\n// 文件: SkPictureRecorder.cpp ​ std::shared_ptr<OHRenderNode> SkOHPicture::generateNewNode() const { // 🎯 优先级 1：从复用池获取 if (!fUnusedCloneNodes.empty()) { auto node = fUnusedCloneNodes.front(); fUnusedCloneNodes.pop_front(); return node; } // 🎯 优先级 2：使用原始节点（如果未被使用） if (fOriginNode && !fOriginNode->isInUse()) { fCacheCloneNodes.push_back(fOriginNode); return fOriginNode; } // 🎯 优先级 3：克隆新节点 auto cloneNode = fOriginNode->makeClone(); fCacheCloneNodes.push_back(cloneNode); return cloneNode; }\n\n7.4 节点克隆实现：makeClone()\n\n// 文件: OHRenderNode.cpp ​ std::shared_ptr<OHRenderNode> OHRenderNode::makeClone() { auto clone = std::make_shared<OHRenderNode>(); // 复制关键属性 clone->fRealFrame = this->fRealFrame; clone->fNoLimitSize = this->fNoLimitSize; // 共享绘制命令（只读，不需要复制） clone->fPictureCmd = this->fPictureCmd; // 递归克隆子节点 for (auto& child : fChildList) { auto childClone = child->makeClone(); clone->appendChild(childClone); } return clone; }\n\n7.5 节点生命周期管理\n\n7.6 实际场景示例：Crossfade 动画\n\n// Crossfade 动画会同时显示新旧内容 Crossfade(targetState = currentScreen) { screen -> when (screen) { Screen.A -> ScreenA() // 旧内容 Screen.B -> ScreenB() // 新内容 } }\n\n回放时的节点分配：\n\n帧 N (过渡中): Picture (ScreenA) │ ┌───────────────┼───────────────┐ │ │ │ fOriginNode fCacheClone[0] fCacheClone[1] (alpha=0.7) (不使用) (alpha=0.3) │ │ ▼ ▼ 旧内容显示 新内容显示\n\n第八部分：关键代码位置索引\n\n8.1 Kotlin 层（Compose UI）\n\n类/方法\n\n文件路径\n\n说明\n\nRenderNodeLayer\n\ncompose/ui/ui/src/skikoMain/kotlin/androidx/compose/ui/platform/RenderNodeLayer.skiko.kt\n\n图层桥接类\n\ndrawLayer()\n\n同上\n\n图层绘制入口\n\nperformDrawLayer()\n\n同上\n\n执行绘制（阴影、裁剪、透明度）\n\ninvalidate()\n\n同上\n\n失效处理，清除缓存\n\n8.2 C++ 层（OHRender）\n\n类/方法\n\n文件路径\n\n说明\n\nSkPictureRecorder\n\nOHRender/src/core/SkPictureRecorder.cpp\n\n命令录制器\n\nbeginRecording()\n\n同上\n\n开始录制\n\nfinishRecordingAsPicture()\n\n同上\n\n完成录制\n\nSkOHPicture\n\n同上\n\nPicture 容器\n\nplayback()\n\n同上\n\n回放与模式决策\n\ngenerateNewNode()\n\n同上\n\n节点获取/克隆\n\nSkCanvas\n\nOHRender/src/core/SkCanvas.cpp\n\n绘制接口\n\nbeginSubCanvas()\n\n同上\n\n创建子画布\n\nfinishSubCanvas()\n\n同上\n\n完成子画布\n\ngetFinishDrawBounds()\n\n同上\n\n获取脏区边界\n\nOHRenderNode\n\nOHRender/src/oh/OHRenderNode.cpp\n\n渲染节点\n\npictureDraw()\n\n同上\n\nPicture 模式绘制\n\nnodeDraw()\n\n同上\n\nNode 模式绘制\n\nmakeClone()\n\n同上\n\n节点克隆\n\nappendChild()\n\n同上\n\n添加子节点\n\n8.3 头文件\n\n文件\n\n路径\n\n说明\n\nSkPictureRecorder.h\n\nOHRender/include/core/SkPictureRecorder.h\n\n录制器头文件\n\nSkCanvas.h\n\nOHRender/include/core/SkCanvas.h\n\n画布头文件\n\nSkPicture.h\n\nOHRender/include/core/SkPicture.h\n\nPicture 头文件\n\nOHRenderNode.h\n\nOHRender/include/oh/OHRenderNode.h\n\n节点头文件\n\n8.4 ArkTS 层\n\n类/方法\n\n文件路径\n\n说明\n\nCanvasNodeController\n\nui-arkui/src/ohosArm64Main/cpp/compose/src/main/ets/compose/CanvasNode.ets\n\nCanvas 节点控制器\n\nCompose 组件\n\n同上\n\nCompose 根组件\n\n附录：核心数据结构速查\n\nRenderNodeLayer (Kotlin)\n\ninternal class RenderNodeLayer : OwnedLayer { private val pictureRecorder = PictureRecorder() private var picture: Picture? = null internal val matrix = Matrix() private var alpha: Float = 1f private var clip: Boolean = false private var shadowElevation: Float = 0f }\n\nSkOHPicture (C++)\n\nclass SkOHPicture final : public SkPicture { SkRect fCull; bool fNoLimitDraw; bool fPlaybackInNode; bool fCanPlaybackInPicture; OHDrawingRecordCmdSPtr fOHRecordCmd; std::shared_ptr<OHRenderNode> fOriginNode; mutable std::shared_ptr<OHRenderNode> fNowCacheNode; mutable std::list<std::shared_ptr<OHRenderNode>> fCacheCloneNodes; std::vector<sk_sp<SkPicture>> fSubPics; };\n\nOHRenderNode (C++)\n\nclass OHRenderNode { int fNodeId; SkRect fRealFrame; SkMatrix fFatherMatrix; OH_Drawing_RecordCmd* fPictureCmd; std::shared_ptr<OHRenderNode> fParent; std::list<std::shared_ptr<OHRenderNode>> fChildList; bool fDrawInPicture = true; bool fVisible = true; };",
          "content_html": "<h1><strong>OHRender 融合渲染原理讲解文档</strong></h1>\n<p>本文档详细讲解 CMP（Compose Multiplatform）对接 OHRender 实现 OHOS 统一  渲染方案中的指令录制与绘制机制。</p>\n<hr />\n<h2><strong>第一部分：概述与背景</strong></h2>\n<h3><strong>1.1 什么是融合渲染</strong></h3>\n<p><strong>融合渲染</strong> 是指将 Compose Multiplatform 的绘制命令转换为 OHOS（OpenHarmony OS）原生渲染指令的技术方案。其核心目标是：</p>\n<ol>\n<li><strong>跨平台一致性</strong>：使用统一的 Compose UI 代码，在 OHOS 平台获得原生渲染性能</li>\n<li><strong>高性能</strong>：利用 OHOS 的 RenderService 进行硬件加速渲染</li>\n<li><strong>细粒度更新</strong>：支持按节点级别的脏区管理，避免全屏重绘</li>\n</ol>\n<h3><strong>1.2 技术架构总览</strong></h3>\n<pre><code>┌─────────────────────────────────────────────────────────────────┐\n│ Compose UI (Kotlin) │\n│ 声明式 UI 定义 @Composable │\n└────────────────────────────┬────────────────────────────────────┘\n│\n▼\n┌─────────────────────────────────────────────────────────────────┐\n│ RenderNodeLayer (Kotlin) │\n│ 图层管理 + Picture 录制/缓存 │\n└────────────────────────────┬────────────────────────────────────┘\n│ JNI\n▼\n┌─────────────────────────────────────────────────────────────────┐\n│ SkPictureRecorder (C++) │\n│ 创建 Canvas + 录制绘制命令 + 生成 Picture │\n└────────────────────────────┬────────────────────────────────────┘\n│\n▼\n┌─────────────────────────────────────────────────────────────────┐\n│ SkOHPicture + OHRenderNode (C++) │\n│ Picture/Node 模式决策 + 渲染节点树管理 │\n└────────────────────────────┬────────────────────────────────────┘\n│\n▼\n┌─────────────────────────────────────────────────────────────────┐\n│ OHOS RenderService │\n│ 硬件加速渲染 │\n└─────────────────────────────────────────────────────────────────┘</code></pre>\n<hr />\n<figure class=\"doc-figure\"><img src=\"../knowledge-map-assets/module-10d487ca-1431f05b49.png\" alt=\"指令录制与绘制机制 图示\" /></figure>\n<h2><strong>第二部分：核心概念</strong></h2>\n<p>本部分按照<strong>依赖关系由底向上</strong>的顺序介绍 6 个核心类。</p>\n<h3><strong>2.1 OH_Drawing_RecordCmd（底层）</strong></h3>\n<p><strong>定位</strong>：OHOS 原生绘制命令的容器</p>\n<pre><code>// OHOS 系统提供的绘制命令录制 API\nOH_Drawing_RecordCmdUtils* recorder;\nOH_Drawing_Canvas* canvas;\nOH_Drawing_RecordCmd* recordCmd;\n​\n// 开始录制\nOH_Drawing_RecordCmdUtilsBeginRecording(recorder, width, height, &amp;canvas);\n​\n// 在 canvas 上执行绘制操作...\n​\n// 结束录制，获取命令\nOH_Drawing_RecordCmdUtilsFinishRecording(recorder, &amp;recordCmd);</code></pre>\n<p><strong>特点</strong>：</p>\n<ul>\n<li>由 OHOS 系统管理生命周期</li>\n<li>可被多次回放执行</li>\n<li>支持嵌套回放（<code>OH_Drawing_CanvasDrawRecordCmdNesting</code>）</li>\n</ul>\n<h3><strong>2.2 OHRenderNode（渲染节点）</strong></h3>\n<p><strong>定位</strong>：渲染节点，管理绘制命令和节点树结构</p>\n<pre><code>class OHRenderNode {\n// === 标识 ===\nint fNodeId; // 节点唯一 ID\n// === 绘制区域 ===\nSkRect fNowFrame; // 当前帧边界（用于布局）\nSkRect fRealFrame; // 实际绘制边界（脏区）\nbool fNoLimitSize; // 是否无尺寸限制\n// === 绘制命令 ===\nOH_Drawing_RecordCmd* fPictureCmd; // 录制的绘制命令\n// === 节点树结构 ===\nstd::shared_ptr&lt;OHRenderNode&gt; fParent; // 父节点\nstd::list&lt;std::shared_ptr&lt;OHRenderNode&gt;&gt; fChildList; // 子节点列表\n// === 变换与状态 ===\nSkMatrix fFatherMatrix; // 相对父节点的变换矩阵\nbool fDrawInPicture; // 模式标志：true=Picture模式, false=Node模式\nbool fVisible; // 可见性\n};</code></pre>\n<p><strong>核心方法</strong>：</p>\n<div class=\"doc-table-wrap\"><table class=\"doc-table\"><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td>pictureDraw()</td><td>Picture 模式下执行绘制</td></tr><tr><td>nodeDraw()</td><td>Node 模式下执行绘制</td></tr><tr><td>appendChild()</td><td>添加子节点</td></tr><tr><td>makeClone()</td><td>克隆节点（用于多实例场景）</td></tr></tbody></table></div>\n<h3><strong>2.3 SkCanvas（绘制接口）</strong></h3>\n<p><strong>定位</strong>：绘制命令的录制接口，是 Skia 绘制 API 与 OHOS OH_Drawing API 之间的<strong>核心桥接层</strong></p>\n<p><strong>核心职责</strong>：</p>\n<ol>\n<li><strong>命令转换</strong>：将 Skia 绘制调用转换为 OH_Drawing 调用</li>\n<li><strong>脏区跟踪</strong>：动态计算实际绘制边界，用于优化渲染</li>\n<li><strong>状态管理</strong>：管理变换矩阵、裁剪区域、画笔状态等</li>\n<li><strong>嵌套支持</strong>：支持 SubCanvas 机制处理嵌套 Layer</li>\n</ol>\n<pre><code>class SkCanvas {\n// === 底层画布 ===\nOH_Drawing_Canvas*; // OHOS 原生画布（实际执行绘制）\n// === 关联节点 ===\nOHRenderNode* fOHNode; // 当前关联的渲染节点\n// === 变换状态 ===\nSkMatrix fInitMatrix; // 初始变换矩阵\nSkMatrix fTotalMatrix; // 累积变换矩阵\nstd::vector&lt;SkMatrix&gt; fMatrixStack; // 矩阵栈（save/restore）\n// === 裁剪状态 ===\nSkRect fClipBounds; // 当前裁剪边界\nstd::vector&lt;SkRect&gt; fClipStack; // 裁剪栈\n// === 脏区跟踪 ===\nSkRect fRecordCull; // 录制时指定的边界\nSkRect fDrawBounds; // 实际绘制边界（动态计算）\nbool fHasDrawBounds; // 是否有有效绘制边界\n// === 子画布（嵌套录制） ===\nSkCanvas* fSubCanvas; // 子画布（嵌套 Layer 使用）\nSkPictureRecorder* fSubRecorder; // 子录制器\nstd::vector&lt;sk_sp&lt;SkPicture&gt;&gt; fSubPics; // 已完成的子 Picture 列表\n// === 状态标志 ===\nbool fIsPlayingBack; // 是否正在回放子 Picture\nbool fForceDrawInPicture; // 是否强制 Picture 模式\nint fSaveLayerDepth; // SaveLayer 嵌套深度\n};</code></pre>\n<p><strong>核心方法</strong>：</p>\n<div class=\"doc-table-wrap\"><table class=\"doc-table\"><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td>save() / restore()</td><td>保存/恢复画布状态（矩阵、裁剪）</td></tr><tr><td>translate()</td><td>平移变换</td></tr><tr><td>rotate()</td><td>旋转变换</td></tr><tr><td>scale()</td><td>缩放变换</td></tr><tr><td>concat()</td><td>连接变换矩阵</td></tr><tr><td>clipRect()</td><td>矩形裁剪</td></tr><tr><td>clipPath()</td><td>路径裁剪</td></tr><tr><td>drawRect()</td><td>绘制矩形</td></tr><tr><td>drawPath()</td><td>绘制路径</td></tr><tr><td>drawImage()</td><td>绘制图像</td></tr><tr><td>drawText()</td><td>绘制文本</td></tr><tr><td>drawPicture()</td><td>绘制 Picture（触发回放）</td></tr><tr><td>saveLayer()</td><td>创建离屏图层</td></tr><tr><td>beginSubCanvas()</td><td>创建子画布（嵌套录制）</td></tr><tr><td>finishSubCanvas()</td><td>完成子画布录制</td></tr><tr><td>getFinishDrawBounds()</td><td>获取最终脏区边界</td></tr><tr><td>getOHNode()</td><td>获取关联的 OHRenderNode</td></tr></tbody></table></div>\n<p><strong>绘制命令转换示例</strong>：</p>\n<pre><code>// 示例 1：绘制矩形\nvoid SkCanvas::drawRect(const SkRect&amp; rect, const SkPaint&amp; paint) {\n// 1. 转换画笔\nOH_Drawing_Brush* brush = paint.asBrush();\nOH_Drawing_Pen* pen = paint.asPen();\n// 2. 设置画笔到 OH_Drawing_Canvas\nif (brush) OH_Drawing_CanvasAttachBrush(fOHCanvas, brush);\nif (pen) OH_Drawing_CanvasAttachPen(fOHCanvas, pen);\n// 3. 转换矩形并绘制\nOH_Drawing_Rect* ohRect = toOHRect(rect);\nOH_Drawing_CanvasDrawRect(fOHCanvas, ohRect);\n// 4. 更新脏区边界\nupdateDrawBounds(rect);\n// 5. 清理\nOH_Drawing_RectDestroy(ohRect);\nif (brush) OH_Drawing_CanvasDetachBrush(fOHCanvas);\nif (pen) OH_Drawing_CanvasDetachPen(fOHCanvas);\n}\n​\n// 示例 2：绘制路径\nvoid SkCanvas::drawPath(const SkPath&amp; path, const SkPaint&amp; paint) {\nOH_Drawing_Path* ohPath = path.toOHPath();\nOH_Drawing_CanvasDrawPath(fOHCanvas, ohPath);\n// 使用路径边界更新脏区\nupdateDrawBounds(path.getBounds());\n}\n​\n// 示例 3：绘制图像\nvoid SkCanvas::drawImage(const sk_sp&lt;SkImage&gt;&amp; image, SkScalar x, SkScalar y,\nconst SkPaint* paint) {\nOH_Drawing_Image* ohImage = image-&gt;toOHImage();\nOH_Drawing_CanvasDrawImage(fOHCanvas, ohImage, x, y, ...);\n// 计算图像绘制边界\nSkRect bounds = SkRect::MakeXYWH(x, y, image-&gt;width(), image-&gt;height());\nupdateDrawBounds(bounds);\n}</code></pre>\n<p><strong>脏区跟踪机制</strong>：</p>\n<pre><code>// 每次绘制操作都会更新脏区\nvoid SkCanvas::updateDrawBounds(const SkRect&amp; bounds) {\n// 将绘制区域通过当前变换矩阵映射\nSkRect mappedBounds;\nfTotalMatrix.mapRect(&amp;mappedBounds, bounds);\n// 与裁剪区域求交\nif (!mappedBounds.intersect(fClipBounds)) {\nreturn; // 被完全裁剪，不影响脏区\n}\n// 合并到总脏区\nif (fHasDrawBounds) {\nfDrawBounds.join(mappedBounds);\n} else {\nfDrawBounds = mappedBounds;\nfHasDrawBounds = true;\n}\n}\n​\n// 获取最终脏区（录制结束时调用）\nstd::optional&lt;SkRect&gt; SkCanvas::getFinishDrawBounds() {\nif (!fHasDrawBounds) {\nreturn std::nullopt; // 无绘制内容\n}\n// 反向映射到录制坐标系\nSkMatrix inverse;\nif (fInitMatrix.invert(&amp;inverse)) {\nSkRect result;\ninverse.mapRect(&amp;result, fDrawBounds);\nreturn result;\n}\nreturn fDrawBounds;\n}</code></pre>\n<p>脏区跟踪的核心原理是<strong>动态记录所有绘制操作实际影响的有效区域</strong>，通过结合变换矩阵、裁剪区域和区域合并策略，最终生成需要更新或处理的区域集合。以下是基于代码的具体实现逻辑解析：</p>\n<p><strong>1. 单次绘制操作的脏区更新（</strong><strong><code>updateDrawBounds</code></strong><strong>）</strong></p>\n<p>每次绘制操作（如画线、填充图形等）触发此函数，核心步骤如下：</p>\n<ul>\n<li><strong>变换映射</strong>：将绘制的原始边界 <code>bounds</code> 通过当前总变换矩阵 <code>fTotalMatrix</code> 映射到目标空间（例如画布可能经过平移、旋转、缩放等变换，需将绘制区域转换到实际生效的坐标系）。得到 <code>mappedBounds</code>。</li>\n<li><strong>裁剪过滤</strong>：将映射后的区域 <code>mappedBounds</code> 与当前画布的裁剪区域 <code>fClipBounds</code> 求交。若完全被裁剪（无交集），则此次绘制不影响脏区，直接返回；否则保留交集部分（即实际可见的绘制区域）。</li>\n<li><strong>合并脏区</strong>：将过滤后的有效区域合并到总脏区 <code>fDrawBounds</code> 中。若总脏区尚未初始化（<code>fHasDrawBounds</code> 为 <code>false</code>），则直接赋值；否则通过 <code>join</code> 操作合并两个区域（取并集）。</li>\n</ul>\n<p><strong>2. 最终脏区的生成（</strong><strong><code>getFinishDrawBounds</code></strong><strong>）</strong></p>\n<p>绘制操作全部完成后（如录制结束），调用此函数获取最终脏区：</p>\n<ul>\n<li><strong>无绘制内容判断</strong>：若总脏区未初始化（<code>fHasDrawBounds</code> 为 <code>false</code>），返回 <code>std::nullopt</code> 表示无有效绘制。</li>\n<li><strong>坐标系反向映射</strong>：由于脏区 <code>fDrawBounds</code> 是在经过初始矩阵 <code>fInitMatrix</code> 变换后的坐标系中记录的，需通过其逆矩阵 <code>inverse</code> 将脏区反向映射回原始录制坐标系（确保脏区与用户最初操作的坐标系一致）。若逆矩阵不存在（不可逆），则直接返回当前脏区。</li>\n</ul>\n<p><strong>关键设计思想</strong></p>\n<ul>\n<li><strong>变换感知</strong>：脏区始终跟踪“实际生效”的绘制区域，而非原始绘制指令的边界。例如，一个被缩放的圆形，其脏区会是缩放后的椭圆区域。</li>\n<li><strong>裁剪优化</strong>：仅保留被裁剪区域覆盖的部分，避免无效区域的冗余记录。</li>\n<li><strong>区域合并</strong>：通过逐步合并每次绘制的有效区域，最终得到所有需要处理的区域的并集（总脏区）。</li>\n<li><strong>坐标系一致性</strong>：最终脏区反向映射回原始坐标系，保证结果与用户视角一致，便于后续处理（如重绘、碰撞检测等）。</li>\n</ul>\n<p><strong>总结</strong></p>\n<p>脏区跟踪通过<strong>变换映射→裁剪过滤→区域合并</strong>的流程，动态维护所有绘制操作的实际有效区域，最终输出一个紧凑的、坐标对齐的区域集合，用于高效处理需要更新的内容（如界面重绘、离屏渲染等）。</p>\n<p><strong>状态保存与恢复</strong>：</p>\n<pre><code>void SkCanvas::save() {\n// 保存变换矩阵\nfMatrixStack.push_back(fTotalMatrix);\n// 保存裁剪区域\nfClipStack.push_back(fClipBounds);\n// 调用 OH_Drawing 保存\nOH_Drawing_CanvasSave(fOHCanvas);\n}\n​\nvoid SkCanvas::restore() {\n// 恢复变换矩阵\nif (!fMatrixStack.empty()) {\nfTotalMatrix = fMatrixStack.back();\nfMatrixStack.pop_back();\n}\n// 恢复裁剪区域\nif (!fClipStack.empty()) {\nfClipBounds = fClipStack.back();\nfClipStack.pop_back();\n}\n// 调用 OH_Drawing 恢复\nOH_Drawing_CanvasRestore(fOHCanvas);\n}</code></pre>\n<h3><strong>2.4 SkPicture / SkOHPicture（绘制命令容器）</strong></h3>\n<p><strong>定位</strong>：不可变的绘制命令容器，支持多次回放</p>\n<pre><code>class SkOHPicture final : public SkPicture {\n// === 边界信息 ===\nSkRect fCull; // 裁剪边界（脏区）\nbool fNoLimitDraw; // 无限制绘制标志\n// === 绘制命令 ===\nOHDrawingRecordCmdSPtr fOHRecordCmd; // OH 绘制命令（智能指针）\n// === 节点管理 ===\nstd::shared_ptr&lt;OHRenderNode&gt; fOriginNode; // 原始节点\nmutable std::shared_ptr&lt;OHRenderNode&gt; fNowCacheNode;// 当前使用的节点\n// 克隆节点缓存\nmutable std::list&lt;std::shared_ptr&lt;OHRenderNode&gt;&gt; fCacheCloneNodes;\n// 未使用节点池\nmutable std::list&lt;std::shared_ptr&lt;OHRenderNode&gt;&gt; fUnusedCloneNodes;\n// === 状态标志 ===\nmutable bool fPlaybackInNode; // 是否在 Node 模式回放\nbool fCanPlaybackInPicture; // 是否可以在 Picture 模式回放\n// === 子 Picture ===\nstd::vector&lt;sk_sp&lt;SkPicture&gt;&gt; fSubPics; // 嵌套的子 Picture\n};</code></pre>\n<p><strong>核心方法</strong>：</p>\n<pre><code>// 回放方法 - 核心决策逻辑所在\nvoid playback(SkCanvas* canvas, AbortCallback* callback) const override;</code></pre>\n<h3><strong>2.5 SkPictureRecorder（命令录制器）</strong></h3>\n<p><strong>定位</strong>：管理 Canvas 和 OHRenderNode 的创建，生成 SkOHPicture</p>\n<pre><code>class SkPictureRecorder {\n// === 录制器 ===\nOH_Drawing_RecordCmdUtils* fOHRecorder; // OHOS 录制工具\n// === 当前录制状态 ===\nSkCanvas* fRecordCanvas; // 当前录制用的 Canvas\nbool fActivelyRecording; // 是否正在录制\nSkRect fCullRect; // 录制边界\n// === 节点管理 ===\nstd::shared_ptr&lt;OHRenderNode&gt; fNowOHNode; // 当前关联的节点\n};</code></pre>\n<p><strong>核心 API</strong>：</p>\n<pre><code>// 开始录制，返回可用于绘制的 Canvas\nSkCanvas* beginRecording(const SkRect&amp; bounds);\n​\n// 结束录制，生成 Picture\nsk_sp&lt;SkPicture&gt; finishRecordingAsPicture();</code></pre>\n<h3><strong>2.6 OwnedLayer / RenderNodeLayer（Compose 图层）</strong></h3>\n<p><strong>定位</strong>：Compose UI 层的<strong>图层抽象</strong>，管理变换、裁剪、透明度等属性</p>\n<pre><code>internal class RenderNodeLayer(\nprivate var density: Density,\nprivate val invalidateParentLayer: () -&gt; Unit,\nprivate val drawBlock: (Canvas) -&gt; Unit,\nprivate val onDestroy: () -&gt; Unit = {}\n) : OwnedLayer {\n// === Picture 录制 ===\nprivate val pictureRecorder = PictureRecorder()\nprivate var picture: Picture? = null // 缓存的 Picture\n// === 图层属性 ===\ninternal val matrix = Matrix() // 变换矩阵\nprivate var transformOrigin: TransformOrigin\nprivate var translationX/Y/Z: Float\nprivate var rotationX/Y/Z: Float\nprivate var scaleX/Y: Float\nprivate var alpha: Float // 透明度\nprivate var clip: Boolean // 裁剪开关\nprivate var shadowElevation: Float // 阴影高度\n// === 核心方法 ===\noverride fun drawLayer(canvas: Canvas) { ... }\noverride fun invalidate() { ... }\n}</code></pre>\n<h3><strong>2.7 核心概念关系图</strong></h3>\n<figure class=\"doc-figure\"><img src=\"../knowledge-map-assets/module-10d487ca-d1b53e4ee8.png\" alt=\"指令录制与绘制机制 图示\" /></figure>\n<hr />\n<h2><strong>第三部分：对象关系</strong></h2>\n<h3><strong>3.1 数量关系概述</strong></h3>\n<div class=\"doc-table-wrap\"><table class=\"doc-table\"><thead><tr><th>源对象</th><th>目标对象</th><th>关系</th><th>说明</th></tr></thead><tbody><tr><td>OwnedLayer</td><td>SkPictureRecorder</td><td>1:1</td><td>每个 Layer 持有一个 Recorder</td></tr><tr><td>OwnedLayer</td><td>SkOHPicture</td><td>1:0..1</td><td>缓存的 Picture，invalidate 时清空</td></tr><tr><td>SkOHPicture</td><td>OHRenderNode (Origin)</td><td>1:1</td><td>创建时关联的原始节点</td></tr><tr><td>SkOHPicture</td><td>OHRenderNode (Cache)</td><td>1:N</td><td>多次 Node 模式回放时创建克隆</td></tr><tr><td>OHRenderNode</td><td>OHRenderNode (Child)</td><td>1:N</td><td>父子节点树结构</td></tr></tbody></table></div>\n<h3><strong>3.2 类图</strong></h3>\n<figure class=\"doc-figure\"><img src=\"../knowledge-map-assets/module-10d487ca-ec5ca256af.png\" alt=\"指令录制与绘制机制 图示\" /></figure>\n<p><strong>图例说明</strong>：</p>\n<div class=\"doc-table-wrap\"><table class=\"doc-table\"><thead><tr><th>层级</th><th>语言</th><th>说明</th></tr></thead><tbody><tr><td>CMP 层</td><td>Kotlin</td><td>Compose Multiplatform 框架层，定义图层接口和绘制逻辑</td></tr><tr><td>Skiko 层</td><td>Kotlin</td><td>Skia Kotlin 绑定层，提供跨平台 Canvas/Picture API</td></tr><tr><td>OHRender 层</td><td>C++</td><td>OHOS 渲染适配层，实现 Skia API 到 OH_Drawing API 的转换</td></tr></tbody></table></div>\n<p><strong>跨层调用关系</strong>：</p>\n<pre><code>RenderNodeLayer (Kotlin)\n│\n│ 持有 Skiko 对象\n▼\nPictureRecorder / Canvas / Picture (Skiko Kotlin)\n│\n│ JNI 调用\n▼\nSkPictureRecorder / SkCanvas / SkOHPicture (C++)\n│\n│ API 转换\n▼\nOH_Drawing_Canvas / OH_Drawing_RecordCmd (OHOS System)</code></pre>\n<h3><strong>3.3 一个 OwnedLayer 是否一定对应一个 OHRenderNode？</strong></h3>\n<p><strong>答案：是的，但不是简单的 1:1</strong></p>\n<p>每个 <code>OwnedLayer</code>（即 <code>RenderNodeLayer</code>）在录制时会：</p>\n<ol>\n<li>必定关联一个<strong>原始节点</strong>（<code>fOriginNode</code>）</li>\n<li>但在回放时可能创建<strong>多个克隆节点</strong></li>\n</ol>\n<pre><code>OwnedLayer\n└── SkOHPicture\n├── fOriginNode ─────────────────→ OHRenderNode #1 (原始)\n├── fCacheCloneNodes[0] ─────────→ OHRenderNode #2 (克隆)\n└── fCacheCloneNodes[1] ─────────→ OHRenderNode #3 (克隆)</code></pre>\n<h3><strong>3.4 是否会存在多个 OwnedLayer 绘制在同一个 OHRenderNode？</strong></h3>\n<p><strong>答案：会的，在 Picture 模式下</strong></p>\n<p>当子 Layer 选择 <strong>Picture 模式</strong> 回放时，其绘制命令会被聚合到父节点的 <code>OH_Drawing_RecordCmd</code> 中：</p>\n<pre><code>Layer A (父)\n│\n├── 自身绘制命令\n│\n└── Layer B (子, Picture 模式)\n│\n└── 绘制命令 ──聚合──→ Layer A 的 OHRenderNode</code></pre>\n<p><strong>示意图</strong>：</p>\n<figure class=\"doc-figure\"><img src=\"../knowledge-map-assets/module-10d487ca-3f084cf770.png\" alt=\"指令录制与绘制机制 图示\" /></figure>\n<hr />\n<h2><strong>第四部分：录制流程</strong></h2>\n<h3><strong>4.1 录制流程总览</strong></h3>\n<figure class=\"doc-figure\"><img src=\"../knowledge-map-assets/module-10d487ca-3c9bc24c36.png\" alt=\"指令录制与绘制机制 图示\" /></figure>\n<h3><strong>4.2 录制入口：</strong><strong><code>RenderNodeLayer.drawLayer()</code></strong></h3>\n<pre><code>// 文件: RenderNodeLayer.skiko.kt\n​\noverride fun drawLayer(canvas: Canvas) {\n// 🎯 步骤 1：检查缓存\nif (picture == null) {\nval bounds = size.toSize().toRect()\n// 🎯 步骤 2：开始录制\n// 使用极大边界，实际脏区由 C++ 层计算\nval pictureCanvas = pictureRecorder.beginRecording(\norg.jetbrains.skia.Rect.makeLTRB(\nl = -(1 shl 30).toFloat(),\nt = -(1 shl 30).toFloat(),\nr = ((1 shl 30)-1).toFloat(),\nb = ((1 shl 30)-1).toFloat()\n)\n)\n// 🎯 步骤 3：执行绘制\nperformDrawLayer(pictureCanvas.asComposeCanvas(), bounds)\n// 🎯 步骤 4：完成录制\npicture = pictureRecorder.finishRecordingAsPicture()\n}\n// 🎯 步骤 5：应用变换并绘制 Picture\ncanvas.save()\ncanvas.concat(matrix)\ncanvas.translate(position.x.toFloat(), position.y.toFloat())\ncanvas.nativeCanvas.drawPicture(picture!!, null, null)\ncanvas.restore()\n}</code></pre>\n<h3><strong>4.3 Canvas 创建：</strong><strong><code>beginRecording()</code></strong></h3>\n<pre><code>// 文件: SkPictureRecorder.cpp\n​\nSkCanvas* SkPictureRecorder::beginRecording(const SkRect&amp; userCullRect,\nsk_sp&lt;SkBBoxHierarchy&gt; bbh) {\nconst SkRect cullRect = userCullRect.isEmpty() ? SkRect::MakeEmpty() : userCullRect;\n// 防止重复录制\nif (fRecordCanvas) {\nreturn nullptr;\n}\n// 🎯 步骤 1：开始 OH_Drawing 录制\nOH_Drawing_Canvas *ohCanvas = nullptr;\nOH_Drawing_RecordCmdUtilsBeginRecording(fOHRecorder,\nullRect.width(),\ncullRect.height(),\n&amp;ohCanvas);\nif (!ohCanvas) {\nreturn nullptr;\n}\n​\n// 🎯 步骤 2：创建或复用 OHRenderNode\nif (fNowOHNode == nullptr || fNowOHNode-&gt;getPicture() != nullptr) {\nfNowOHNode = OHRenderNode::CreateNormalNode();\n}\n// 🎯 步骤 3：创建 SkCanvas（包装 OH_Drawing_Canvas）\nfRecordCanvas = new SkCanvas(ohCanvas, fNowOHNode.get());\nfRecordCanvas-&gt;setRecordCull(cullRect);\n// ... 更多初始化 ...\nfActivelyRecording = true;\nreturn fRecordCanvas;\n}</code></pre>\n<h3><strong>4.4 命令转换示例</strong></h3>\n<pre><code>// 文件: SkCanvas.cpp\n​\nvoid SkCanvas::drawRect(const SkRect&amp; rect, const SkPaint&amp; paint) {\n// 获取 OH_Drawing 画笔\nOH_Drawing_Brush* brush = paint.asBrush();\nOH_Drawing_Pen* pen = paint.asPen();\n// 设置画笔\nif (brush) OH_Drawing_CanvasAttachBrush(fOHCanvas, brush);\nif (pen) OH_Drawing_CanvasAttachPen(fOHCanvas, pen);\n// 转换为 OH_Drawing 命令\nOH_Drawing_Rect* ohRect = OH_Drawing_RectCreate();\nOH_Drawing_RectSetLeft(ohRect, rect.fLeft);\nOH_Drawing_RectSetTop(ohRect, rect.fTop);\nOH_Drawing_RectSetRight(ohRect, rect.fRight);\nOH_Drawing_RectSetBottom(ohRect, rect.fBottom);\n// 执行绘制\nOH_Drawing_CanvasDrawRect(fOHCanvas, ohRect);\n// 🎯 更新脏区边界\nupdateDrawBounds(rect);\n// 清理\nOH_Drawing_RectDestroy(ohRect);\nif (brush) OH_Drawing_CanvasDetachBrush(fOHCanvas);\nif (pen) OH_Drawing_CanvasDetachPen(fOHCanvas);\n}</code></pre>\n<h3><strong>4.5 脏区计算：</strong><strong><code>getFinishDrawBounds()</code></strong></h3>\n<pre><code>// 文件: SkCanvas.cpp\nstd::optional&lt;SkRect&gt; SkCanvas::getFinishDrawBounds() {\nif (!fHasDrawBounds) {\nreturn std::nullopt; // 无绘制内容\n}\n// 应用录制时的变换矩阵，将脏区映射到正确坐标系\nSkMatrix inverse;\nif (fInitMatrix.invert(&amp;inverse)) {\nSkRect mappedBounds;\ninverse.mapRect(&amp;mappedBounds, fDrawBounds);\nreturn mappedBounds;\n}\nreturn fDrawBounds;\n}</code></pre>\n<h3><strong>4.6 Picture 生成：finishRecordingAsPicture()</strong></h3>\n<pre><code>// 文件: SkPictureRecorder.cpp\nsk_sp&lt;SkPicture&gt; SkPictureRecorder::finishRecordingAsPicture() {\nfActivelyRecording = false;\nif (!fRecordCanvas) {\nreturn nullptr;\n}\n// 🎯 步骤 1：处理子 Canvas（嵌套录制场景）\nif (fRecordCanvas-&gt;fSubCanvas) {\nfRecordCanvas-&gt;finishSubCanvas();\n}\nif (fNowOHNode) {\nfNowOHNode-&gt;finishChildAdd();\n}\n// 🎯 步骤 2：获取脏区边界\nOH_Drawing_RecordCmd* recordCmd = nullptr;\nauto paintArea = fRecordCanvas-&gt;getFinishDrawBounds();\nbool noLimitDraw = false;\nif (paintArea.has_value()) {\n// 有明确绘制边界\nif (fNowOHNode) {\nfNowOHNode-&gt;setRealFrame(paintArea.value(), false);\n}\nfCullRect = paintArea.value();\n} else {\n// 无限制绘制（可能是无绘制内容或全屏绘制）\nauto noLimitRect = SkRect::MakeWH(NODE_SIZE_ALIGNMENT, NODE_SIZE_ALIGNMENT);\nif (fNowOHNode) {\nfNowOHNode-&gt;setRealFrame(noLimitRect, true);\n}\nnoLimitDraw = true;\n}\n// 🎯 步骤 3：完成 OH_Drawing 录制\nOH_Drawing_RecordCmdUtilsFinishRecording(fOHRecorder, &amp;recordCmd);\n// 🎯 步骤 4：收集子 Picture\nauto subPics = fRecordCanvas-&gt;takeSubPics();\n// 🎯 步骤 5：计算内容哈希（用于缓存复用）\nuint64_t pictureHash = calculateHash();\n// 🎯 步骤 6：创建 SkOHPicture\nreturn sk_make_sp&lt;SkOHPicture&gt;(\nfCullRect, // 脏区边界\nnoLimitDraw, // 无限制绘制标志\nrecordCmd, // OH 绘制命令\nfNowOHNode, // 关联节点\nstd::move(subPics), // 子 Picture 列表\ncost, // 绘制成本\nfDisableRecycleNode, // 禁用节点回收\npictureHash // 内容哈希\n);\n}</code></pre>\n<hr />\n<h2><strong>第五部分：回放流程与模式决策</strong></h2>\n<h3><strong>5.1 两种模式对比</strong></h3>\n<div class=\"doc-table-wrap\"><table class=\"doc-table\"><thead><tr><th>特性</th><th>Picture 模式</th><th>Node 模式</th></tr></thead><tbody><tr><td>渲染方式</td><td>直接在 Canvas 上执行命令</td><td>独立 RenderNode 挂载</td></tr><tr><td>脏区管理</td><td>父节点统一管理</td><td>独立脏区</td></tr><tr><td>变换支持</td><td>继承父节点变换</td><td>独立变换矩阵</td></tr><tr><td>内存占用</td><td>较低</td><td>较高（节点对象开销）</td></tr><tr><td>适用场景</td><td>静态/简单内容</td><td>动态/复杂/频繁变化</td></tr><tr><td>是否可逆</td><td>可回退到 Node</td><td>不可逆，一旦分裂无法聚合</td></tr></tbody></table></div>\n<h3><strong>5.2 模式决策流程图</strong></h3>\n<figure class=\"doc-figure\"><img src=\"../knowledge-map-assets/module-10d487ca-821417061a.png\" alt=\"指令录制与绘制机制 图示\" /></figure>\n<h3><strong>5.3 回放核心代码：playback()</strong></h3>\n<pre><code>// 文件: SkPictureRecorder.cpp (SkOHPicture 类)\nvoid playback(SkCanvas* canvas, AbortCallback* callback) const override {\n// 获取父节点\nauto canvas_node = canvas-&gt;getOHNode();\n// === 模式决策 ===\nbool should_paint_in_picture = false;\n// 条件 1：无父节点或无原始节点\nif (!canvas_node || !fOriginNode) {\nshould_paint_in_picture = true;\n}\n// 条件 2：强制 Picture 模式\nelse if (canvas-&gt;isForceDrawInPicture()) {\nshould_paint_in_picture = true;\n}\n// 条件 3：在 SaveLayer 中且支持嵌套命令\nelse if (canvas-&gt;isInSaveLayer() &amp;&amp;\nOHDrawingAPI::support_OH_Drawing_CanvasDrawRecordCmdNesting) {\nshould_paint_in_picture = true;\n}\n// 条件 4：无限制绘制且无子节点\nelse if (fNoLimitDraw &amp;&amp; !fOriginNode-&gt;hasChildren()) {\nshould_paint_in_picture = true;\n}\n// 条件 5：之前在 Picture 模式，检查是否需要转为 Node 模式\nelse if (!fPlaybackInNode &amp;&amp; fCanPlaybackInPicture) {\n// 计算绘制区域与父节点的相交情况\nSkRect drawArea = calculateDrawArea(canvas);\nSkRect parentArea = canvas_node-&gt;getPaintArea();\n// 如果不相交，可以继续使用 Picture 模式\nif (!drawArea.intersects(parentArea)) {\nshould_paint_in_picture = true;\n}\n}\n// === 执行回放 ===\nif (should_paint_in_picture) {\n// 🟢 Picture 模式：直接执行命令\nfNowCacheNode-&gt;pictureDraw(canvas-&gt;getOHCanvas(), true);\nfPlaybackInNode = false;\n} else {\n// 🟠 Node 模式：挂载独立节点\nif (!fNowCacheNode) {\nfNowCacheNode = generateNewNode();\n}\n// 设置父子关系\nfNowCacheNode-&gt;setParent(canvas_node);\nfNowCacheNode-&gt;updateFatherMatrix(canvas-&gt;getTotalMatrix());\nfNowCacheNode-&gt;setPaintArea(calculatePaintArea(canvas));\n// 挂载到父节点\ncanvas_node-&gt;appendChild(fNowCacheNode);\nfPlaybackInNode = true;\nfNowCacheNode-&gt;setDrawInPicture(false); // 标记为 Node 模式\n}\n}</code></pre>\n<h3><strong>5.4 分帧分裂优化机制</strong></h3>\n<h4><strong>5.4.1 什么是分帧分裂？</strong></h4>\n<p>在 OHRender 中，当一个 Picture 从 <strong>Picture 模式</strong>切换到 <strong>Node 模式</strong>时，这个过程被称为\"节点分裂\"。为了避免一帧内创建大量节点导致的性能尖峰，OHRender 采用了<strong>分帧分裂</strong>策略：</p>\n<p><strong>核心思想</strong>：每帧<strong>尽可能</strong>只分裂一个节点，将节点创建的开销分散到多帧中，实现渐进式的节点树构建。</p>\n<p><strong>问题场景</strong>：</p>\n<pre><code>// 复杂嵌套结构\nBox(Modifier.graphicsLayer { /* Layer A */ }) {\nColumn {\n// 100 个子元素，每个都有 graphicsLayer\nrepeat(100) { i -&gt;\nBox(Modifier.graphicsLayer { /* Layer B-$i */ }) {\nText(\"Item $i\")\n}\n}\n}\n}</code></pre>\n<p><strong>问题</strong>：如果在<strong>一帧内</strong>将所有 100 个 Picture 都分裂成 Node，会导致：</p>\n<ul>\n<li>CPU 峰值：大量节点对象创建和内存分配</li>\n<li>帧时间超标：可能导致掉帧</li>\n<li>内存压力：瞬间分配大量节点对象</li>\n</ul>\n<p><strong>解决方案</strong>：使用 <code>needDelayChildAppend</code> 标志，控制节点分裂的速度。</p>\n<h4><strong>5.4.2 分帧分裂的工作原理</strong></h4>\n<p><strong>核心数据结构</strong>（<code>OHRenderNode</code>）：</p>\n<pre><code>class OHRenderNode {\n// === 子节点管理 ===\nstd::list&lt;std::shared_ptr&lt;OHRenderNode&gt;&gt; fChildList; // 持久化存储\nstd::list&lt;std::shared_ptr&lt;OHRenderNode&gt;&gt; fChildOrderList;// 本次录制的绘制顺序\nstd::list&lt;std::shared_ptr&lt;OHRenderNode&gt;&gt; fChildAppend; // 本次新添加的子节点\n// === 分帧分裂控制标志 ===\nbool fNeedDelayChildAppend = true; // 本帧是否有新子节点插入\n};</code></pre>\n<p><strong>生命周期流程</strong>：</p>\n<figure class=\"doc-figure\"><img src=\"../knowledge-map-assets/module-10d487ca-cc69342b91.png\" alt=\"指令录制与绘制机制 图示\" /></figure>\n<h4><strong>5.4.3 关键代码实现</strong></h4>\n<p><strong>步骤 1：录制开始，重置标志</strong></p>\n<pre><code>// 文件: OHRenderNode.cpp, L601-613\n​\nvoid OHRenderNode::restartChildAdd() {\n// 🎯 重置分帧分裂标志\nfNeedDelayChildAppend = false;\n// 清空本次录制的临时列表\nfChildOrderList.clear();\nfChildAppend.clear();\n}</code></pre>\n<p><strong>步骤 2：添加子节点，设置标志</strong></p>\n<pre><code>// 文件: OHRenderNode.cpp, L672-720\n​\nvoid OHRenderNode::appendChild(std::shared_ptr&lt;OHRenderNode&gt; child) {\n// ... 前置检查 ...\n// 🎯 记录到本次绘制顺序列表\nfChildOrderList.push_back(child);\n// 🎯 检查是否是新插入的子节点\nbool isNewChild =\n(std::find(fChildList.begin(),\nfChildList.end(),\nchild) == fChildList.end());\nif (isNewChild) {\n// 🎯 记录到新增列表\nfChildAppend.push_back(child);\n// 🔥 设置标志：本帧有新子节点插入！\nfNeedDelayChildAppend = true;\n}\n}</code></pre>\n<p><strong>步骤 3：录制结束，重排序</strong></p>\n<pre><code>// 文件: OHRenderNode.cpp, L615-669\n​\nvoid OHRenderNode::finishChildAdd() {\nif (fChildOrderList.empty()) {\nreturn;\n}\n// 🎯 将新增节点合并到持久化列表\nfor (auto&amp; newChild : fChildAppend) {\nfChildList.push_back(newChild);\n}\n// 🎯 根据本次绘制顺序重排子节点\n// （省略复杂的重排序逻辑...）\n}</code></pre>\n<p><strong>步骤 4：回放时检查标志，控制分裂</strong></p>\n<pre><code>// 文件: SkPictureRecorder.cpp, L230-242 (SkOHPicture::playback)\n​\nconst auto refinePictureModeByHeuristics = [&amp;]() {\nif (should_paint_in_picture) {\nreturn; // 已经决定用 Picture 模式\n}\nif (!canvas_node || !fOriginNode || !fNowCacheNode) {\nreturn;\n}\nif (!fCanPlaybackInPicture || fPlaybackInNode ||\n!OHDrawingAPI::support_OH_Drawing_CanvasDrawRecordCmdNesting) {\nreturn;\n}\n​\nauto father_paint_area = canvas_node-&gt;getPaintChildArea();\nSkRect temp;\nconst bool node_can_draw_in_father =\n(paint_area.has_value() &amp;&amp;\nfather_paint_area.has_value() &amp;&amp;\n!(temp.intersect(father_paint_area.value(), paint_area.value()) &amp;&amp;\ntemp.width() &gt; 0.1f &amp;&amp;\ntemp.height() &gt; 0.1f));\n​\nconst bool matrix_changed =\nfNowCacheNode-&gt;updateFatherMatrix(father_matrix);\nconst bool record_delta_changed =\n(fOriginNode-&gt;updateDeltaChangedCnt(canvas_node-&gt;getRecordCnt()) &gt;= 3);\nconst bool prefer_playback_in_node = (matrix_changed ||\nrecord_delta_changed ||\ncanvas_node-&gt;getAllNodeChildrenNum() &gt; 0);\n​\n// 分帧分裂控制核心逻辑：\n// 当父节点本帧刚添加了新子节点时，我们正处于分帧分裂的过程中；\n// 子节点顺序仍在确定中，所以仅当新子节点不与其他绘制子节点重叠时，\n// 才回退到 Picture 模式（避免创建又一个节点）。\nif (!prefer_playback_in_node ||\n(node_can_draw_in_father &amp;&amp; canvas_node-&gt;needDelayChildAppend())) {\nshould_paint_in_picture = true;\n}\n};</code></pre>\n<h4><strong>5.4.4 分帧分裂的执行流程图</strong></h4>\n<figure class=\"doc-figure\"><img src=\"../knowledge-map-assets/module-10d487ca-19eade3b8a.png\" alt=\"指令录制与绘制机制 图示\" /></figure>\n<h4><strong>5.4.5 分帧分裂的效果对比</strong></h4>\n<p><strong>场景</strong>：父节点下有 10 个子 Picture，首次渲染时需要决策是否分裂。</p>\n<p><strong>无分帧分裂限制</strong>（假设所有条件都满足）：</p>\n<pre><code>帧 1:\nPicture 1 → Node 1 (分裂)\nPicture 2 → Node 2 (分裂)\nPicture 3 → Node 3 (分裂)\n...\nPicture 10 → Node 10 (分裂)\n结果: 一帧内创建 10 个节点，CPU 峰值！</code></pre>\n<p><strong>有分帧分裂控制</strong>：</p>\n<pre><code>帧 1:\nrestartChildAdd() → fNeedDelayChildAppend = false\nPicture 1 → Node 1 (分裂) ✓\n└─ fNeedDelayChildAppend = true\nPicture 2 → Picture 模式 (因为 needDelayChildAppend = true)\nPicture 3 → Picture 模式 (因为 needDelayChildAppend = true)\n...\nPicture 10 → Picture 模式\n帧 2:\nrestartChildAdd() → fNeedDelayChildAppend = false\nPicture 1 → 已分裂，直接挂载\nPicture 2 → Node 2 (分裂) ✓\n└─ fNeedDelayChildAppend = true\nPicture 3 → Picture 模式 (因为 needDelayChildAppend = true)\n...\n帧 3:\nPicture 3 → Node 3 (分裂) ✓\n...\n结果: 每帧只分裂 1 个节点，开销平滑！</code></pre>\n<p><strong>性能对比</strong>：</p>\n<div class=\"doc-table-wrap\"><table class=\"doc-table\"><thead><tr><th>指标</th><th>无分帧分裂限制</th><th>有分帧分裂控制</th></tr></thead><tbody><tr><td>首帧 CPU 峰值</td><td>极高（创建 N 个节点）</td><td>低（创建 1 个节点）</td></tr><tr><td>首帧时间</td><td>可能掉帧（&gt;16.6ms）</td><td>正常（&lt;16.6ms）</td></tr><tr><td>完全分裂时间</td><td>1 帧</td><td>N 帧</td></tr><tr><td>用户体验</td><td>卡顿一下后流畅</td><td>始终流畅</td></tr><tr><td>内存分配曲线</td><td>尖峰</td><td>平滑上升</td></tr></tbody></table></div>\n<h4><strong>5.4.6 特殊情况：不重叠子节点的快速通道</strong></h4>\n<p>即使 <code>needDelayChildAppend = true</code>，如果新子节点与父节点的其他绘制子节点<strong>不重叠</strong>，也可以立即分裂：</p>\n<pre><code>// 核心判断逻辑\nconst bool node_can_draw_in_father =\n(paint_area.has_value() &amp;&amp; father_paint_area.has_value() &amp;&amp;\n!(temp.intersect(father_paint_area.value(), paint_area.value()) &amp;&amp;\ntemp.width() &gt; 0.1f &amp;&amp; temp.height() &gt; 0.1f));\n​\n// 如果不重叠，即使 needDelayChildAppend = true，也可以分裂\nif (!prefer_playback_in_node ||\n(node_can_draw_in_father &amp;&amp; canvas_node-&gt;needDelayChildAppend())) {\nshould_paint_in_picture = true;\n} else {\n// Node 模式分裂\n}</code></pre>\n<h4><strong>5.4.7 命名讨论与改进建议</strong></h4>\n<p><strong>当前命名</strong>：<code>fNeedDelayChildAppend</code></p>\n<p><strong>问题</strong>：</p>\n<ul>\n<li>\"Delay\" 含义不明确，看起来像是延迟添加子节点</li>\n<li>没有体现\"分帧分裂\"的核心意图</li>\n</ul>\n<p><strong>建议命名</strong>：<code>fHasNewChildThisFrame</code> 或 <code>fChildOrderUnstable</code></p>\n<p><strong>原因</strong>：</p>\n<ul>\n<li>更直接地表达\"本帧有新子节点\"的语义</li>\n<li>强调子节点顺序尚未稳定，需要延迟其他节点的分裂</li>\n</ul>\n<p><strong>如果采用新命名，代码会更易读</strong>：</p>\n<pre><code>// 当前代码（语义模糊）\nif (!prefer_playback_in_node ||\n(node_can_draw_in_father &amp;&amp; canvas_node-&gt;needDelayChildAppend())) {\nshould_paint_in_picture = true;\n}\n​\n// 改进后（语义清晰）\nif (!prefer_playback_in_node ||\n(node_can_draw_in_father &amp;&amp; canvas_node-&gt;hasNewChildThisFrame())) {\nshould_paint_in_picture = true;\n}</code></pre>\n<h4><strong>5.4.8 总结</strong></h4>\n<p>分帧分裂机制是 OHRender 实现高性能渲染的关键优化：</p>\n<ol>\n<li><strong>问题</strong>：一帧内分裂大量节点导致性能尖峰</li>\n<li><strong>方案</strong>：使用 <code>needDelayChildAppend</code> 标志，每帧尽量只分裂一个节点</li>\n<li><strong>实现</strong>：</li>\n</ol>\n<ul>\n<li>录制开始时重置标志（<code>restartChildAdd</code>）</li>\n<li>添加子节点时设置标志（<code>appendChild</code>）</li>\n<li>回放时检查标志，控制分裂速度（<code>playback</code>）</li>\n<li>录制结束时合并新增节点（<code>finishChildAdd</code>）</li>\n</ul>\n<ol>\n<li><strong>效果</strong>：将节点创建开销分散到多帧，实现流畅的渲染体验</li>\n<li><strong>特殊情况</strong>：不重叠的子节点可以快速通道，立即分裂</li>\n</ol>\n<h3><strong>5.5 为什么节点分裂后无法聚合？</strong></h3>\n<p><strong>核心原因</strong>：一旦节点进入 Node 模式（<code>fDrawInPicture = false</code>），后续回放时会<strong>优先保持 Node 模式</strong>。</p>\n<p><strong>代码证据</strong>：</p>\n<pre><code>// 文件: OHRenderNode.h\n// 状态标志：初始为 true（尝试 Picture 模式）\nbool fDrawInPicture = true;\n// 判断是否在 Node 模式\nbool isInNode() { return !fDrawInPicture; }</code></pre>\n<pre><code>// 文件: SkPictureRecorder.cpp (SkOHPicture 构造函数)\nSkOHPicture(...) {\n// 构造时记录节点的初始模式状态\nfPlaybackInNode = node-&gt;isInNode();\n// 如果节点已经在 Node 模式，则不允许回退到 Picture 模式\nfCanPlaybackInPicture = !fPlaybackInNode;\n}</code></pre>\n<p><strong>不可逆的原因</strong>：</p>\n<ol>\n<li><strong>状态锁定</strong>：一旦 <code>fDrawInPicture = false</code>，<code>fCanPlaybackInPicture</code> 也会被设为 <code>false</code></li>\n<li><strong>子节点依赖</strong>：Node 模式下可能已创建子节点，回退会破坏节点树结构</li>\n<li><strong>设计意图</strong>：避免频繁的模式切换带来的性能抖动</li>\n</ol>\n<pre><code>时间轴:\nT1: Picture 模式 (fDrawInPicture = true)\n│\n▼ 触发条件满足，切换到 Node 模式\nT2: Node 模式 (fDrawInPicture = false)\n│\n╳ 无法回退！fCanPlaybackInPicture = false\nT3: Node 模式 (fDrawInPicture = false)\n│\n▼\nT4: Node 模式 (永久保持)</code></pre>\n<h3><strong>5.6 pictureDraw vs nodeDraw</strong></h3>\n<pre><code>// Picture 模式：直接执行绘制命令\nuint64_t OHRenderNode::pictureDraw(OH_Drawing_Canvas *canvas, bool needCache) {\nif (fPictureCmd) {\n// 使用缓存的命令树（如果有）\nif (fPictureTreeCmdCache) {\nOHDrawingAPI::OH_Drawing_CanvasDrawRecordCmdNesting(\ncanvas, fPictureTreeCmdCache.get());\nreturn fPictureTreeHash;\n}\n// 执行自身命令\nOHDrawingAPI::OH_Drawing_CanvasDrawRecordCmdNesting(canvas,\nfPictureCmd.get());\n// 递归处理子节点\nfor (auto&amp; child : fChildList) {\nif (child-&gt;fVisible) {\nOH_Drawing_CanvasSave(canvas);\nOH_Drawing_CanvasConcatMatrix(canvas, child-&gt;fFatherMatrix);\nchild-&gt;pictureDraw(canvas, needCache);\nOH_Drawing_CanvasRestore(canvas);\n}\n}\n}\nreturn 0;\n}</code></pre>\n<pre><code>// Node 模式：通过 NodeImpl 执行绘制\nvoid OHRenderNode::nodeDraw(OH_Drawing_Canvas *oh_canvas) {\nif (fNodeImpl) {\nfNodeImpl-&gt;nodeDraw(oh_canvas, this);\n}\n}</code></pre>\n<hr />\n<h2><strong>第六部分：嵌套录制机制</strong></h2>\n<h3><strong>6.1 嵌套场景说明</strong></h3>\n<p>当 Compose UI 中存在嵌套的 <code>graphicsLayer</code> 时，会产生<strong>嵌套录制</strong>：</p>\n<pre><code>// Compose UI 嵌套结构示例\nBox(modifier = Modifier.graphicsLayer { /* Layer A */ }) {\nText(\"Header\")\nBox(modifier = Modifier.graphicsLayer { /* Layer B */ }) {\nImage(...)\nBox(modifier = Modifier.graphicsLayer { /* Layer C */ }) {\nText(\"Content\")\n}\n}\nText(\"Footer\")\n}</code></pre>\n<h3><strong>6.2 SubCanvas 机制</strong></h3>\n<p>OHRender 使用 <strong>SubCanvas（子画布）</strong> 机制处理嵌套录制：</p>\n<figure class=\"doc-figure\"><img src=\"../knowledge-map-assets/module-10d487ca-c4f3156183.png\" alt=\"指令录制与绘制机制 图示\" /></figure>\n<h3><strong>6.3 关键代码：beginSubCanvas 和 finishSubCanvas</strong></h3>\n<pre><code>// 文件: SkCanvas.cpp\n// 创建子画布\nvoid SkCanvas::beginSubCanvas(const SkRect&amp; bounds) {\n// 保存当前状态\nsave();\n// 创建子录制器\nfSubRecorder = new SkPictureRecorder();\n// 开始子录制\nfSubCanvas = fSubRecorder-&gt;beginRecording(bounds);\n// 传递当前变换矩阵到子画布\nfSubCanvas-&gt;concat(getTotalMatrix());\n}\n// 完成子画布录制\nvoid SkCanvas::finishSubCanvas() {\n// 1. 完成子录制，生成 Picture\nsk_sp&lt;SkPicture&gt; subPic = fSubRecorder-&gt;finishRecordingAsPicture();\n// 2. 保存到子 Picture 列表\nfSubPics.push_back(subPic);\n// 清理子画布\nfSubCanvas = nullptr;\nfSubRecorder = nullptr;\n// 🔥 3. 立即回放子 Picture！\nfIsPlayingBack = true;\nmarkSubPicPlayback(true);\nthis-&gt;drawPicture(subPic); // ← 触发 playback()\nmarkSubPicPlayback(false);\nfIsPlayingBack = false;\n// 4. 恢复状态\nrestore();\n}</code></pre>\n<h3><strong>6.4 嵌套录制的时序</strong></h3>\n<p><strong>关键点</strong>：子 Layer 的 Picture 在父 Layer 录制完成<strong>之前</strong>就已经回放完成。</p>\n<pre><code>时间轴:\nLayer A 录制\n┌─────────────────────────────────────────┐\n│ │\nT1 ──────▶│ beginRecording() │\n│ draw(\"Header\") │\n│ │\nT2 ──────▶│ ┌─── Layer B 录制 ───────────────────┐ │\n│ │ beginRecording() │ │\n│ │ draw(Image) │ │\n│ │ finishRecording() → Picture B │ │\nT3 ──────▶│ │ │ │\n│ │ playback(Picture B) ← 立即回放！ │ │\n│ └────────────────────────────────────┘ │\n│ │\nT4 ──────▶│ draw(\"Footer\") │\n│ finishRecording() → Picture A │\n└─────────────────────────────────────────┘</code></pre>\n<h3><strong>6.5 数据结构转化</strong></h3>\n<p>嵌套录制过程中，数据结构的转化关系：</p>\n<figure class=\"doc-figure\"><img src=\"../knowledge-map-assets/module-10d487ca-597bf05f1b.png\" alt=\"指令录制与绘制机制 图示\" /></figure>\n<h3><strong>6.6 嵌套场景的模式决策</strong></h3>\n<p>在嵌套场景中，模式决策会<strong>逐层独立进行</strong>：</p>\n<figure class=\"doc-figure\"><img src=\"../knowledge-map-assets/module-10d487ca-f316fbb35c.png\" alt=\"指令录制与绘制机制 图示\" /></figure>\n<hr />\n<h2><strong>第七部分：节点克隆与复用</strong></h2>\n<h3><strong>7.1 为什么需要节点克隆？</strong></h3>\n<p>在以下场景中，一个 Picture 可能需要多个 OHRenderNode：</p>\n<ol>\n<li><strong>过渡动画（Crossfade）</strong>：新旧内容同时显示</li>\n<li><strong>LazyList 复用</strong>：同一模板渲染多个 item</li>\n<li><strong>并发回放</strong>：多个线程同时回放同一 Picture</li>\n</ol>\n<h3><strong>7.2 节点管理结构</strong></h3>\n<pre><code>class SkOHPicture {\n// 原始节点（创建时关联）\nstd::shared_ptr&lt;OHRenderNode&gt; fOriginNode;\n// 当前使用的节点（回放时动态获取）\nmutable std::shared_ptr&lt;OHRenderNode&gt; fNowCacheNode;\n// 所有克隆节点的缓存列表\nmutable std::list&lt;std::shared_ptr&lt;OHRenderNode&gt;&gt; fCacheCloneNodes;\n// 未使用的克隆节点列表（复用池）\nmutable std::list&lt;std::shared_ptr&lt;OHRenderNode&gt;&gt; fUnusedCloneNodes;\n};</code></pre>\n<h3><strong>7.3 节点获取逻辑：generateNewNode()</strong></h3>\n<pre><code>// 文件: SkPictureRecorder.cpp\n​\nstd::shared_ptr&lt;OHRenderNode&gt; SkOHPicture::generateNewNode() const {\n// 🎯 优先级 1：从复用池获取\nif (!fUnusedCloneNodes.empty()) {\nauto node = fUnusedCloneNodes.front();\nfUnusedCloneNodes.pop_front();\nreturn node;\n}\n// 🎯 优先级 2：使用原始节点（如果未被使用）\nif (fOriginNode &amp;&amp; !fOriginNode-&gt;isInUse()) {\nfCacheCloneNodes.push_back(fOriginNode);\nreturn fOriginNode;\n}\n// 🎯 优先级 3：克隆新节点\nauto cloneNode = fOriginNode-&gt;makeClone();\nfCacheCloneNodes.push_back(cloneNode);\nreturn cloneNode;\n}</code></pre>\n<h3><strong>7.4 节点克隆实现：makeClone()</strong></h3>\n<pre><code>// 文件: OHRenderNode.cpp\n​\nstd::shared_ptr&lt;OHRenderNode&gt; OHRenderNode::makeClone() {\nauto clone = std::make_shared&lt;OHRenderNode&gt;();\n// 复制关键属性\nclone-&gt;fRealFrame = this-&gt;fRealFrame;\nclone-&gt;fNoLimitSize = this-&gt;fNoLimitSize;\n// 共享绘制命令（只读，不需要复制）\nclone-&gt;fPictureCmd = this-&gt;fPictureCmd;\n// 递归克隆子节点\nfor (auto&amp; child : fChildList) {\nauto childClone = child-&gt;makeClone();\nclone-&gt;appendChild(childClone);\n}\nreturn clone;\n}</code></pre>\n<h3><strong>7.5 节点生命周期管理</strong></h3>\n<figure class=\"doc-figure\"><img src=\"../knowledge-map-assets/module-10d487ca-aaa1148c25.png\" alt=\"指令录制与绘制机制 图示\" /></figure>\n<h3><strong>7.6 实际场景示例：Crossfade 动画</strong></h3>\n<pre><code>// Crossfade 动画会同时显示新旧内容\nCrossfade(targetState = currentScreen) { screen -&gt;\nwhen (screen) {\nScreen.A -&gt; ScreenA() // 旧内容\nScreen.B -&gt; ScreenB() // 新内容\n}\n}</code></pre>\n<p><strong>回放时的节点分配</strong>：</p>\n<pre><code>帧 N (过渡中):\nPicture (ScreenA)\n│\n┌───────────────┼───────────────┐\n│ │ │\nfOriginNode fCacheClone[0] fCacheClone[1]\n(alpha=0.7) (不使用) (alpha=0.3)\n│ │\n▼ ▼\n旧内容显示 新内容显示</code></pre>\n<hr />\n<h2><strong>第八部分：关键代码位置索引</strong></h2>\n<h3><strong>8.1 Kotlin 层（Compose UI）</strong></h3>\n<div class=\"doc-table-wrap\"><table class=\"doc-table\"><thead><tr><th>类/方法</th><th>文件路径</th><th>说明</th></tr></thead><tbody><tr><td>RenderNodeLayer</td><td>compose/ui/ui/src/skikoMain/kotlin/androidx/compose/ui/platform/RenderNodeLayer.skiko.kt</td><td>图层桥接类</td></tr><tr><td>drawLayer()</td><td>同上</td><td>图层绘制入口</td></tr><tr><td>performDrawLayer()</td><td>同上</td><td>执行绘制（阴影、裁剪、透明度）</td></tr><tr><td>invalidate()</td><td>同上</td><td>失效处理，清除缓存</td></tr></tbody></table></div>\n<h3><strong>8.2 C++ 层（OHRender）</strong></h3>\n<div class=\"doc-table-wrap\"><table class=\"doc-table\"><thead><tr><th>类/方法</th><th>文件路径</th><th>说明</th></tr></thead><tbody><tr><td>SkPictureRecorder</td><td>OHRender/src/core/SkPictureRecorder.cpp</td><td>命令录制器</td></tr><tr><td>beginRecording()</td><td>同上</td><td>开始录制</td></tr><tr><td>finishRecordingAsPicture()</td><td>同上</td><td>完成录制</td></tr><tr><td>SkOHPicture</td><td>同上</td><td>Picture 容器</td></tr><tr><td>playback()</td><td>同上</td><td>回放与模式决策</td></tr><tr><td>generateNewNode()</td><td>同上</td><td>节点获取/克隆</td></tr><tr><td>SkCanvas</td><td>OHRender/src/core/SkCanvas.cpp</td><td>绘制接口</td></tr><tr><td>beginSubCanvas()</td><td>同上</td><td>创建子画布</td></tr><tr><td>finishSubCanvas()</td><td>同上</td><td>完成子画布</td></tr><tr><td>getFinishDrawBounds()</td><td>同上</td><td>获取脏区边界</td></tr><tr><td>OHRenderNode</td><td>OHRender/src/oh/OHRenderNode.cpp</td><td>渲染节点</td></tr><tr><td>pictureDraw()</td><td>同上</td><td>Picture 模式绘制</td></tr><tr><td>nodeDraw()</td><td>同上</td><td>Node 模式绘制</td></tr><tr><td>makeClone()</td><td>同上</td><td>节点克隆</td></tr><tr><td>appendChild()</td><td>同上</td><td>添加子节点</td></tr></tbody></table></div>\n<h3><strong>8.3 头文件</strong></h3>\n<div class=\"doc-table-wrap\"><table class=\"doc-table\"><thead><tr><th>文件</th><th>路径</th><th>说明</th></tr></thead><tbody><tr><td>SkPictureRecorder.h</td><td>OHRender/include/core/SkPictureRecorder.h</td><td>录制器头文件</td></tr><tr><td>SkCanvas.h</td><td>OHRender/include/core/SkCanvas.h</td><td>画布头文件</td></tr><tr><td>SkPicture.h</td><td>OHRender/include/core/SkPicture.h</td><td>Picture 头文件</td></tr><tr><td>OHRenderNode.h</td><td>OHRender/include/oh/OHRenderNode.h</td><td>节点头文件</td></tr></tbody></table></div>\n<h3><strong>8.4 ArkTS 层</strong></h3>\n<div class=\"doc-table-wrap\"><table class=\"doc-table\"><thead><tr><th>类/方法</th><th>文件路径</th><th>说明</th></tr></thead><tbody><tr><td>CanvasNodeController</td><td>ui-arkui/src/ohosArm64Main/cpp/compose/src/main/ets/compose/CanvasNode.ets</td><td>Canvas 节点控制器</td></tr><tr><td>Compose 组件</td><td>同上</td><td>Compose 根组件</td></tr></tbody></table></div>\n<hr />\n<h2><strong>附录：核心数据结构速查</strong></h2>\n<h3><strong>RenderNodeLayer (Kotlin)</strong></h3>\n<pre><code>internal class RenderNodeLayer : OwnedLayer {\nprivate val pictureRecorder = PictureRecorder()\nprivate var picture: Picture? = null\ninternal val matrix = Matrix()\nprivate var alpha: Float = 1f\nprivate var clip: Boolean = false\nprivate var shadowElevation: Float = 0f\n}</code></pre>\n<h3><strong>SkOHPicture (C++)</strong></h3>\n<pre><code>class SkOHPicture final : public SkPicture {\nSkRect fCull;\nbool fNoLimitDraw;\nbool fPlaybackInNode;\nbool fCanPlaybackInPicture;\nOHDrawingRecordCmdSPtr fOHRecordCmd;\nstd::shared_ptr&lt;OHRenderNode&gt; fOriginNode;\nmutable std::shared_ptr&lt;OHRenderNode&gt; fNowCacheNode;\nmutable std::list&lt;std::shared_ptr&lt;OHRenderNode&gt;&gt; fCacheCloneNodes;\nstd::vector&lt;sk_sp&lt;SkPicture&gt;&gt; fSubPics;\n};</code></pre>\n<h3><strong>OHRenderNode (C++)</strong></h3>\n<pre><code>class OHRenderNode {\nint fNodeId;\nSkRect fRealFrame;\nSkMatrix fFatherMatrix;\nOH_Drawing_RecordCmd* fPictureCmd;\nstd::shared_ptr&lt;OHRenderNode&gt; fParent;\nstd::list&lt;std::shared_ptr&lt;OHRenderNode&gt;&gt; fChildList;\nbool fDrawInPicture = true;\nbool fVisible = true;\n};</code></pre>"
        }
      ],
      "estimated_minutes": 90
    },
    {
      "module_id": "kmp-f03735ca",
      "title": "KMP工程集成鸿蒙应用完整教程",
      "source_path": "environment-setup/KMP工程集成鸿蒙应用完整教程.md",
      "source_file_hash": "f03735ca19b9579673ce90f7db218b0f75f46067",
      "split_mode": "auto",
      "render_version": 11,
      "difficulty": 3,
      "summary": "本教程将详细介绍如何从零开始创建一个Kotlin Multiplatform (KMP) 工程，并集成鸿蒙(HarmonyOS)应用。",
      "sections": [
        {
          "section_id": "8cb4de0fa1",
          "title": "KMP工程集成鸿蒙应用完整教程",
          "summary": "本教程将详细介绍如何从零开始创建一个Kotlin Multiplatform (KMP) 工程，并集成鸿蒙(HarmonyOS)应用。",
          "key_points": [
            "本教程将详细介绍如何从零开始创建一个Kotlin Multiplatform (KMP) 工程，并集成鸿蒙(HarmonyOS)应用。"
          ],
          "estimated_minutes": 2,
          "content": "本教程将详细介绍如何从零开始创建一个Kotlin Multiplatform (KMP) 工程，并集成鸿蒙(HarmonyOS)应用。",
          "content_html": "<p>本教程将详细介绍如何从零开始创建一个Kotlin Multiplatform (KMP) 工程，并集成鸿蒙(HarmonyOS)应用。</p>"
        },
        {
          "section_id": "9a6d0c4426",
          "title": "1.1 环境要求",
          "summary": "Android Studio (支持KMP的最新版本) DevEco Studio (用于鸿蒙应用开发) JDK 11 或更高版本 Kotlin 2.2.0-ohos-07...",
          "key_points": [
            "Android Studio (支持KMP的最新版本)",
            "DevEco Studio (用于鸿蒙应用开发)",
            "JDK 11 或更高版本",
            "Kotlin 2.2.0-ohos-07 或兼容版本"
          ],
          "estimated_minutes": 2,
          "content": "- Android Studio (支持KMP的最新版本)\n- DevEco Studio (用于鸿蒙应用开发)\n- JDK 11 或更高版本\n- Kotlin 2.2.0-ohos-07 或兼容版本",
          "content_html": "<ul><li>Android Studio (支持KMP的最新版本)</li><li>DevEco Studio (用于鸿蒙应用开发)</li><li>JDK 11 或更高版本</li><li>Kotlin 2.2.0-ohos-07 或兼容版本</li></ul>"
        },
        {
          "section_id": "82f3376434",
          "title": "1.2 必要的依赖仓库",
          "summary": "KMP鸿蒙支持仓库: https://kmp-ohos-test.obs.cn-south-1.myhuaweicloud.com/maven/ 腾讯Maven仓库: htt...",
          "key_points": [
            "KMP鸿蒙支持仓库: https://kmp-ohos-test.obs.cn-south-1.myhuaweicloud.com/maven/",
            "腾讯Maven仓库: https://mirrors.tencent.com/nexus/repository/maven-tencent"
          ],
          "estimated_minutes": 2,
          "content": "- KMP鸿蒙支持仓库: `https://kmp-ohos-test.obs.cn-south-1.myhuaweicloud.com/maven/`\n- 腾讯Maven仓库: `https://mirrors.tencent.com/nexus/repository/maven-tencent`",
          "content_html": "<ul><li>KMP鸿蒙支持仓库: <code>https://kmp-ohos-test.obs.cn-south-1.myhuaweicloud.com/maven/</code></li><li>腾讯Maven仓库: <code>https://mirrors.tencent.com/nexus/repository/maven-tencent</code></li></ul>"
        },
        {
          "section_id": "13248251d0",
          "title": "2.1 使用Android Studio创建KMP项目",
          "summary": "新建工程入口.png 打开Android Studio 选择 **File** -> **New** -> **New Project** 选择 **Kotlin Multi...",
          "key_points": [
            "新建工程入口.png",
            "打开Android Studio",
            "选择 **File** -> **New** -> **New Project**",
            "选择 **Kotlin Multiplatform** 模板"
          ],
          "estimated_minutes": 2,
          "content": "![新建工程入口.png](./1.png)\n\n1. 打开Android Studio\n2. 选择 **File** -> **New** -> **New Project**\n3. 选择 **Kotlin Multiplatform** 模板\n\n![选择KMP项目.png](./2.png)",
          "content_html": "<figure class=\"doc-figure\"><img src=\"../knowledge-map-assets/kmp-f03735ca-md-3488ef63ac.png\" alt=\"新建工程入口.png\" loading=\"lazy\" referrerpolicy=\"no-referrer\" data-origin-src=\"../knowledge-map-assets/kmp-f03735ca-md-3488ef63ac.png\" data-local-match=\"direct\" /><figcaption class=\"img-fallback\">图片加载失败，<a class=\"img-open-link\" href=\"../knowledge-map-assets/kmp-f03735ca-md-3488ef63ac.png\" target=\"_blank\" rel=\"noopener noreferrer\">点击打开原图</a></figcaption></figure><ol><li>打开Android Studio</li><li>选择 <strong>File</strong> -&gt; <strong>New</strong> -&gt; <strong>New Project</strong></li><li>选择 <strong>Kotlin Multiplatform</strong> 模板</li></ol><figure class=\"doc-figure\"><img src=\"../knowledge-map-assets/kmp-f03735ca-md-22531d041d.png\" alt=\"选择KMP项目.png\" loading=\"lazy\" referrerpolicy=\"no-referrer\" data-origin-src=\"../knowledge-map-assets/kmp-f03735ca-md-22531d041d.png\" data-local-match=\"direct\" /><figcaption class=\"img-fallback\">图片加载失败，<a class=\"img-open-link\" href=\"../knowledge-map-assets/kmp-f03735ca-md-22531d041d.png\" target=\"_blank\" rel=\"noopener noreferrer\">点击打开原图</a></figcaption></figure>"
        },
        {
          "section_id": "cecbfc2855",
          "title": "2.2 配置工程基本信息",
          "summary": "修改工程名和包名.png 配置项说明： **Name**: MyKMPApp (工程名称) **Package name**: com.example.mykmpapp (包...",
          "key_points": [
            "修改工程名和包名.png",
            "配置项说明：",
            "**Name**: MyKMPApp (工程名称)",
            "**Package name**: com.example.mykmpapp (包名)"
          ],
          "estimated_minutes": 2,
          "content": "![修改工程名和包名.png](./3.png)\n配置项说明：\n- **Name**: MyKMPApp (工程名称)\n- **Package name**: com.example.mykmpapp (包名)\n- **Save location**: 选择合适的保存位置\n\n![选择平台一般默认.png](./4.png)",
          "content_html": "<figure class=\"doc-figure\"><img src=\"../knowledge-map-assets/kmp-f03735ca-md-7d9215a96c.png\" alt=\"修改工程名和包名.png\" loading=\"lazy\" referrerpolicy=\"no-referrer\" data-origin-src=\"../knowledge-map-assets/kmp-f03735ca-md-7d9215a96c.png\" data-local-match=\"direct\" /><figcaption class=\"img-fallback\">图片加载失败，<a class=\"img-open-link\" href=\"../knowledge-map-assets/kmp-f03735ca-md-7d9215a96c.png\" target=\"_blank\" rel=\"noopener noreferrer\">点击打开原图</a></figcaption></figure><p>配置项说明：</p><ul><li><strong>Name</strong>: MyKMPApp (工程名称)</li><li><strong>Package name</strong>: com.example.mykmpapp (包名)</li><li><strong>Save location</strong>: 选择合适的保存位置</li></ul><figure class=\"doc-figure\"><img src=\"../knowledge-map-assets/kmp-f03735ca-md-575ace531d.png\" alt=\"选择平台一般默认.png\" loading=\"lazy\" referrerpolicy=\"no-referrer\" data-origin-src=\"../knowledge-map-assets/kmp-f03735ca-md-575ace531d.png\" data-local-match=\"direct\" /><figcaption class=\"img-fallback\">图片加载失败，<a class=\"img-open-link\" href=\"../knowledge-map-assets/kmp-f03735ca-md-575ace531d.png\" target=\"_blank\" rel=\"noopener noreferrer\">点击打开原图</a></figcaption></figure>"
        },
        {
          "section_id": "5248c50029",
          "title": "2.3 选择目标平台",
          "summary": "默认情况下会包含： Android iOS 注意：鸿蒙平台需要后续手动配置",
          "key_points": [
            "默认情况下会包含：",
            "Android",
            "iOS",
            "注意：鸿蒙平台需要后续手动配置"
          ],
          "estimated_minutes": 2,
          "content": "默认情况下会包含：\n- Android\n- iOS\n\n> 注意：鸿蒙平台需要后续手动配置",
          "content_html": "<p>默认情况下会包含：</p><ul><li>Android</li><li>iOS</li></ul><blockquote><p>注意：鸿蒙平台需要后续手动配置</p></blockquote>"
        },
        {
          "section_id": "af7085cfbb",
          "title": "3.1 配置Gradle依赖仓库",
          "summary": "修改 settings.gradle.kts 文件，添加鸿蒙相关的Maven仓库： kotlin pluginManagement { repositories { mave...",
          "key_points": [
            "修改 settings.gradle.kts 文件，添加鸿蒙相关的Maven仓库：",
            "kotlin",
            "pluginManagement {",
            "repositories {"
          ],
          "estimated_minutes": 2,
          "content": "修改 `settings.gradle.kts` 文件，添加鸿蒙相关的Maven仓库：\n\n```kotlin\npluginManagement {\n    repositories {\n        maven(\"https://kmp-ohos-test.obs.cn-south-1.myhuaweicloud.com/maven/\")\n        maven(\"https://mirrors.tencent.com/nexus/repository/maven-tencent\")\n        google {\n            mavenContent {\n                includeGroupAndSubgroups(\"androidx\")\n                includeGroupAndSubgroups(\"com.android\")\n                includeGroupAndSubgroups(\"com.google\")\n            }\n        }\n        mavenCentral()\n        gradlePluginPortal()\n    }\n}\n\ndependencyResolutionManagement {\n    repositories {\n        maven(\"https://kmp-ohos-test.obs.cn-south-1.myhuaweicloud.com/maven/\")\n        maven(\"https://mirrors.tencent.com/nexus/repository/maven-tencent\")\n        google {\n            mavenContent {\n                includeGroupAndSubgroups(\"androidx\")\n                includeGroupAndSubgroups(\"com.android\")\n                includeGroupAndSubgroups(\"com.google\")\n            }\n        }\n        mavenCentral()\n    }\n}\n```",
          "content_html": "<p>修改 <code>settings.gradle.kts</code> 文件，添加鸿蒙相关的Maven仓库：</p><pre><code class=\"language-kotlin\">pluginManagement {\n    repositories {\n        maven(\"https://kmp-ohos-test.obs.cn-south-1.myhuaweicloud.com/maven/\")\n        maven(\"https://mirrors.tencent.com/nexus/repository/maven-tencent\")\n        google {\n            mavenContent {\n                includeGroupAndSubgroups(\"androidx\")\n                includeGroupAndSubgroups(\"com.android\")\n                includeGroupAndSubgroups(\"com.google\")\n            }\n        }\n        mavenCentral()\n        gradlePluginPortal()\n    }\n}\n\ndependencyResolutionManagement {\n    repositories {\n        maven(\"https://kmp-ohos-test.obs.cn-south-1.myhuaweicloud.com/maven/\")\n        maven(\"https://mirrors.tencent.com/nexus/repository/maven-tencent\")\n        google {\n            mavenContent {\n                includeGroupAndSubgroups(\"androidx\")\n                includeGroupAndSubgroups(\"com.android\")\n                includeGroupAndSubgroups(\"com.google\")\n            }\n        }\n        mavenCentral()\n    }\n}</code></pre>"
        },
        {
          "section_id": "ed1709abae",
          "title": "3.2 配置版本依赖",
          "summary": "修改 gradle/libs.versions.toml 文件，配置鸿蒙相关的版本。**关键配置**如下（其他AndroidX库使用默认配置即可）： toml [versio...",
          "key_points": [
            "修改 gradle/libs.versions.toml 文件，配置鸿蒙相关的版本。**关键配置**如下（其他AndroidX库使用默认配置即可）：",
            "toml",
            "[versions]",
            "composeMultiplatform = \"1.6.1-ohos-003\""
          ],
          "estimated_minutes": 4,
          "content": "修改 `gradle/libs.versions.toml` 文件，配置鸿蒙相关的版本。**关键配置**如下（其他AndroidX库使用默认配置即可）：\n\n```toml\n[versions]\ncomposeMultiplatform = \"1.6.1-ohos-003\"\nkotlin = \"2.2.0-ohos-07\"\natomicFu = \"0.23.2-KBA-001\"\nkotlinx-coroutines = \"1.8.0-KBA-001\"\n\n[libraries]\nandroidx-activity-compose = { module = \"androidx.activity:activity-compose\", version.ref = \"androidx-activity\" }\ncompose-multiplatform-export = { module = \"org.jetbrains.compose.export:export\", version.ref = \"composeMultiplatform\" }\natomicFu = { module = \"org.jetbrains.kotlinx:atomicfu\", version.ref = \"atomicFu\" }\nkotlinx-coroutines-core = { module = \"org.jetbrains.kotlinx:kotlinx-coroutines-core\", version.ref = \"kotlinx-coroutines\" }\n\n[plugins]\ncomposeMultiplatform = { id = \"org.jetbrains.compose\", version.ref = \"composeMultiplatform\" }\ncomposeCompiler = { id = \"org.jetbrains.kotlin.plugin.compose\", version.ref = \"kotlin\" }\nkotlinMultiplatform = { id = \"org.jetbrains.kotlin.multiplatform\", version.ref = \"kotlin\" }\n```\n\n**关键版本说明**：\n- `kotlin = \"2.2.0-ohos-07\"`: 支持鸿蒙的Kotlin版本（**必须使用此版本**）\n- `composeMultiplatform = \"1.6.1-ohos-003\"`: 支持鸿蒙的Compose Multiplatform版本（**必须使用此版本**）\n- `atomicFu = \"0.23.2-KBA-001\"`: KMP原子操作库，用于跨平台原子性操作\n- `kotlinx-coroutines = \"1.8.0-KBA-001\"`: 跨平台协程库\n- 注意：`composeMultiplatform` 使用驼峰命名，在引用时使用 `version.ref = \"composeMultiplatform\"`",
          "content_html": "<p>修改 <code>gradle/libs.versions.toml</code> 文件，配置鸿蒙相关的版本。<strong>关键配置</strong>如下（其他AndroidX库使用默认配置即可）：</p><pre><code class=\"language-toml\">[versions]\ncomposeMultiplatform = \"1.6.1-ohos-003\"\nkotlin = \"2.2.0-ohos-07\"\natomicFu = \"0.23.2-KBA-001\"\nkotlinx-coroutines = \"1.8.0-KBA-001\"\n\n[libraries]\nandroidx-activity-compose = { module = \"androidx.activity:activity-compose\", version.ref = \"androidx-activity\" }\ncompose-multiplatform-export = { module = \"org.jetbrains.compose.export:export\", version.ref = \"composeMultiplatform\" }\natomicFu = { module = \"org.jetbrains.kotlinx:atomicfu\", version.ref = \"atomicFu\" }\nkotlinx-coroutines-core = { module = \"org.jetbrains.kotlinx:kotlinx-coroutines-core\", version.ref = \"kotlinx-coroutines\" }\n\n[plugins]\ncomposeMultiplatform = { id = \"org.jetbrains.compose\", version.ref = \"composeMultiplatform\" }\ncomposeCompiler = { id = \"org.jetbrains.kotlin.plugin.compose\", version.ref = \"kotlin\" }\nkotlinMultiplatform = { id = \"org.jetbrains.kotlin.multiplatform\", version.ref = \"kotlin\" }</code></pre><p><strong>关键版本说明</strong>：</p><ul><li><code>kotlin = \"2.2.0-ohos-07\"</code>: 支持鸿蒙的Kotlin版本（<strong>必须使用此版本</strong>）</li><li><code>composeMultiplatform = \"1.6.1-ohos-003\"</code>: 支持鸿蒙的Compose Multiplatform版本（<strong>必须使用此版本</strong>）</li><li><code>atomicFu = \"0.23.2-KBA-001\"</code>: KMP原子操作库，用于跨平台原子性操作</li><li><code>kotlinx-coroutines = \"1.8.0-KBA-001\"</code>: 跨平台协程库</li><li>注意：<code>composeMultiplatform</code> 使用驼峰命名，在引用时使用 <code>version.ref = \"composeMultiplatform\"</code></li></ul>"
        },
        {
          "section_id": "8c3521abc8",
          "title": "3.3 配置composeApp模块",
          "summary": "修改 composeApp/build.gradle.kts，添加鸿蒙平台配置： kotlin kotlin { androidTarget { compilerOption...",
          "key_points": [
            "修改 composeApp/build.gradle.kts，添加鸿蒙平台配置：",
            "kotlin",
            "kotlin {",
            "androidTarget {"
          ],
          "estimated_minutes": 6,
          "content": "修改 `composeApp/build.gradle.kts`，添加鸿蒙平台配置：\n\n```kotlin\nkotlin {\n    androidTarget {\n        compilerOptions {\n            jvmTarget.set(JvmTarget.JVM_11)\n        }\n    }\n    \n    listOf(\n        iosArm64(),\n        iosSimulatorArm64()\n    ).forEach { iosTarget ->\n        iosTarget.binaries.framework {\n            baseName = \"ComposeApp\"\n            isStatic = true\n        }\n    }\n\n    // 添加鸿蒙平台配置\n    ohosArm64 {\n        binaries.sharedLib {\n            baseName = \"kn\"\n            export(libs.compose.multiplatform.export)\n            linkerOpts(\n                \"-lnative_drawing\",\n                \"-lpixelmap\",\n                \"-lpixelmap_ndk.z\",\n                \"-lace_napi.z\",\n                \"-lhilog_ndk.z\",\n                \"-limage_source\",\n                \"-lhitrace_ndk.z\",\n                \"-luv\",\n                \"-lnative_window\",\n                \"-lunwind\",\n            )\n            // debug和release模式都打包带符号表的so\n            debuggable = true\n        }\n        compilations.all {\n            compilerOptions.configure {\n            }\n        }\n\n        // 配置cinterop用于访问鸿蒙资源\n        val main by compilations.getting\n        val resource by main.cinterops.creating {\n            defFile(file(\"src/ohosArm64Main/cinterop/resource.def\"))\n            includeDirs(file(\"src/ohosArm64Main/cinterop/include\"))\n        }\n    }\n    \n    sourceSets {\n        androidMain.dependencies {\n            implementation(compose.preview)\n            implementation(libs.androidx.activity.compose)\n        }\n        commonMain.dependencies {\n            implementation(compose.runtime)\n            implementation(compose.foundation)\n            implementation(compose.material3)\n            implementation(compose.ui)\n            implementation(compose.components.resources)\n            implementation(compose.components.uiToolingPreview)\n            implementation(libs.kotlinx.coroutines.core)\n            implementation(libs.atomicFu)\n        }\n\n        // 鸿蒙平台依赖\n        val ohosArm64Main by getting {\n            dependencies {\n                api(libs.compose.multiplatform.export)\n            }\n        }\n    }\n}\n\n// 配置自动发布任务\narrayOf(\"debug\", \"release\").forEach { type ->\n    tasks.register<Copy>(\"publish${type.capitalizeUS()}BinariesToHarmonyApp\") {\n        group = \"harmony\"\n        dependsOn(\"link${type.capitalizeUS()}SharedOhosArm64\")\n        into(rootProject.file(\"harmonyApp\"))\n        from(\"build/bin/ohosArm64/${type}Shared/libkn_api.h\") {\n            into(\"entry/src/main/cpp/include/\")\n        }\n        from(project.file(\"build/bin/ohosArm64/${type}Shared/libkn.so\")) {\n            into(\"/entry/libs/arm64-v8a/\")\n        }\n    }\n}\n```\n\n**关键配置说明**：\n- `ohosArm64`: 声明鸿蒙平台目标\n- `sharedLib`: 生成共享库(.so文件)\n- `baseName = \"kn\"`: 生成的so文件名为libkn.so\n- `linkerOpts`: 链接鸿蒙NDK库\n- `cinterops`: 配置C互操作，用于访问鸿蒙资源管理器",
          "content_html": "<p>修改 <code>composeApp/build.gradle.kts</code>，添加鸿蒙平台配置：</p><pre><code class=\"language-kotlin\">kotlin {\n    androidTarget {\n        compilerOptions {\n            jvmTarget.set(JvmTarget.JVM_11)\n        }\n    }\n    \n    listOf(\n        iosArm64(),\n        iosSimulatorArm64()\n    ).forEach { iosTarget -&gt;\n        iosTarget.binaries.framework {\n            baseName = \"ComposeApp\"\n            isStatic = true\n        }\n    }\n\n    // 添加鸿蒙平台配置\n    ohosArm64 {\n        binaries.sharedLib {\n            baseName = \"kn\"\n            export(libs.compose.multiplatform.export)\n            linkerOpts(\n                \"-lnative_drawing\",\n                \"-lpixelmap\",\n                \"-lpixelmap_ndk.z\",\n                \"-lace_napi.z\",\n                \"-lhilog_ndk.z\",\n                \"-limage_source\",\n                \"-lhitrace_ndk.z\",\n                \"-luv\",\n                \"-lnative_window\",\n                \"-lunwind\",\n            )\n            // debug和release模式都打包带符号表的so\n            debuggable = true\n        }\n        compilations.all {\n            compilerOptions.configure {\n            }\n        }\n\n        // 配置cinterop用于访问鸿蒙资源\n        val main by compilations.getting\n        val resource by main.cinterops.creating {\n            defFile(file(\"src/ohosArm64Main/cinterop/resource.def\"))\n            includeDirs(file(\"src/ohosArm64Main/cinterop/include\"))\n        }\n    }\n    \n    sourceSets {\n        androidMain.dependencies {\n            implementation(compose.preview)\n            implementation(libs.androidx.activity.compose)\n        }\n        commonMain.dependencies {\n            implementation(compose.runtime)\n            implementation(compose.foundation)\n            implementation(compose.material3)\n            implementation(compose.ui)\n            implementation(compose.components.resources)\n            implementation(compose.components.uiToolingPreview)\n            implementation(libs.kotlinx.coroutines.core)\n            implementation(libs.atomicFu)\n        }\n\n        // 鸿蒙平台依赖\n        val ohosArm64Main by getting {\n            dependencies {\n                api(libs.compose.multiplatform.export)\n            }\n        }\n    }\n}\n\n// 配置自动发布任务\narrayOf(\"debug\", \"release\").forEach { type -&gt;\n    tasks.register&lt;Copy&gt;(\"publish${type.capitalizeUS()}BinariesToHarmonyApp\") {\n        group = \"harmony\"\n        dependsOn(\"link${type.capitalizeUS()}SharedOhosArm64\")\n        into(rootProject.file(\"harmonyApp\"))\n        from(\"build/bin/ohosArm64/${type}Shared/libkn_api.h\") {\n            into(\"entry/src/main/cpp/include/\")\n        }\n        from(project.file(\"build/bin/ohosArm64/${type}Shared/libkn.so\")) {\n            into(\"/entry/libs/arm64-v8a/\")\n        }\n    }\n}</code></pre><p><strong>关键配置说明</strong>：</p><ul><li><code>ohosArm64</code>: 声明鸿蒙平台目标</li><li><code>sharedLib</code>: 生成共享库(.so文件)</li><li><code>baseName = \"kn\"</code>: 生成的so文件名为libkn.so</li><li><code>linkerOpts</code>: 链接鸿蒙NDK库</li><li><code>cinterops</code>: 配置C互操作，用于访问鸿蒙资源管理器</li></ul>"
        },
        {
          "section_id": "37d51909b1",
          "title": "3.4 创建鸿蒙平台代码",
          "summary": "3.4.1 创建目录结构 composeApp/src/ohosArm64Main/ ├── cinterop/ │ ├── include/ │ │ ├── raw_fil...",
          "key_points": [
            "3.4.1 创建目录结构",
            "composeApp/src/ohosArm64Main/",
            "├── cinterop/",
            "│ ├── include/"
          ],
          "estimated_minutes": 6,
          "content": "#### 3.4.1 创建目录结构\n\n```\ncomposeApp/src/ohosArm64Main/\n├── cinterop/\n│   ├── include/\n│   │   ├── raw_file.h\n│   │   └── raw_file_manager.h\n│   └── resource.def\n└── kotlin/\n    └── com/example/mykmpapp/\n        ├── App.ohos.kt\n        ├── MainArkUIViewController.kt\n        └── Platform.ohos.kt\n```\n\n#### 3.4.2 配置cinterop\n\n创建 `composeApp/src/ohosArm64Main/cinterop/resource.def`:\n\n```\npackage = platform.resource\nheaders = raw_file_manager.h raw_file.h\n```\n\n#### 3.4.3 实现平台特定代码\n\n创建 `composeApp/src/ohosArm64Main/kotlin/com/example/mykmpapp/Platform.ohos.kt`:\n\n```kotlin\npackage com.example.mykmpapp\n\nimport kotlinx.cinterop.ExperimentalForeignApi\nimport kotlinx.cinterop.toKString\nimport platform.ohos.OH_GetOSFullName\n\ninternal class OHOSPlatform : Platform {\n    @OptIn(ExperimentalForeignApi::class)\n    override val name: String = \"OHOS\"\n}\n\nactual fun getPlatform(): Platform = OHOSPlatform()\n```\n\n创建 `composeApp/src/ohosArm64Main/kotlin/com/example/mykmpapp/MainArkUIViewController.kt`:\n\n```kotlin\n@file:OptIn(ExperimentalForeignApi::class)\n\npackage com.example.mykmpapp\n\nimport androidx.compose.ui.window.ComposeArkUIViewController\nimport kotlinx.cinterop.CPointer\nimport kotlinx.cinterop.ExperimentalForeignApi\nimport kotlinx.coroutines.initMainHandler\nimport platform.ohos.napi_env\nimport platform.ohos.napi_value\nimport kotlin.experimental.ExperimentalNativeApi\n\n@OptIn(ExperimentalNativeApi::class)\n@CName(\"MainArkUIViewController\")\nfun MainArkUIViewController(env: napi_env): napi_value {\n    initMainHandler(env)\n    return ComposeArkUIViewController(env) {\n        App()\n    }\n}\n\ntypealias NativeResourceManager = CPointer<cnames.structs.NativeResourceManager>?\nvar nativeResourceManager: NativeResourceManager = null\n\n@OptIn(ExperimentalForeignApi::class)\nfun initResourceManager(resourceManager: NativeResourceManager) {\n    nativeResourceManager = resourceManager\n}\n```\n\n**关键代码说明**：\n- `@CName(\"MainArkUIViewController\")`: 导出C函数供鸿蒙调用\n- `ComposeArkUIViewController`: 创建Compose ArkUI视图控制器\n- `initMainHandler`: 初始化协程主线程处理器\n- `initResourceManager`: 初始化资源管理器",
          "content_html": "<h4>3.4.1 创建目录结构</h4><pre><code>composeApp/src/ohosArm64Main/\n├── cinterop/\n│   ├── include/\n│   │   ├── raw_file.h\n│   │   └── raw_file_manager.h\n│   └── resource.def\n└── kotlin/\n    └── com/example/mykmpapp/\n        ├── App.ohos.kt\n        ├── MainArkUIViewController.kt\n        └── Platform.ohos.kt</code></pre><h4>3.4.2 配置cinterop</h4><p>创建 <code>composeApp/src/ohosArm64Main/cinterop/resource.def</code>:</p><pre><code>package = platform.resource\nheaders = raw_file_manager.h raw_file.h</code></pre><h4>3.4.3 实现平台特定代码</h4><p>创建 <code>composeApp/src/ohosArm64Main/kotlin/com/example/mykmpapp/Platform.ohos.kt</code>:</p><pre><code class=\"language-kotlin\">package com.example.mykmpapp\n\nimport kotlinx.cinterop.ExperimentalForeignApi\nimport kotlinx.cinterop.toKString\nimport platform.ohos.OH_GetOSFullName\n\ninternal class OHOSPlatform : Platform {\n    @OptIn(ExperimentalForeignApi::class)\n    override val name: String = \"OHOS\"\n}\n\nactual fun getPlatform(): Platform = OHOSPlatform()</code></pre><p>创建 <code>composeApp/src/ohosArm64Main/kotlin/com/example/mykmpapp/MainArkUIViewController.kt</code>:</p><pre><code class=\"language-kotlin\">@file:OptIn(ExperimentalForeignApi::class)\n\npackage com.example.mykmpapp\n\nimport androidx.compose.ui.window.ComposeArkUIViewController\nimport kotlinx.cinterop.CPointer\nimport kotlinx.cinterop.ExperimentalForeignApi\nimport kotlinx.coroutines.initMainHandler\nimport platform.ohos.napi_env\nimport platform.ohos.napi_value\nimport kotlin.experimental.ExperimentalNativeApi\n\n@OptIn(ExperimentalNativeApi::class)\n@CName(\"MainArkUIViewController\")\nfun MainArkUIViewController(env: napi_env): napi_value {\n    initMainHandler(env)\n    return ComposeArkUIViewController(env) {\n        App()\n    }\n}\n\ntypealias NativeResourceManager = CPointer&lt;cnames.structs.NativeResourceManager&gt;?\nvar nativeResourceManager: NativeResourceManager = null\n\n@OptIn(ExperimentalForeignApi::class)\nfun initResourceManager(resourceManager: NativeResourceManager) {\n    nativeResourceManager = resourceManager\n}</code></pre><p><strong>关键代码说明</strong>：</p><ul><li><code>@CName(\"MainArkUIViewController\")</code>: 导出C函数供鸿蒙调用</li><li><code>ComposeArkUIViewController</code>: 创建Compose ArkUI视图控制器</li><li><code>initMainHandler</code>: 初始化协程主线程处理器</li><li><code>initResourceManager</code>: 初始化资源管理器</li></ul>"
        },
        {
          "section_id": "ccc99c0b45",
          "title": "4.1 使用DevEco Studio创建Native工程",
          "summary": "DevecoStudio新建工程入口.png 打开DevEco Studio 选择 **File** -> **New** -> **Create Project** Dev...",
          "key_points": [
            "DevecoStudio新建工程入口.png",
            "打开DevEco Studio",
            "选择 **File** -> **New** -> **Create Project**",
            "DevecoStudio新建Native工程.png"
          ],
          "estimated_minutes": 2,
          "content": "![DevecoStudio新建工程入口.png](./5.png)\n1. 打开DevEco Studio\n2. 选择 **File** -> **New** -> **Create Project**\n\n![DevecoStudio新建Native工程.png](./6.png)\n3. 选择 **Native C++** 模板\n\n![DevecoStudio新建相同包名的Native应用.png](./7.png)\n4. 配置应用信息：\n   - **Project name**: harmonyApp\n   - **Bundle name**: com.example.mykmpapp (与KMP工程包名一致)",
          "content_html": "<figure class=\"doc-figure\"><img src=\"../knowledge-map-assets/kmp-f03735ca-md-93db0f5d92.png\" alt=\"DevecoStudio新建工程入口.png\" loading=\"lazy\" referrerpolicy=\"no-referrer\" data-origin-src=\"../knowledge-map-assets/kmp-f03735ca-md-93db0f5d92.png\" data-local-match=\"direct\" /><figcaption class=\"img-fallback\">图片加载失败，<a class=\"img-open-link\" href=\"../knowledge-map-assets/kmp-f03735ca-md-93db0f5d92.png\" target=\"_blank\" rel=\"noopener noreferrer\">点击打开原图</a></figcaption></figure><ol><li>打开DevEco Studio</li><li>选择 <strong>File</strong> -&gt; <strong>New</strong> -&gt; <strong>Create Project</strong></li></ol><figure class=\"doc-figure\"><img src=\"../knowledge-map-assets/kmp-f03735ca-md-f04a02834d.png\" alt=\"DevecoStudio新建Native工程.png\" loading=\"lazy\" referrerpolicy=\"no-referrer\" data-origin-src=\"../knowledge-map-assets/kmp-f03735ca-md-f04a02834d.png\" data-local-match=\"direct\" /><figcaption class=\"img-fallback\">图片加载失败，<a class=\"img-open-link\" href=\"../knowledge-map-assets/kmp-f03735ca-md-f04a02834d.png\" target=\"_blank\" rel=\"noopener noreferrer\">点击打开原图</a></figcaption></figure><ol><li>选择 <strong>Native C++</strong> 模板</li></ol><figure class=\"doc-figure\"><img src=\"../knowledge-map-assets/kmp-f03735ca-md-a92530d48e.png\" alt=\"DevecoStudio新建相同包名的Native应用.png\" loading=\"lazy\" referrerpolicy=\"no-referrer\" data-origin-src=\"../knowledge-map-assets/kmp-f03735ca-md-a92530d48e.png\" data-local-match=\"direct\" /><figcaption class=\"img-fallback\">图片加载失败，<a class=\"img-open-link\" href=\"../knowledge-map-assets/kmp-f03735ca-md-a92530d48e.png\" target=\"_blank\" rel=\"noopener noreferrer\">点击打开原图</a></figcaption></figure><ol><li>配置应用信息：<ul><li><strong>Project name</strong>: harmonyApp</li><li><strong>Bundle name</strong>: com.example.mykmpapp (与KMP工程包名一致)</li></ul></li></ol>"
        },
        {
          "section_id": "22d3771d7e",
          "title": "4.2 复制鸿蒙工程到KMP项目",
          "summary": "复制harmonyApp至kmpApp.png 将创建好的 harmonyApp 目录复制到KMP工程根目录下。",
          "key_points": [
            "复制harmonyApp至kmpApp.png",
            "将创建好的 harmonyApp 目录复制到KMP工程根目录下。"
          ],
          "estimated_minutes": 2,
          "content": "![复制harmonyApp至kmpApp.png](./8.png)\n将创建好的 `harmonyApp` 目录复制到KMP工程根目录下。",
          "content_html": "<figure class=\"doc-figure\"><img src=\"../knowledge-map-assets/kmp-f03735ca-md-9ad9e21275.png\" alt=\"复制harmonyApp至kmpApp.png\" loading=\"lazy\" referrerpolicy=\"no-referrer\" data-origin-src=\"../knowledge-map-assets/kmp-f03735ca-md-9ad9e21275.png\" data-local-match=\"direct\" /><figcaption class=\"img-fallback\">图片加载失败，<a class=\"img-open-link\" href=\"../knowledge-map-assets/kmp-f03735ca-md-9ad9e21275.png\" target=\"_blank\" rel=\"noopener noreferrer\">点击打开原图</a></figcaption></figure><p>将创建好的 <code>harmonyApp</code> 目录复制到KMP工程根目录下。</p>"
        },
        {
          "section_id": "3289da4fd8",
          "title": "4.3 使用Patch快速集成（推荐）",
          "summary": "**重要提示**：为了简化集成流程，我们提供了一个完整的patch文件，包含了所有必要的修改。",
          "key_points": [
            "**重要提示**：为了简化集成流程，我们提供了一个完整的patch文件，包含了所有必要的修改。",
            "**Patch文件**：📎 KMP应用集成鸿蒙应用必要修改.patch （点击可直接打开查看）",
            "**使用方法**：",
            "**方式一：直接应用Patch（推荐）**"
          ],
          "estimated_minutes": 2,
          "content": "**重要提示**：为了简化集成流程，我们提供了一个完整的patch文件，包含了所有必要的修改。\n\n**Patch文件**：[📎 KMP应用集成鸿蒙应用必要修改.patch](KMP应用集成鸿蒙应用必要修改.patch) （点击可直接打开查看）\n\n**使用方法**：\n\n1. **方式一：直接应用Patch（推荐）**\n   ```bash\n   # 在KMP工程根目录执行\n   git apply KMP应用集成鸿蒙应用必要修改.patch\n   ```\n   \n   或者使用完整路径：\n   ```bash\n   git apply \"KMP应用集成鸿蒙应用必要修改.patch\"\n   ```\n\n2. **方式二：手动配置**\n   如果您想了解每个修改的详细内容，可以按照第五节的详细说明逐步配置。\n\n**Patch包含的修改内容**：\n- ✅ KMP工程配置（`settings.gradle.kts`, `gradle/libs.versions.toml`, `composeApp/build.gradle.kts`）\n- ✅ 鸿蒙平台代码（`Platform.ohos.kt`, `MainArkUIViewController.kt`, `App.ohos.kt`）\n- ✅ C互操作配置（`resource.def`, `raw_file.h`, `raw_file_manager.h`）\n- ✅ 鸿蒙应用配置（`build-profile.json5`, `oh-package.json5`, `CMakeLists.txt`）\n- ✅ NAPI桥接代码（`napi_init.cpp`）\n- ✅ ArkTS页面代码（`Index.ets`, `ComposeSample.ets`, `ComposeInterops.ets`）\n- ✅ Compose支持库（`compose.har`）\n\n> **注意**：应用patch后，您可以直接跳到第六节\"编译和运行\"进行验证。如果您想了解每个配置的详细说明，可以继续阅读第五节。",
          "content_html": "<p><strong>重要提示</strong>：为了简化集成流程，我们提供了一个完整的patch文件，包含了所有必要的修改。</p><p><strong>Patch文件</strong>：<a href=\"KMP应用集成鸿蒙应用必要修改.patch\" target=\"_blank\" rel=\"noopener noreferrer\">📎 KMP应用集成鸿蒙应用必要修改.patch</a> （点击可直接打开查看）</p><p><strong>使用方法</strong>：</p><ol><li><strong>方式一：直接应用Patch（推荐）</strong></li></ol><pre><code class=\"language-bash\">   # 在KMP工程根目录执行\n   git apply KMP应用集成鸿蒙应用必要修改.patch</code></pre><p>或者使用完整路径：</p><pre><code class=\"language-bash\">   git apply \"KMP应用集成鸿蒙应用必要修改.patch\"</code></pre><ol><li><strong>方式二：手动配置</strong></li></ol><p>如果您想了解每个修改的详细内容，可以按照第五节的详细说明逐步配置。</p><p><strong>Patch包含的修改内容</strong>：</p><ul><li>✅ KMP工程配置（<code>settings.gradle.kts</code>, <code>gradle/libs.versions.toml</code>, <code>composeApp/build.gradle.kts</code>）</li><li>✅ 鸿蒙平台代码（<code>Platform.ohos.kt</code>, <code>MainArkUIViewController.kt</code>, <code>App.ohos.kt</code>）</li><li>✅ C互操作配置（<code>resource.def</code>, <code>raw_file.h</code>, <code>raw_file_manager.h</code>）</li><li>✅ 鸿蒙应用配置（<code>build-profile.json5</code>, <code>oh-package.json5</code>, <code>CMakeLists.txt</code>）</li><li>✅ NAPI桥接代码（<code>napi_init.cpp</code>）</li><li>✅ ArkTS页面代码（<code>Index.ets</code>, <code>ComposeSample.ets</code>, <code>ComposeInterops.ets</code>）</li><li>✅ Compose支持库（<code>compose.har</code>）</li></ul><blockquote><p><strong>注意</strong>：应用patch后，您可以直接跳到第六节\"编译和运行\"进行验证。如果您想了解每个配置的详细说明，可以继续阅读第五节。</p></blockquote>"
        },
        {
          "section_id": "9e52eadc73",
          "title": "五、配置鸿蒙工程（详细说明）",
          "summary": "**说明**：本节详细介绍了patch文件中的所有修改。如果您已经应用了patch，可以跳过本节直接进入第六节。本节内容帮助您理解每个配置的作用和原理。",
          "key_points": [
            "**说明**：本节详细介绍了patch文件中的所有修改。如果您已经应用了patch，可以跳过本节直接进入第六节。本节内容帮助您理解每个配置的作用和原理。",
            "以下内容是对patch中所有修改的详细说明："
          ],
          "estimated_minutes": 2,
          "content": "> **说明**：本节详细介绍了patch文件中的所有修改。如果您已经应用了patch，可以跳过本节直接进入第六节。本节内容帮助您理解每个配置的作用和原理。\n\n以下内容是对patch中所有修改的详细说明：",
          "content_html": "<blockquote><p><strong>说明</strong>：本节详细介绍了patch文件中的所有修改。如果您已经应用了patch，可以跳过本节直接进入第六节。本节内容帮助您理解每个配置的作用和原理。</p></blockquote><p>以下内容是对patch中所有修改的详细说明：</p>"
        },
        {
          "section_id": "0d343cbdea",
          "title": "5.1 配置build-profile.json5",
          "summary": "编辑 harmonyApp/build-profile.json5： json5 { \"app\": { \"signingConfigs\": [ { \"name\": \"defa...",
          "key_points": [
            "编辑 harmonyApp/build-profile.json5：",
            "json5",
            "{",
            "\"app\": {"
          ],
          "estimated_minutes": 2,
          "content": "编辑 `harmonyApp/build-profile.json5`：\n\n```json5\n{\n  \"app\": {\n    \"signingConfigs\": [\n      {\n        \"name\": \"default\",\n        \"type\": \"HarmonyOS\",\n        \"material\": {\n          // 配置签名信息\n        }\n      }\n    ],\n    \"products\": [\n      {\n        \"name\": \"default\",\n        \"signingConfig\": \"default\",\n        \"targetSdkVersion\": \"6.0.0(20)\",\n        \"compatibleSdkVersion\": \"6.0.0(20)\",\n        \"runtimeOS\": \"HarmonyOS\",\n        \"buildOption\": {\n          \"nativeCompiler\": \"BiSheng\",\n          \"strictMode\": {\n            \"caseSensitiveCheck\": true,\n            \"useNormalizedOHMUrl\": true\n          }\n        }\n      }\n    ]\n  }\n}\n```",
          "content_html": "<p>编辑 <code>harmonyApp/build-profile.json5</code>：</p><pre><code class=\"language-json5\">{\n  \"app\": {\n    \"signingConfigs\": [\n      {\n        \"name\": \"default\",\n        \"type\": \"HarmonyOS\",\n        \"material\": {\n          // 配置签名信息\n        }\n      }\n    ],\n    \"products\": [\n      {\n        \"name\": \"default\",\n        \"signingConfig\": \"default\",\n        \"targetSdkVersion\": \"6.0.0(20)\",\n        \"compatibleSdkVersion\": \"6.0.0(20)\",\n        \"runtimeOS\": \"HarmonyOS\",\n        \"buildOption\": {\n          \"nativeCompiler\": \"BiSheng\",\n          \"strictMode\": {\n            \"caseSensitiveCheck\": true,\n            \"useNormalizedOHMUrl\": true\n          }\n        }\n      }\n    ]\n  }\n}</code></pre>"
        },
        {
          "section_id": "fc1d4a3e74",
          "title": "5.2 配置entry模块依赖",
          "summary": "编辑 harmonyApp/entry/oh-package.json5： json5 { \"name\": \"entry\", \"version\": \"1.0.0\", \"des...",
          "key_points": [
            "编辑 harmonyApp/entry/oh-package.json5：",
            "json5",
            "{",
            "\"name\": \"entry\","
          ],
          "estimated_minutes": 2,
          "content": "编辑 `harmonyApp/entry/oh-package.json5`：\n\n```json5\n{\n  \"name\": \"entry\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Please describe the basic information.\",\n  \"main\": \"\",\n  \"author\": \"\",\n  \"license\": \"\",\n  \"dependencies\": {\n    \"libentry.so\": \"file:./src/main/cpp/types/libentry\",\n    \"compose\": \"file:./libs/compose.har\"\n  }\n}\n```\n\n**关键依赖说明**：\n- `libentry.so`: 本地C++模块\n- `compose.har`: Compose鸿蒙支持库",
          "content_html": "<p>编辑 <code>harmonyApp/entry/oh-package.json5</code>：</p><pre><code class=\"language-json5\">{\n  \"name\": \"entry\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Please describe the basic information.\",\n  \"main\": \"\",\n  \"author\": \"\",\n  \"license\": \"\",\n  \"dependencies\": {\n    \"libentry.so\": \"file:./src/main/cpp/types/libentry\",\n    \"compose\": \"file:./libs/compose.har\"\n  }\n}</code></pre><p><strong>关键依赖说明</strong>：</p><ul><li><code>libentry.so</code>: 本地C++模块</li><li><code>compose.har</code>: Compose鸿蒙支持库</li></ul>"
        },
        {
          "section_id": "e7ddf93b69",
          "title": "5.3 配置CMakeLists.txt",
          "summary": "编辑 harmonyApp/entry/src/main/cpp/CMakeLists.txt： cmake cmake_minimum_required(VERSION 3...",
          "key_points": [
            "编辑 harmonyApp/entry/src/main/cpp/CMakeLists.txt：",
            "cmake",
            "cmake_minimum_required(VERSION 3.5.0)",
            "project(harmonyApp)"
          ],
          "estimated_minutes": 2,
          "content": "编辑 `harmonyApp/entry/src/main/cpp/CMakeLists.txt`：\n\n```cmake\ncmake_minimum_required(VERSION 3.5.0)\nproject(harmonyApp)\n\nset(NATIVERENDER_ROOT_PATH ${CMAKE_CURRENT_SOURCE_DIR})\n\nif(DEFINED PACKAGE_FIND_FILE)\n    include(${PACKAGE_FIND_FILE})\nendif()\n\ninclude_directories(${NATIVERENDER_ROOT_PATH}\n                    ${NATIVERENDER_ROOT_PATH}/include)\n\nadd_library(entry SHARED napi_init.cpp)\ntarget_link_libraries(entry PUBLIC libace_napi.z.so)\ntarget_link_libraries(entry PUBLIC librawfile.z.so)\ntarget_link_libraries(entry PUBLIC libace_ndk.z.so)\ntarget_link_libraries(entry PUBLIC ${NATIVERENDER_ROOT_PATH}/../../../libs/arm64-v8a/libkn.so)\n```\n\n**关键配置说明**：\n- 链接KMP生成的 `libkn.so` 共享库\n- 链接鸿蒙NDK必要的库",
          "content_html": "<p>编辑 <code>harmonyApp/entry/src/main/cpp/CMakeLists.txt</code>：</p><pre><code class=\"language-cmake\">cmake_minimum_required(VERSION 3.5.0)\nproject(harmonyApp)\n\nset(NATIVERENDER_ROOT_PATH ${CMAKE_CURRENT_SOURCE_DIR})\n\nif(DEFINED PACKAGE_FIND_FILE)\n    include(${PACKAGE_FIND_FILE})\nendif()\n\ninclude_directories(${NATIVERENDER_ROOT_PATH}\n                    ${NATIVERENDER_ROOT_PATH}/include)\n\nadd_library(entry SHARED napi_init.cpp)\ntarget_link_libraries(entry PUBLIC libace_napi.z.so)\ntarget_link_libraries(entry PUBLIC librawfile.z.so)\ntarget_link_libraries(entry PUBLIC libace_ndk.z.so)\ntarget_link_libraries(entry PUBLIC ${NATIVERENDER_ROOT_PATH}/../../../libs/arm64-v8a/libkn.so)</code></pre><p><strong>关键配置说明</strong>：</p><ul><li>链接KMP生成的 <code>libkn.so</code> 共享库</li><li>链接鸿蒙NDK必要的库</li></ul>"
        },
        {
          "section_id": "bbf151b652",
          "title": "5.4 实现NAPI桥接代码",
          "summary": "编辑 harmonyApp/entry/src/main/cpp/napi_init.cpp： cpp #include \"napi/native_api.h\" #inclu...",
          "key_points": [
            "编辑 harmonyApp/entry/src/main/cpp/napi_init.cpp：",
            "cpp",
            "#include \"napi/native_api.h\"",
            "#include \"libkn_api.h\""
          ],
          "estimated_minutes": 5,
          "content": "编辑 `harmonyApp/entry/src/main/cpp/napi_init.cpp`：\n\n```cpp\n#include \"napi/native_api.h\"\n#include \"libkn_api.h\"\n#include <rawfile/raw_file_manager.h>\n\nstatic napi_value MainArkUIViewController(napi_env env, napi_callback_info info) {\n    return reinterpret_cast<napi_value>(MainArkUIViewController(env));\n}\n\nstatic napi_value InitResourceManager(napi_env env, napi_callback_info info) {\n    size_t argc = 1;\n    napi_value args[1] = {nullptr};\n    napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);\n\n    auto manager = OH_ResourceManager_InitNativeResourceManager(env, args[0]);\n    auto kt = libkn_symbols();\n    kt->kotlin.root.com.example.mykmpapp.initResourceManager(manager);\n\n    napi_value result;\n    napi_create_int32(env, 0, &result);\n    return result;\n}\n\nEXTERN_C_START\nstatic napi_value Init(napi_env env, napi_value exports)\n{\n    napi_property_descriptor desc[] = {\n        {\"initResourceManager\", nullptr, InitResourceManager, nullptr, nullptr, nullptr, napi_default, nullptr},\n        {\"MainArkUIViewController\", nullptr, MainArkUIViewController, nullptr, nullptr, nullptr, napi_default, nullptr},\n    };\n    napi_define_properties(env, exports, sizeof(desc) / sizeof(desc[0]), desc);\n    return exports;\n}\nEXTERN_C_END\n\nstatic napi_module demoModule = {\n    .nm_version = 1,\n    .nm_flags = 0,\n    .nm_filename = nullptr,\n    .nm_register_func = Init,\n    .nm_modname = \"entry\",\n    .nm_priv = ((void*)0),\n    .reserved = { 0 },\n};\n\nextern \"C\" __attribute__((constructor)) void RegisterEntryModule(void)\n{\n    napi_module_register(&demoModule);\n}\n```\n\n**关键代码说明**：\n- `MainArkUIViewController`: 桥接函数，调用Kotlin导出的同名函数\n- `InitResourceManager`: 初始化资源管理器，传递给Kotlin层\n- `libkn_symbols()`: 访问Kotlin/Native导出的符号",
          "content_html": "<p>编辑 <code>harmonyApp/entry/src/main/cpp/napi_init.cpp</code>：</p><pre><code class=\"language-cpp\">#include \"napi/native_api.h\"\n#include \"libkn_api.h\"\n#include &lt;rawfile/raw_file_manager.h&gt;\n\nstatic napi_value MainArkUIViewController(napi_env env, napi_callback_info info) {\n    return reinterpret_cast&lt;napi_value&gt;(MainArkUIViewController(env));\n}\n\nstatic napi_value InitResourceManager(napi_env env, napi_callback_info info) {\n    size_t argc = 1;\n    napi_value args[1] = {nullptr};\n    napi_get_cb_info(env, info, &amp;argc, args, nullptr, nullptr);\n\n    auto manager = OH_ResourceManager_InitNativeResourceManager(env, args[0]);\n    auto kt = libkn_symbols();\n    kt-&gt;kotlin.root.com.example.mykmpapp.initResourceManager(manager);\n\n    napi_value result;\n    napi_create_int32(env, 0, &amp;result);\n    return result;\n}\n\nEXTERN_C_START\nstatic napi_value Init(napi_env env, napi_value exports)\n{\n    napi_property_descriptor desc[] = {\n        {\"initResourceManager\", nullptr, InitResourceManager, nullptr, nullptr, nullptr, napi_default, nullptr},\n        {\"MainArkUIViewController\", nullptr, MainArkUIViewController, nullptr, nullptr, nullptr, napi_default, nullptr},\n    };\n    napi_define_properties(env, exports, sizeof(desc) / sizeof(desc[0]), desc);\n    return exports;\n}\nEXTERN_C_END\n\nstatic napi_module demoModule = {\n    .nm_version = 1,\n    .nm_flags = 0,\n    .nm_filename = nullptr,\n    .nm_register_func = Init,\n    .nm_modname = \"entry\",\n    .nm_priv = ((void*)0),\n    .reserved = { 0 },\n};\n\nextern \"C\" __attribute__((constructor)) void RegisterEntryModule(void)\n{\n    napi_module_register(&amp;demoModule);\n}</code></pre><p><strong>关键代码说明</strong>：</p><ul><li><code>MainArkUIViewController</code>: 桥接函数，调用Kotlin导出的同名函数</li><li><code>InitResourceManager</code>: 初始化资源管理器，传递给Kotlin层</li><li><code>libkn_symbols()</code>: 访问Kotlin/Native导出的符号</li></ul>"
        },
        {
          "section_id": "982008141a",
          "title": "5.5 创建ArkTS页面",
          "summary": "5.5.1 创建ComposeInterops.ets 首先创建 harmonyApp/entry/src/main/ets/pages/ComposeInterops.et...",
          "key_points": [
            "5.5.1 创建ComposeInterops.ets",
            "首先创建 harmonyApp/entry/src/main/ets/pages/ComposeInterops.ets，实现ArkUI与Compose互操作组件：",
            "typescript",
            "import { promptAction } from '@kit.ArkUI';"
          ],
          "estimated_minutes": 19,
          "content": "#### 5.5.1 创建ComposeInterops.ets\n\n首先创建 `harmonyApp/entry/src/main/ets/pages/ComposeInterops.ets`，实现ArkUI与Compose互操作组件：\n\n```typescript\nimport { promptAction } from '@kit.ArkUI';\n\ninterface ButtonArgs {\n  text: string\n  backgroundColor: string\n}\n\n@Builder\nexport function buttonBuilder(args: ButtonArgs) {\n  button()\n}\n\n@Component\nexport struct button {\n  @Consume compose_args: ButtonArgs\n\n  build() {\n    Column() {\n      Button(this.compose_args.text)\n        .backgroundColor(this.compose_args.backgroundColor)\n        .width('100%')\n        .onClick(e => {\n          console.log(`Button Clicked: ${this.compose_args.text}`)\n        })\n        .height('70%')\n\n      Text(this.compose_args.text)\n        .backgroundColor(this.compose_args.backgroundColor)\n        .width('100%')\n        .onClick(e => {\n          console.log(`Text Clicked: ${this.compose_args.text}`)\n        })\n        .height('20%')\n      Stack().height('10%')\n    }\n  }\n}\n\ninterface TextArgs {\n  id: string\n  text: string\n  backgroundColor: string\n}\n\n@Builder\nexport function textBuilder(args: TextArgs) {\n  text()\n}\n\n@Component\nexport struct text {\n  @Consume compose_args: TextArgs\n\n  build() {\n    Text(this.compose_args.id + \" \" + this.compose_args.text)\n      .backgroundColor(this.compose_args.backgroundColor)\n      .width('100%')\n      .height('100%')\n      .borderRadius('5vp')\n      .onClick(e => {\n        console.log(`Text Clicked: ${JSON.stringify(this.compose_args)}`)\n      })\n  }\n}\n\n@Builder\nexport function labelBuilder(args: ButtonArgs) {\n  label()\n}\n\n@Component\nexport struct label {\n  @Consume compose_args: ButtonArgs\n\n  build() {\n    Column() {\n      Button(`+ ${this.compose_args.text}`, { type: ButtonType.Normal })\n        .backgroundColor(this.compose_args.backgroundColor)\n        .width('100%')\n        .height('50%')\n        .borderRadius(2)\n        .onClick(e => {\n          promptAction.showToast({\n            message: this.compose_args.text\n          })\n        })\n      Text(this.compose_args.text)\n        .backgroundColor(Color.Orange)\n        .width('100%')\n        .height('50%')\n    }\n  }\n}\n\n@Builder\nexport function textInputBuilder(args: InputArgs) {\n  textInput()\n}\n\ninterface InputArgs {\n  text: string\n}\n\n@Component\nexport struct textInput {\n  @Consume compose_args: InputArgs\n\n  build() {\n    Column() {\n      TextInput({ text: $$this.compose_args.text })\n        .onChange(value => {\n          console.log(`/// onChange: ${value}`)\n        })\n\n      Text(\"ArkUI组件更新:\")\n        .fontColor(Color.Gray)\n        .margin({ top: 30 })\n\n      Text(this.compose_args.text)\n        .width('100%')\n        .padding(10)\n        .border({ width: 1, color: Color.Gray })\n    }.alignItems(HorizontalAlign.Start)\n  }\n}\n\n@Builder\nexport function layerBuilder(args: ButtonArgs) {\n  layer()\n}\n\n@Component\nexport struct layer {\n  @Consume compose_args: ButtonArgs\n\n  build() {\n    Stack({ alignContent: Alignment.BottomEnd }) {\n      Text(this.compose_args.text)\n    }\n    .width('100%')\n    .height('100%')\n    .backgroundColor(this.compose_args.backgroundColor)\n    .onClick(() => {\n      promptAction.showToast({ message: `${this.compose_args.text} Clicked` })\n    })\n  }\n}\n\n@Builder\nexport function verticalListBuilder(args?: object) {\n  verticalList()\n}\n\n@Component\nexport struct verticalList {\n  build() {\n    Row() {\n      List() {\n        ForEach([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], (item: number, index) => {\n          ListItem() {\n            Button(`Ark Button ${index}`, { type: ButtonType.Normal })\n              .borderRadius(2)\n              .height('100vp')\n              .padding(10)\n          }.padding(10)\n        })\n      }.listDirection(Axis.Vertical).height('100%').width('40%')\n\n      Stack().width('20%').height('100%').borderWidth(1)\n\n      Scroll() {\n        Column() {\n          ForEach([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], (item: number, index) => {\n            ListItem() {\n              Button(`Ark Button ${index}`, { type: ButtonType.Normal })\n                .borderRadius(2)\n                .height('100vp')\n                .padding(10)\n            }.padding(10)\n          })\n        }\n      }.scrollable(ScrollDirection.Vertical).height('100%').width('40%')\n    }\n  }\n}\n\n@Builder\nexport function horizontalListBuilder(args?: object) {\n  horizontalList()\n}\n\n@Component\nexport struct horizontalList {\n  build() {\n    Column() {\n      List() {\n        ForEach([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], (item: number, index) => {\n          ListItem() {\n            Button(`Ark Button ${index}`, { type: ButtonType.Normal })\n              .borderRadius(2)\n              .height('100vp')\n          }.padding(10)\n        })\n      }.listDirection(Axis.Horizontal).height('40%').width('100%')\n\n      Stack().width('100%').height('20%').borderWidth(1)\n\n      Scroll() {\n        Row() {\n          ForEach([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], (item: number, index) => {\n            ListItem() {\n              Button(`Ark Button ${index}`, { type: ButtonType.Normal })\n                .borderRadius(2)\n                .height('100vp')\n            }.padding(10)\n          })\n        }\n      }.scrollable(ScrollDirection.Horizontal).height('40%').width('100%')\n    }\n  }\n}\n```\n\n**关键代码说明**：\n- `@Builder`: 定义可复用的UI构建函数\n- `@Component`: 定义ArkUI组件\n- `@Consume`: 从Compose传递过来的参数\n- 这些组件允许在Compose中嵌入原生ArkUI组件，实现互操作\n\n#### 5.5.2 创建ComposeSample.ets\n\n创建 `harmonyApp/entry/src/main/ets/pages/ComposeSample.ets`：\n\n```typescript\nimport { registerComposeInteropBuilder } from 'compose/src/main/ets/compose/ArkUIView';\nimport {\n  buttonBuilder,\n  textBuilder,\n  labelBuilder,\n  textInputBuilder,\n  buttonWrapContentBuilder,\n  layerBuilder,\n  verticalListBuilder,\n  horizontalListBuilder,\n} from './ComposeInterops';\n\nexport function registerComposeInteropBuilders() {\n  registerComposeInteropBuilder('button', buttonBuilder)\n  registerComposeInteropBuilder('label', labelBuilder)\n  registerComposeInteropBuilder('buttonWrapContent', buttonWrapContentBuilder)\n  registerComposeInteropBuilder('textInput', textInputBuilder)\n  registerComposeInteropBuilder('layer', layerBuilder)\n  registerComposeInteropBuilder('text', textBuilder)\n  registerComposeInteropBuilder('verticalList', verticalListBuilder)\n  registerComposeInteropBuilder('horizontalList', horizontalListBuilder)\n}\n```\n\n#### 5.5.3 创建Index.ets入口页面\n\n创建 `harmonyApp/entry/src/main/ets/pages/Index.ets`：\n\n```typescript\nimport { Compose } from 'compose';\nimport { MainArkUIViewController } from 'libentry.so';\nimport { registerComposeInteropBuilders } from './ComposeSample';\n\nregisterComposeInteropBuilders();\n\n@Entry\n@Component\nstruct Index {\n  private controller = MainArkUIViewController()\n\n  onPageShow(): void {\n    this.controller.onPageShow()\n  }\n\n  onPageHide(): void {\n    this.controller.onPageHide()\n  }\n\n  onBackPress(): boolean | void {\n    // 返回事件转发给 Compose，优先给 Compose 消费，若 Compose 不消费再给系统消费\n    return this.controller.onBackPress()\n  }\n\n  build() {\n    Stack() {\n      Compose(\n        {\n          controller: this.controller,\n          libraryName: \"entry\",\n          // 若 Compose 不消费，事件会流转到这里，若这里返回 false，则交由系统处理\n          onBackPressed: () => false\n        }\n      ).width('100%').height('100%')\n    }.width('100%').height('100%')\n  }\n}\n```\n\n**关键代码说明**：\n- `MainArkUIViewController()`: 调用NAPI导出的函数，创建Compose控制器\n- `registerComposeInteropBuilders()`: 注册ArkUI与Compose互操作组件\n- `Compose`: 鸿蒙Compose组件，承载Kotlin编写的Compose UI\n- 生命周期方法：`onPageShow`, `onPageHide`, `onBackPress`",
          "content_html": "<h4>5.5.1 创建ComposeInterops.ets</h4><p>首先创建 <code>harmonyApp/entry/src/main/ets/pages/ComposeInterops.ets</code>，实现ArkUI与Compose互操作组件：</p><pre><code class=\"language-typescript\">import { promptAction } from '@kit.ArkUI';\n\ninterface ButtonArgs {\n  text: string\n  backgroundColor: string\n}\n\n@Builder\nexport function buttonBuilder(args: ButtonArgs) {\n  button()\n}\n\n@Component\nexport struct button {\n  @Consume compose_args: ButtonArgs\n\n  build() {\n    Column() {\n      Button(this.compose_args.text)\n        .backgroundColor(this.compose_args.backgroundColor)\n        .width('100%')\n        .onClick(e =&gt; {\n          console.log(`Button Clicked: ${this.compose_args.text}`)\n        })\n        .height('70%')\n\n      Text(this.compose_args.text)\n        .backgroundColor(this.compose_args.backgroundColor)\n        .width('100%')\n        .onClick(e =&gt; {\n          console.log(`Text Clicked: ${this.compose_args.text}`)\n        })\n        .height('20%')\n      Stack().height('10%')\n    }\n  }\n}\n\ninterface TextArgs {\n  id: string\n  text: string\n  backgroundColor: string\n}\n\n@Builder\nexport function textBuilder(args: TextArgs) {\n  text()\n}\n\n@Component\nexport struct text {\n  @Consume compose_args: TextArgs\n\n  build() {\n    Text(this.compose_args.id + \" \" + this.compose_args.text)\n      .backgroundColor(this.compose_args.backgroundColor)\n      .width('100%')\n      .height('100%')\n      .borderRadius('5vp')\n      .onClick(e =&gt; {\n        console.log(`Text Clicked: ${JSON.stringify(this.compose_args)}`)\n      })\n  }\n}\n\n@Builder\nexport function labelBuilder(args: ButtonArgs) {\n  label()\n}\n\n@Component\nexport struct label {\n  @Consume compose_args: ButtonArgs\n\n  build() {\n    Column() {\n      Button(`+ ${this.compose_args.text}`, { type: ButtonType.Normal })\n        .backgroundColor(this.compose_args.backgroundColor)\n        .width('100%')\n        .height('50%')\n        .borderRadius(2)\n        .onClick(e =&gt; {\n          promptAction.showToast({\n            message: this.compose_args.text\n          })\n        })\n      Text(this.compose_args.text)\n        .backgroundColor(Color.Orange)\n        .width('100%')\n        .height('50%')\n    }\n  }\n}\n\n@Builder\nexport function textInputBuilder(args: InputArgs) {\n  textInput()\n}\n\ninterface InputArgs {\n  text: string\n}\n\n@Component\nexport struct textInput {\n  @Consume compose_args: InputArgs\n\n  build() {\n    Column() {\n      TextInput({ text: $$this.compose_args.text })\n        .onChange(value =&gt; {\n          console.log(`/// onChange: ${value}`)\n        })\n\n      Text(\"ArkUI组件更新:\")\n        .fontColor(Color.Gray)\n        .margin({ top: 30 })\n\n      Text(this.compose_args.text)\n        .width('100%')\n        .padding(10)\n        .border({ width: 1, color: Color.Gray })\n    }.alignItems(HorizontalAlign.Start)\n  }\n}\n\n@Builder\nexport function layerBuilder(args: ButtonArgs) {\n  layer()\n}\n\n@Component\nexport struct layer {\n  @Consume compose_args: ButtonArgs\n\n  build() {\n    Stack({ alignContent: Alignment.BottomEnd }) {\n      Text(this.compose_args.text)\n    }\n    .width('100%')\n    .height('100%')\n    .backgroundColor(this.compose_args.backgroundColor)\n    .onClick(() =&gt; {\n      promptAction.showToast({ message: `${this.compose_args.text} Clicked` })\n    })\n  }\n}\n\n@Builder\nexport function verticalListBuilder(args?: object) {\n  verticalList()\n}\n\n@Component\nexport struct verticalList {\n  build() {\n    Row() {\n      List() {\n        ForEach([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], (item: number, index) =&gt; {\n          ListItem() {\n            Button(`Ark Button ${index}`, { type: ButtonType.Normal })\n              .borderRadius(2)\n              .height('100vp')\n              .padding(10)\n          }.padding(10)\n        })\n      }.listDirection(Axis.Vertical).height('100%').width('40%')\n\n      Stack().width('20%').height('100%').borderWidth(1)\n\n      Scroll() {\n        Column() {\n          ForEach([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], (item: number, index) =&gt; {\n            ListItem() {\n              Button(`Ark Button ${index}`, { type: ButtonType.Normal })\n                .borderRadius(2)\n                .height('100vp')\n                .padding(10)\n            }.padding(10)\n          })\n        }\n      }.scrollable(ScrollDirection.Vertical).height('100%').width('40%')\n    }\n  }\n}\n\n@Builder\nexport function horizontalListBuilder(args?: object) {\n  horizontalList()\n}\n\n@Component\nexport struct horizontalList {\n  build() {\n    Column() {\n      List() {\n        ForEach([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], (item: number, index) =&gt; {\n          ListItem() {\n            Button(`Ark Button ${index}`, { type: ButtonType.Normal })\n              .borderRadius(2)\n              .height('100vp')\n          }.padding(10)\n        })\n      }.listDirection(Axis.Horizontal).height('40%').width('100%')\n\n      Stack().width('100%').height('20%').borderWidth(1)\n\n      Scroll() {\n        Row() {\n          ForEach([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], (item: number, index) =&gt; {\n            ListItem() {\n              Button(`Ark Button ${index}`, { type: ButtonType.Normal })\n                .borderRadius(2)\n                .height('100vp')\n            }.padding(10)\n          })\n        }\n      }.scrollable(ScrollDirection.Horizontal).height('40%').width('100%')\n    }\n  }\n}</code></pre><p><strong>关键代码说明</strong>：</p><ul><li><code>@Builder</code>: 定义可复用的UI构建函数</li><li><code>@Component</code>: 定义ArkUI组件</li><li><code>@Consume</code>: 从Compose传递过来的参数</li><li>这些组件允许在Compose中嵌入原生ArkUI组件，实现互操作</li></ul><h4>5.5.2 创建ComposeSample.ets</h4><p>创建 <code>harmonyApp/entry/src/main/ets/pages/ComposeSample.ets</code>：</p><pre><code class=\"language-typescript\">import { registerComposeInteropBuilder } from 'compose/src/main/ets/compose/ArkUIView';\nimport {\n  buttonBuilder,\n  textBuilder,\n  labelBuilder,\n  textInputBuilder,\n  buttonWrapContentBuilder,\n  layerBuilder,\n  verticalListBuilder,\n  horizontalListBuilder,\n} from './ComposeInterops';\n\nexport function registerComposeInteropBuilders() {\n  registerComposeInteropBuilder('button', buttonBuilder)\n  registerComposeInteropBuilder('label', labelBuilder)\n  registerComposeInteropBuilder('buttonWrapContent', buttonWrapContentBuilder)\n  registerComposeInteropBuilder('textInput', textInputBuilder)\n  registerComposeInteropBuilder('layer', layerBuilder)\n  registerComposeInteropBuilder('text', textBuilder)\n  registerComposeInteropBuilder('verticalList', verticalListBuilder)\n  registerComposeInteropBuilder('horizontalList', horizontalListBuilder)\n}</code></pre><h4>5.5.3 创建Index.ets入口页面</h4><p>创建 <code>harmonyApp/entry/src/main/ets/pages/Index.ets</code>：</p><pre><code class=\"language-typescript\">import { Compose } from 'compose';\nimport { MainArkUIViewController } from 'libentry.so';\nimport { registerComposeInteropBuilders } from './ComposeSample';\n\nregisterComposeInteropBuilders();\n\n@Entry\n@Component\nstruct Index {\n  private controller = MainArkUIViewController()\n\n  onPageShow(): void {\n    this.controller.onPageShow()\n  }\n\n  onPageHide(): void {\n    this.controller.onPageHide()\n  }\n\n  onBackPress(): boolean | void {\n    // 返回事件转发给 Compose，优先给 Compose 消费，若 Compose 不消费再给系统消费\n    return this.controller.onBackPress()\n  }\n\n  build() {\n    Stack() {\n      Compose(\n        {\n          controller: this.controller,\n          libraryName: \"entry\",\n          // 若 Compose 不消费，事件会流转到这里，若这里返回 false，则交由系统处理\n          onBackPressed: () =&gt; false\n        }\n      ).width('100%').height('100%')\n    }.width('100%').height('100%')\n  }\n}</code></pre><p><strong>关键代码说明</strong>：</p><ul><li><code>MainArkUIViewController()</code>: 调用NAPI导出的函数，创建Compose控制器</li><li><code>registerComposeInteropBuilders()</code>: 注册ArkUI与Compose互操作组件</li><li><code>Compose</code>: 鸿蒙Compose组件，承载Kotlin编写的Compose UI</li><li>生命周期方法：<code>onPageShow</code>, <code>onPageHide</code>, <code>onBackPress</code></li></ul>"
        },
        {
          "section_id": "c9ac10a96f",
          "title": "6.1 编译KMP共享库",
          "summary": "在KMP工程根目录执行： bash",
          "key_points": [
            "在KMP工程根目录执行：",
            "bash"
          ],
          "estimated_minutes": 2,
          "content": "在KMP工程根目录执行：\n\n```bash",
          "content_html": "<p>在KMP工程根目录执行：</p><pre><code class=\"language-bash\"></code></pre>"
        },
        {
          "section_id": "39ed4ecb01",
          "title": "Debug版本",
          "summary": "./gradlew publishDebugBinariesToHarmonyApp",
          "key_points": [
            "./gradlew publishDebugBinariesToHarmonyApp"
          ],
          "estimated_minutes": 2,
          "content": "./gradlew publishDebugBinariesToHarmonyApp",
          "content_html": "<p>./gradlew publishDebugBinariesToHarmonyApp</p>"
        },
        {
          "section_id": "c01ae185b6",
          "title": "Release版本",
          "summary": "./gradlew publishReleaseBinariesToHarmonyApp 此命令会： 编译鸿蒙平台的Kotlin代码 生成 libkn.so 共享库 生成 l...",
          "key_points": [
            "./gradlew publishReleaseBinariesToHarmonyApp",
            "此命令会：",
            "编译鸿蒙平台的Kotlin代码",
            "生成 libkn.so 共享库"
          ],
          "estimated_minutes": 2,
          "content": "./gradlew publishReleaseBinariesToHarmonyApp\n```\n\n此命令会：\n1. 编译鸿蒙平台的Kotlin代码\n2. 生成 `libkn.so` 共享库\n3. 生成 `libkn_api.h` 头文件\n4. 自动复制到 `harmonyApp/entry/libs/arm64-v8a/` 目录",
          "content_html": "<p>./gradlew publishReleaseBinariesToHarmonyApp</p><pre><code>\n此命令会：\n1. 编译鸿蒙平台的Kotlin代码\n2. 生成 `libkn.so` 共享库\n3. 生成 `libkn_api.h` 头文件\n4. 自动复制到 `harmonyApp/entry/libs/arm64-v8a/` 目录</code></pre>"
        },
        {
          "section_id": "2da1b42275",
          "title": "6.2 在DevEco Studio中编译鸿蒙应用",
          "summary": "用DevEco Studio打开 harmonyApp 目录 等待依赖同步完成 点击 **Build** -> **Build Hap(s)/APP(s)** 或直接点击运行...",
          "key_points": [
            "用DevEco Studio打开 harmonyApp 目录",
            "等待依赖同步完成",
            "点击 **Build** -> **Build Hap(s)/APP(s)**",
            "或直接点击运行按钮部署到设备/模拟器"
          ],
          "estimated_minutes": 2,
          "content": "1. 用DevEco Studio打开 `harmonyApp` 目录\n2. 等待依赖同步完成\n3. 点击 **Build** -> **Build Hap(s)/APP(s)**\n4. 或直接点击运行按钮部署到设备/模拟器",
          "content_html": "<ol><li>用DevEco Studio打开 <code>harmonyApp</code> 目录</li><li>等待依赖同步完成</li><li>点击 <strong>Build</strong> -&gt; <strong>Build Hap(s)/APP(s)</strong></li><li>或直接点击运行按钮部署到设备/模拟器</li></ol>"
        },
        {
          "section_id": "6f4e720d6c",
          "title": "6.3 验证集成",
          "summary": "应用启动后，应该能看到： Compose编写的UI界面正常显示 显示文本: \"Compose: Hello, OHOS!\" 界面响应正常",
          "key_points": [
            "应用启动后，应该能看到：",
            "Compose编写的UI界面正常显示",
            "显示文本: \"Compose: Hello, OHOS!\"",
            "界面响应正常"
          ],
          "estimated_minutes": 2,
          "content": "应用启动后，应该能看到：\n- Compose编写的UI界面正常显示\n- 显示文本: \"Compose: Hello, OHOS!\"\n- 界面响应正常",
          "content_html": "<p>应用启动后，应该能看到：</p><ul><li>Compose编写的UI界面正常显示</li><li>显示文本: \"Compose: Hello, OHOS!\"</li><li>界面响应正常</li></ul>"
        },
        {
          "section_id": "3ac4f49228",
          "title": "7.1 找不到libkn.so",
          "summary": "**问题**: 编译鸿蒙应用时提示找不到libkn.so **解决方案**: 确认已执行 publishDebugBinariesToHarmonyApp 任务 检查 har...",
          "key_points": [
            "**问题**: 编译鸿蒙应用时提示找不到libkn.so",
            "**解决方案**:",
            "确认已执行 publishDebugBinariesToHarmonyApp 任务",
            "检查 harmonyApp/entry/libs/arm64-v8a/libkn.so 是否存在"
          ],
          "estimated_minutes": 2,
          "content": "**问题**: 编译鸿蒙应用时提示找不到libkn.so\n\n**解决方案**:\n1. 确认已执行 `publishDebugBinariesToHarmonyApp` 任务\n2. 检查 `harmonyApp/entry/libs/arm64-v8a/libkn.so` 是否存在\n3. 检查 CMakeLists.txt 中的路径是否正确",
          "content_html": "<p><strong>问题</strong>: 编译鸿蒙应用时提示找不到libkn.so</p><p><strong>解决方案</strong>:</p><ol><li>确认已执行 <code>publishDebugBinariesToHarmonyApp</code> 任务</li><li>检查 <code>harmonyApp/entry/libs/arm64-v8a/libkn.so</code> 是否存在</li><li>检查 CMakeLists.txt 中的路径是否正确</li></ol>"
        },
        {
          "section_id": "ce0c0c7a40",
          "title": "7.2 符号未定义",
          "summary": "**问题**: 链接时提示 undefined reference to MainArkUIViewController **解决方案**: 确认 libkn_api.h 已...",
          "key_points": [
            "**问题**: 链接时提示 undefined reference to MainArkUIViewController",
            "**解决方案**:",
            "确认 libkn_api.h 已生成并复制到 harmonyApp/entry/src/main/cpp/include/",
            "检查 Kotlin 代码中的 @CName 注解是否正确"
          ],
          "estimated_minutes": 2,
          "content": "**问题**: 链接时提示 `undefined reference to MainArkUIViewController`\n\n**解决方案**:\n1. 确认 `libkn_api.h` 已生成并复制到 `harmonyApp/entry/src/main/cpp/include/`\n2. 检查 Kotlin 代码中的 `@CName` 注解是否正确\n3. 重新编译 KMP 共享库",
          "content_html": "<p><strong>问题</strong>: 链接时提示 <code>undefined reference to MainArkUIViewController</code></p><p><strong>解决方案</strong>:</p><ol><li>确认 <code>libkn_api.h</code> 已生成并复制到 <code>harmonyApp/entry/src/main/cpp/include/</code></li><li>检查 Kotlin 代码中的 <code>@CName</code> 注解是否正确</li><li>重新编译 KMP 共享库</li></ol>"
        },
        {
          "section_id": "6857486a06",
          "title": "7.3 资源加载失败",
          "summary": "**问题**: 应用运行时无法加载Compose资源 **解决方案**: 确认已调用 initResourceManager 检查 napi_init.cpp 中的资源管理器...",
          "key_points": [
            "**问题**: 应用运行时无法加载Compose资源",
            "**解决方案**:",
            "确认已调用 initResourceManager",
            "检查 napi_init.cpp 中的资源管理器初始化代码"
          ],
          "estimated_minutes": 2,
          "content": "**问题**: 应用运行时无法加载Compose资源\n\n**解决方案**:\n1. 确认已调用 `initResourceManager`\n2. 检查 `napi_init.cpp` 中的资源管理器初始化代码\n3. 确认 `compose.har` 依赖已正确配置",
          "content_html": "<p><strong>问题</strong>: 应用运行时无法加载Compose资源</p><p><strong>解决方案</strong>:</p><ol><li>确认已调用 <code>initResourceManager</code></li><li>检查 <code>napi_init.cpp</code> 中的资源管理器初始化代码</li><li>确认 <code>compose.har</code> 依赖已正确配置</li></ol>"
        },
        {
          "section_id": "7566e2790a",
          "title": "7.4 版本不兼容",
          "summary": "**问题**: 编译时提示Kotlin或Compose版本不兼容 **解决方案**: 使用指定的鸿蒙版本: kotlin: 2.2.0-ohos-07 compose-mul...",
          "key_points": [
            "**问题**: 编译时提示Kotlin或Compose版本不兼容",
            "**解决方案**:",
            "使用指定的鸿蒙版本:",
            "kotlin: 2.2.0-ohos-07"
          ],
          "estimated_minutes": 2,
          "content": "**问题**: 编译时提示Kotlin或Compose版本不兼容\n\n**解决方案**:\n1. 使用指定的鸿蒙版本:\n   - kotlin: `2.2.0-ohos-07`\n   - compose-multiplatform: `1.6.1-ohos-003`\n2. 确认 Maven 仓库配置正确\n3. 清理缓存: `./gradlew clean`",
          "content_html": "<p><strong>问题</strong>: 编译时提示Kotlin或Compose版本不兼容</p><p><strong>解决方案</strong>:</p><ol><li>使用指定的鸿蒙版本:<ul><li>kotlin: <code>2.2.0-ohos-07</code></li><li>compose-multiplatform: <code>1.6.1-ohos-003</code></li></ul></li><li>确认 Maven 仓库配置正确</li><li>清理缓存: <code>./gradlew clean</code></li></ol>"
        },
        {
          "section_id": "4bb4f10e7b",
          "title": "八、项目结构总览",
          "summary": "MyKMPApp/ ├── composeApp/ # KMP应用模块 │ ├── build.gradle.kts # 构建配置 │ └── src/ │ ├── andr...",
          "key_points": [
            "MyKMPApp/",
            "├── composeApp/ # KMP应用模块",
            "│ ├── build.gradle.kts # 构建配置",
            "│ └── src/"
          ],
          "estimated_minutes": 3,
          "content": "```\nMyKMPApp/\n├── composeApp/                         # KMP应用模块\n│   ├── build.gradle.kts                # 构建配置\n│   └── src/\n│       ├── androidMain/                # Android平台代码\n│       ├── iosMain/                    # iOS平台代码\n│       ├── commonMain/                 # 共享代码\n│       │   └── kotlin/\n│       │       └── com/example/mykmpapp/\n│       │           ├── App.kt          # 主UI界面\n│       │           ├── Greeting.kt     # 业务逻辑\n│       │           └── Platform.kt     # 平台接口定义\n│       └── ohosArm64Main/              # 鸿蒙平台代码\n│           ├── cinterop/               # C互操作配置\n│           │   ├── include/\n│           │   │   ├── raw_file.h\n│           │   │   └── raw_file_manager.h\n│           │   └── resource.def\n│           └── kotlin/\n│               └── com/example/mykmpapp/\n│                   ├── MainArkUIViewController.kt  # 视图控制器\n│                   └── Platform.ohos.kt           # 平台实现\n├── harmonyApp/                         # 鸿蒙应用工程\n│   ├── entry/\n│   │   ├── libs/\n│   │   │   ├── arm64-v8a/\n│   │   │   │   └── libkn.so           # KMP生成的共享库\n│   │   │   └── compose.har            # Compose鸿蒙支持库\n│   │   ├── src/main/\n│   │   │   ├── cpp/\n│   │   │   │   ├── include/\n│   │   │   │   │   └── libkn_api.h    # KMP生成的头文件\n│   │   │   │   ├── CMakeLists.txt     # CMake配置\n│   │   │   │   └── napi_init.cpp      # NAPI桥接代码\n│   │   │   └── ets/\n│   │   │       └── pages/\n│   │   │           ├── Index.ets      # 主页面\n│   │   │           └── ComposeSample.ets  # Compose互操作配置\n│   │   └── oh-package.json5           # 依赖配置\n│   └── build-profile.json5            # 构建配置\n├── gradle/\n│   └── libs.versions.toml             # 版本管理\n├── settings.gradle.kts                # 工程设置\n└── build.gradle.kts                   # 根构建配置\n```",
          "content_html": "<pre><code>MyKMPApp/\n├── composeApp/                         # KMP应用模块\n│   ├── build.gradle.kts                # 构建配置\n│   └── src/\n│       ├── androidMain/                # Android平台代码\n│       ├── iosMain/                    # iOS平台代码\n│       ├── commonMain/                 # 共享代码\n│       │   └── kotlin/\n│       │       └── com/example/mykmpapp/\n│       │           ├── App.kt          # 主UI界面\n│       │           ├── Greeting.kt     # 业务逻辑\n│       │           └── Platform.kt     # 平台接口定义\n│       └── ohosArm64Main/              # 鸿蒙平台代码\n│           ├── cinterop/               # C互操作配置\n│           │   ├── include/\n│           │   │   ├── raw_file.h\n│           │   │   └── raw_file_manager.h\n│           │   └── resource.def\n│           └── kotlin/\n│               └── com/example/mykmpapp/\n│                   ├── MainArkUIViewController.kt  # 视图控制器\n│                   └── Platform.ohos.kt           # 平台实现\n├── harmonyApp/                         # 鸿蒙应用工程\n│   ├── entry/\n│   │   ├── libs/\n│   │   │   ├── arm64-v8a/\n│   │   │   │   └── libkn.so           # KMP生成的共享库\n│   │   │   └── compose.har            # Compose鸿蒙支持库\n│   │   ├── src/main/\n│   │   │   ├── cpp/\n│   │   │   │   ├── include/\n│   │   │   │   │   └── libkn_api.h    # KMP生成的头文件\n│   │   │   │   ├── CMakeLists.txt     # CMake配置\n│   │   │   │   └── napi_init.cpp      # NAPI桥接代码\n│   │   │   └── ets/\n│   │   │       └── pages/\n│   │   │           ├── Index.ets      # 主页面\n│   │   │           └── ComposeSample.ets  # Compose互操作配置\n│   │   └── oh-package.json5           # 依赖配置\n│   └── build-profile.json5            # 构建配置\n├── gradle/\n│   └── libs.versions.toml             # 版本管理\n├── settings.gradle.kts                # 工程设置\n└── build.gradle.kts                   # 根构建配置</code></pre>"
        },
        {
          "section_id": "4b610ce167",
          "title": "9.1 配置多模块",
          "summary": "如果项目有多个共享模块，可以在 settings.gradle.kts 中添加： kotlin include(\":composeApp\") include(\":shared...",
          "key_points": [
            "如果项目有多个共享模块，可以在 settings.gradle.kts 中添加：",
            "kotlin",
            "include(\":composeApp\")",
            "include(\":shared\")"
          ],
          "estimated_minutes": 2,
          "content": "如果项目有多个共享模块，可以在 `settings.gradle.kts` 中添加：\n\n```kotlin\ninclude(\":composeApp\")\ninclude(\":shared\")\n```",
          "content_html": "<p>如果项目有多个共享模块，可以在 <code>settings.gradle.kts</code> 中添加：</p><pre><code class=\"language-kotlin\">include(\":composeApp\")\ninclude(\":shared\")</code></pre>"
        },
        {
          "section_id": "6aebdc12d9",
          "title": "9.2 配置符号表",
          "summary": "为了便于调试崩溃，可以保留符号表： kotlin ohosArm64 { binaries.sharedLib { // 在debug和release模式，让gradle都打...",
          "key_points": [
            "为了便于调试崩溃，可以保留符号表：",
            "kotlin",
            "ohosArm64 {",
            "binaries.sharedLib {"
          ],
          "estimated_minutes": 2,
          "content": "为了便于调试崩溃，可以保留符号表：\n\n```kotlin\nohosArm64 {\n    binaries.sharedLib {\n        // 在debug和release模式，让gradle都打包带符号表的so\n        debuggable = true\n    }\n}\n```",
          "content_html": "<p>为了便于调试崩溃，可以保留符号表：</p><pre><code class=\"language-kotlin\">ohosArm64 {\n    binaries.sharedLib {\n        // 在debug和release模式，让gradle都打包带符号表的so\n        debuggable = true\n    }\n}</code></pre>"
        },
        {
          "section_id": "7ccc962770",
          "title": "9.3 配置ProGuard/R8",
          "summary": "对于生产环境，可以配置代码混淆和优化。",
          "key_points": [
            "对于生产环境，可以配置代码混淆和优化。"
          ],
          "estimated_minutes": 2,
          "content": "对于生产环境，可以配置代码混淆和优化。",
          "content_html": "<p>对于生产环境，可以配置代码混淆和优化。</p>"
        },
        {
          "section_id": "374ee98054",
          "title": "十、总结",
          "summary": "通过本教程，您已经完成了： ✅ 创建KMP多平台工程 ✅ 配置鸿蒙平台支持 ✅ 创建鸿蒙应用工程 ✅ 实现NAPI桥接 ✅ 集成Compose UI ✅ 编译和运行应用 现在...",
          "key_points": [
            "通过本教程，您已经完成了：",
            "✅ 创建KMP多平台工程",
            "✅ 配置鸿蒙平台支持",
            "✅ 创建鸿蒙应用工程"
          ],
          "estimated_minutes": 2,
          "content": "通过本教程，您已经完成了：\n\n1. ✅ 创建KMP多平台工程\n2. ✅ 配置鸿蒙平台支持\n3. ✅ 创建鸿蒙应用工程\n4. ✅ 实现NAPI桥接\n5. ✅ 集成Compose UI\n6. ✅ 编译和运行应用\n\n现在您可以：\n- 在 `commonMain` 中编写共享的业务逻辑和UI\n- 在 `ohosArm64Main` 中编写鸿蒙平台特定代码\n- 使用Compose构建现代化的跨平台UI",
          "content_html": "<p>通过本教程，您已经完成了：</p><ol><li>✅ 创建KMP多平台工程</li><li>✅ 配置鸿蒙平台支持</li><li>✅ 创建鸿蒙应用工程</li><li>✅ 实现NAPI桥接</li><li>✅ 集成Compose UI</li><li>✅ 编译和运行应用</li></ol><p>现在您可以：</p><ul><li>在 <code>commonMain</code> 中编写共享的业务逻辑和UI</li><li>在 <code>ohosArm64Main</code> 中编写鸿蒙平台特定代码</li><li>使用Compose构建现代化的跨平台UI</li></ul>"
        },
        {
          "section_id": "714f330feb",
          "title": "十一、参考资源",
          "summary": "Kotlin Multiplatform 官方文档 Compose Multiplatform 官方文档 HarmonyOS 开发者文档 --- **最后更新**: 2025...",
          "key_points": [
            "Kotlin Multiplatform 官方文档",
            "Compose Multiplatform 官方文档",
            "HarmonyOS 开发者文档",
            "---"
          ],
          "estimated_minutes": 2,
          "content": "- [Kotlin Multiplatform 官方文档](https://kotlinlang.org/docs/multiplatform.html)\n- [Compose Multiplatform 官方文档](https://www.jetbrains.com/lp/compose-multiplatform/)\n- [HarmonyOS 开发者文档](https://developer.harmonyos.com/)\n\n---\n\n**最后更新**: 2025年11月18日",
          "content_html": "<ul><li><a href=\"https://kotlinlang.org/docs/multiplatform.html\" target=\"_blank\" rel=\"noopener noreferrer\">Kotlin Multiplatform 官方文档</a></li><li><a href=\"https://www.jetbrains.com/lp/compose-multiplatform/\" target=\"_blank\" rel=\"noopener noreferrer\">Compose Multiplatform 官方文档</a></li><li><a href=\"https://developer.harmonyos.com/\" target=\"_blank\" rel=\"noopener noreferrer\">HarmonyOS 开发者文档</a></li></ul><hr /><p><strong>最后更新</strong>: 2025年11月18日</p>"
        }
      ],
      "estimated_minutes": 99
    }
  ],
  "learning_path": {
    "target_minutes": 60,
    "actual_minutes": 324,
    "sections": [
      {
        "order": 1,
        "module_id": "module-10877e53",
        "module_title": "流水线问题处理",
        "section_id": "5d0b07aea4",
        "section_title": "流水线问题处理",
        "minutes": 2,
        "reason": "建立基础认知"
      },
      {
        "order": 2,
        "module_id": "cmp-2b736961",
        "module_title": "CMP相关产物依赖层级关系",
        "section_id": "bc665bf2b3",
        "section_title": "CMP相关产物依赖层级关系",
        "minutes": 8,
        "reason": "建立基础认知"
      },
      {
        "order": 3,
        "module_id": "compose-ohos-28606dae",
        "module_title": "Compose 语义系统梳理与 OHOS 无障碍适配",
        "section_id": "6a9d4c5330",
        "section_title": "Compose 语义系统梳理与 OHOS 无障碍适配",
        "minutes": 25,
        "reason": "建立基础认知"
      },
      {
        "order": 4,
        "module_id": "cmp-for-ohos-cc7f01f0",
        "module_title": "CMP For OHOS知识地图",
        "section_id": "fe96798679",
        "section_title": "CMP For OHOS知识地图",
        "minutes": 2,
        "reason": "进入模块核心"
      },
      {
        "order": 5,
        "module_id": "demo-3ef46c0b",
        "module_title": "融合渲染demo打通流程",
        "section_id": "8c422a8dcf",
        "section_title": "融合渲染demo打通流程",
        "minutes": 15,
        "reason": "进入模块核心"
      },
      {
        "order": 6,
        "module_id": "ohrendernode-rendernodelayer-aae602d5",
        "module_title": "OHRenderNode 与 RenderNodeLayer 录制协作机制详解",
        "section_id": "8e74c3a13a",
        "section_title": "OHRenderNode 与 RenderNodeLayer 录制协作机制详解",
        "minutes": 14,
        "reason": "进入模块核心"
      },
      {
        "order": 7,
        "module_id": "module-f09e99ae",
        "module_title": "非三明治混排原理",
        "section_id": "9d3398a6ad",
        "section_title": "非三明治混排原理",
        "minutes": 16,
        "reason": "进入模块核心"
      },
      {
        "order": 8,
        "module_id": "vsync-5b772145",
        "module_title": "VSYNC空跑问题根因分析与解决方案",
        "section_id": "21f698f500",
        "section_title": "VSYNC空跑问题根因分析与解决方案",
        "minutes": 21,
        "reason": "进入模块核心"
      },
      {
        "order": 9,
        "module_id": "ohos-coil-abc42967",
        "module_title": "OHOS 下 Coil 自定义解码方案梳理",
        "section_id": "b07f3cf38b",
        "section_title": "0. Coil库的使用教程",
        "minutes": 2,
        "reason": "进入模块核心"
      },
      {
        "order": 10,
        "module_id": "savelayer-b18a6be3",
        "module_title": "saveLayer 实现方案解析",
        "section_id": "76481f50bc",
        "section_title": "saveLayer 实现方案解析",
        "minutes": 58,
        "reason": "进入模块核心"
      },
      {
        "order": 11,
        "module_id": "slottable-composition-8939c899",
        "module_title": "SlotTable 与 Composition 完整详解",
        "section_id": "57b8165d6f",
        "section_title": "SlotTable 与 Composition 完整详解",
        "minutes": 69,
        "reason": "进入模块核心"
      },
      {
        "order": 12,
        "module_id": "module-10d487ca",
        "module_title": "指令录制与绘制机制",
        "section_id": "ac1751a22b",
        "section_title": "指令录制与绘制机制",
        "minutes": 90,
        "reason": "进入模块核心"
      },
      {
        "order": 13,
        "module_id": "kmp-f03735ca",
        "module_title": "KMP工程集成鸿蒙应用完整教程",
        "section_id": "8cb4de0fa1",
        "section_title": "KMP工程集成鸿蒙应用完整教程",
        "minutes": 2,
        "reason": "进入模块核心"
      }
    ]
  },
  "generation_warnings": []
}