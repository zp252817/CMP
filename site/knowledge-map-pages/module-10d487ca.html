<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>æŒ‡ä»¤å½•åˆ¶ä¸ç»˜åˆ¶æœºåˆ¶</title>
  <style>
    :root {
      --bg: #f6f8f7;
      --card: #ffffff;
      --ink: #10231c;
      --muted: #4f6d66;
      --accent: #0f7668;
      --line: #d5e2de;
    }
    * { box-sizing: border-box; }
    body { margin: 0; font-family: "PingFang SC", "Noto Sans SC", sans-serif; background: var(--bg); color: var(--ink); }
    .wrap { max-width: 980px; margin: 0 auto; padding: 24px 18px 42px; }
    .top { display: flex; flex-wrap: wrap; gap: 10px; margin-bottom: 12px; }
    .back { color: var(--accent); text-decoration: none; font-size: 14px; }
    h1 { margin: 0 0 8px; font-size: 30px; }
    .meta { display: flex; flex-wrap: wrap; gap: 8px; margin-bottom: 12px; }
    .chip { background: #dff1ec; color: var(--accent); border-radius: 999px; padding: 4px 10px; font-size: 12px; }
    .section { background: var(--card); border: 1px solid var(--line); border-radius: 14px; padding: 14px; margin-top: 12px; box-shadow: 0 8px 24px rgba(16,35,28,.05); }
    .section-head { display: flex; justify-content: space-between; gap: 10px; align-items: baseline; }
    .section-head h2 { margin: 0; font-size: 20px; }
    .section-head span { color: var(--accent); font-size: 13px; }
    .summary { color: #48665f; margin: 8px 0; font-size: 15px; line-height: 1.65; }
    .points { margin: 0 0 8px; padding-left: 18px; color: #48665f; }
    .points li { line-height: 1.65; }
    .content { margin: 0; background: linear-gradient(180deg, #fbfefe 0%, #f7fbfa 100%); border: 1px solid var(--line); border-radius: 12px; padding: 14px; line-height: 1.7; font-size: 16px; color: #173029; }
    .content h1, .content h2, .content h3, .content h4 { margin: 14px 0 8px; line-height: 1.35; color: #0f3028; }
    .content h1:first-child, .content h2:first-child, .content h3:first-child, .content h4:first-child { margin-top: 0; }
    .content h2 { font-size: 24px; font-weight: 750; }
    .content h3 { font-size: 20px; font-weight: 700; }
    .content h4 { font-size: 17px; font-weight: 680; color: #1b4b40; }
    .content .auto-h3 { border-left: 4px solid #78b6a7; padding-left: 10px; }
    .content .auto-h4 { color: #205145; }
    .content p { margin: 0 0 9px; color: #1e3b34; }
    .content p:last-child { margin-bottom: 0; }
    .content ul, .content ol { margin: 0 0 10px; padding-left: 20px; }
    .content li + li { margin-top: 6px; }
    .content.xmind-outline { background: linear-gradient(180deg, #f8fcfb 0%, #f2f8f6 100%); }
    .content.xmind-outline ul, .content.xmind-outline ol {
      list-style: none;
      margin: 8px 0 0 0;
      padding-left: 22px;
      border-left: 1px solid #c7ddd6;
    }
    .content.xmind-outline > ul, .content.xmind-outline > ol {
      border-left: none;
      padding-left: 0;
      margin-top: 0;
    }
    .content.xmind-outline li {
      position: relative;
      margin: 8px 0;
      padding: 6px 10px;
      background: #ffffff;
      border: 1px solid #d6e7e2;
      border-radius: 10px;
      box-shadow: 0 1px 0 rgba(15, 87, 74, 0.06);
    }
    .content.xmind-outline li::before {
      content: "";
      position: absolute;
      left: -22px;
      top: 50%;
      width: 22px;
      border-top: 1px solid #c7ddd6;
      transform: translateY(-50%);
    }
    .content.xmind-outline > ul > li::before,
    .content.xmind-outline > ol > li::before { display: none; }
    .content.xmind-outline li > ul,
    .content.xmind-outline li > ol { margin-top: 8px; }
    .content blockquote { margin: 10px 0; padding: 8px 12px; border-left: 3px solid #99c6bb; background: #edf7f4; color: #375852; border-radius: 6px; }
    .content hr { border: none; border-top: 1px dashed #b8d2cb; margin: 12px 0; }
    .content a { color: #0b6d61; text-decoration: none; border-bottom: 1px dashed rgba(11,109,97,.35); }
    .content a:hover { border-bottom-style: solid; }
    .content code { font-family: "SFMono-Regular", Menlo, Consolas, monospace; }
    .content :not(pre) > code { background: #e6f2ef; color: #0f5f54; border-radius: 6px; padding: 2px 6px; }
    .content pre { margin: 10px 0; white-space: pre; overflow: auto; background: #122520; color: #e8f5f1; border-radius: 10px; padding: 12px; box-shadow: inset 0 0 0 1px rgba(124,196,178,.24); }
    .content pre code { background: transparent; color: inherit; padding: 0; border-radius: 0; }
    .content pre.auto-code { border-left: 4px solid #2ea78c; }
    .content .kv-row { display: flex; gap: 8px; align-items: baseline; flex-wrap: wrap; }
    .content .kv-key { color: #1b5e50; font-weight: 700; }
    .doc-table-wrap { overflow-x: auto; margin: 8px 0; }
    .doc-table { width: 100%; border-collapse: collapse; min-width: 640px; }
    .doc-table th, .doc-table td { border: 1px solid #c8d8d3; padding: 8px; text-align: left; vertical-align: top; }
    .doc-table th { background: #e8f4f0; }
    .doc-figure { margin: 10px 0; }
    .doc-figure img { max-width: 100%; height: auto; border: 1px solid #c8d8d3; border-radius: 8px; display: block; background: #f3f7f6; }
    .doc-figure.xmind-figure { margin: 6px 0; }
    .doc-figure.xmind-figure figcaption { margin-top: 8px; font-size: 13px; color: #496861; }
    .doc-figure .img-fallback { display: none; margin-top: 6px; font-size: 12px; color: #496861; }
    .doc-figure .img-fallback a { color: #0f7668; }
    .doc-figure.img-load-failed .img-fallback { display: block; }

    .view-controls { position: fixed; top: 12px; right: 12px; z-index: 3000; display: flex; align-items: center; gap: 6px; background: rgba(255,255,255,.94); border: 1px solid #d5e2de; border-radius: 999px; padding: 6px 8px; box-shadow: 0 6px 20px rgba(16,35,28,.12); }
    .view-controls button { border: 1px solid #c6d8d3; background: #f3faf8; color: #0f7668; border-radius: 999px; min-width: 30px; height: 30px; cursor: pointer; font-size: 14px; }
    .view-controls button:hover { background: #e3f2ee; }
    .view-controls .zoom-value { font-size: 12px; color: #3b5d56; min-width: 44px; text-align: center; }
    .zoom-root { transform-origin: top center; }
    

    .doc-figure img { cursor: zoom-in; }
    .img-modal { position: fixed; inset: 0; display: none; z-index: 4000; }
    .img-modal.open { display: block; }
    .img-modal-backdrop { position: absolute; inset: 0; background: rgba(10, 14, 18, .85); }
    .img-modal-toolbar { position: absolute; top: 12px; right: 12px; z-index: 2; display: flex; gap: 6px; align-items: center; background: rgba(255,255,255,.95); border-radius: 999px; padding: 6px 8px; }
    .img-modal-toolbar button { border: 1px solid #c6d8d3; background: #f3faf8; color: #0f7668; border-radius: 999px; min-width: 30px; height: 30px; cursor: pointer; }
    .img-modal-toolbar .zoom-value { min-width: 44px; text-align: center; font-size: 12px; color: #3b5d56; }
    .img-modal-image-wrap { position: absolute; inset: 64px 24px 24px; display: grid; place-items: center; overflow: auto; cursor: grab; user-select: none; touch-action: none; }
    .img-modal-image-wrap.dragging { cursor: grabbing; }
    .img-modal-image-wrap img { max-width: 100%; max-height: 100%; transform-origin: center center; pointer-events: none; -webkit-user-drag: none; user-select: none; }
    
  </style>
</head>
<body>
  
  <div class="view-controls" aria-label="é¡µé¢ç¼©æ”¾å·¥å…·">
    <button type="button" data-zoom="out" title="ç¼©å°">-</button>
    <button type="button" data-zoom="in" title="æ”¾å¤§">+</button>
    <button type="button" data-zoom="reset" title="é‡ç½®">100%</button>
    <span class="zoom-value" id="zoom-value">100%</span>
  </div>

  <div class="zoom-root" id="zoom-root">
  <main class="wrap">
    <div class="top">
      <a class="back" href="../knowledge-map.html">è¿”å›å…¥å£</a>
      <a class="back" id="chapter-back-link" href="../knowledge-map-chapters.html">è¿”å›ç« èŠ‚åˆ—è¡¨</a>
    </div>
    <h1>æŒ‡ä»¤å½•åˆ¶ä¸ç»˜åˆ¶æœºåˆ¶</h1>
    <div class="meta">
      <span class="chip">CMPæ¡†æ¶çŸ¥è¯†åœ°å›¾</span>
      <span class="chip">90 åˆ†é’Ÿ</span>
      <span class="chip">principle-analysis/æŒ‡ä»¤å½•åˆ¶ä¸ç»˜åˆ¶æœºåˆ¶.docx</span>
    </div>

      <section class="section">
        <div class="section-head">
          <h2>æŒ‡ä»¤å½•åˆ¶ä¸ç»˜åˆ¶æœºåˆ¶</h2>
          <span>90 åˆ†é’Ÿ</span>
        </div>
        <p class="summary">OHRender èåˆæ¸²æŸ“åŸç†è®²è§£æ–‡æ¡£ æœ¬æ–‡æ¡£è¯¦ç»†è®²è§£ CMPï¼ˆCompose Multiplatformï¼‰å¯¹æ¥ OHRender å®ç° OHOS ç»Ÿä¸€ æ¸²æŸ“æ–¹æ¡ˆä¸­çš„æŒ‡ä»¤å½•åˆ¶...</p>
        <ul class="points"><li>å•æ¬¡ç»˜åˆ¶æ“ä½œçš„è„åŒºæ›´æ–°ï¼ˆupdateDrawBoundsï¼‰</li><li>æœ€ç»ˆè„åŒºçš„ç”Ÿæˆï¼ˆgetFinishDrawBoundsï¼‰</li></ul>
        <div class="content rich"><h1><strong>OHRender èåˆæ¸²æŸ“åŸç†è®²è§£æ–‡æ¡£</strong></h1>
<p>æœ¬æ–‡æ¡£è¯¦ç»†è®²è§£ CMPï¼ˆCompose Multiplatformï¼‰å¯¹æ¥ OHRender å®ç° OHOS ç»Ÿä¸€  æ¸²æŸ“æ–¹æ¡ˆä¸­çš„æŒ‡ä»¤å½•åˆ¶ä¸ç»˜åˆ¶æœºåˆ¶ã€‚</p>
<hr />
<h2><strong>ç¬¬ä¸€éƒ¨åˆ†ï¼šæ¦‚è¿°ä¸èƒŒæ™¯</strong></h2>
<h3><strong>1.1 ä»€ä¹ˆæ˜¯èåˆæ¸²æŸ“</strong></h3>
<p><strong>èåˆæ¸²æŸ“</strong> æ˜¯æŒ‡å°† Compose Multiplatform çš„ç»˜åˆ¶å‘½ä»¤è½¬æ¢ä¸º OHOSï¼ˆOpenHarmony OSï¼‰åŸç”Ÿæ¸²æŸ“æŒ‡ä»¤çš„æŠ€æœ¯æ–¹æ¡ˆã€‚å…¶æ ¸å¿ƒç›®æ ‡æ˜¯ï¼š</p>
<ol>
<li><strong>è·¨å¹³å°ä¸€è‡´æ€§</strong>ï¼šä½¿ç”¨ç»Ÿä¸€çš„ Compose UI ä»£ç ï¼Œåœ¨ OHOS å¹³å°è·å¾—åŸç”Ÿæ¸²æŸ“æ€§èƒ½</li>
<li><strong>é«˜æ€§èƒ½</strong>ï¼šåˆ©ç”¨ OHOS çš„ RenderService è¿›è¡Œç¡¬ä»¶åŠ é€Ÿæ¸²æŸ“</li>
<li><strong>ç»†ç²’åº¦æ›´æ–°</strong>ï¼šæ”¯æŒæŒ‰èŠ‚ç‚¹çº§åˆ«çš„è„åŒºç®¡ç†ï¼Œé¿å…å…¨å±é‡ç»˜</li>
</ol>
<h3><strong>1.2 æŠ€æœ¯æ¶æ„æ€»è§ˆ</strong></h3>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Compose UI (Kotlin) â”‚
â”‚ å£°æ˜å¼ UI å®šä¹‰ @Composable â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”‚
â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ RenderNodeLayer (Kotlin) â”‚
â”‚ å›¾å±‚ç®¡ç† + Picture å½•åˆ¶/ç¼“å­˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”‚ JNI
â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ SkPictureRecorder (C++) â”‚
â”‚ åˆ›å»º Canvas + å½•åˆ¶ç»˜åˆ¶å‘½ä»¤ + ç”Ÿæˆ Picture â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”‚
â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ SkOHPicture + OHRenderNode (C++) â”‚
â”‚ Picture/Node æ¨¡å¼å†³ç­– + æ¸²æŸ“èŠ‚ç‚¹æ ‘ç®¡ç† â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”‚
â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ OHOS RenderService â”‚
â”‚ ç¡¬ä»¶åŠ é€Ÿæ¸²æŸ“ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></pre>
<hr />
<figure class="doc-figure"><img src="../knowledge-map-assets/module-10d487ca-1431f05b49.png" alt="æŒ‡ä»¤å½•åˆ¶ä¸ç»˜åˆ¶æœºåˆ¶ å›¾ç¤º" /></figure>
<h2><strong>ç¬¬äºŒéƒ¨åˆ†ï¼šæ ¸å¿ƒæ¦‚å¿µ</strong></h2>
<p>æœ¬éƒ¨åˆ†æŒ‰ç…§<strong>ä¾èµ–å…³ç³»ç”±åº•å‘ä¸Š</strong>çš„é¡ºåºä»‹ç» 6 ä¸ªæ ¸å¿ƒç±»ã€‚</p>
<h3><strong>2.1 OH_Drawing_RecordCmdï¼ˆåº•å±‚ï¼‰</strong></h3>
<p><strong>å®šä½</strong>ï¼šOHOS åŸç”Ÿç»˜åˆ¶å‘½ä»¤çš„å®¹å™¨</p>
<pre><code>// OHOS ç³»ç»Ÿæä¾›çš„ç»˜åˆ¶å‘½ä»¤å½•åˆ¶ API
OH_Drawing_RecordCmdUtils* recorder;
OH_Drawing_Canvas* canvas;
OH_Drawing_RecordCmd* recordCmd;
â€‹
// å¼€å§‹å½•åˆ¶
OH_Drawing_RecordCmdUtilsBeginRecording(recorder, width, height, &amp;canvas);
â€‹
// åœ¨ canvas ä¸Šæ‰§è¡Œç»˜åˆ¶æ“ä½œ...
â€‹
// ç»“æŸå½•åˆ¶ï¼Œè·å–å‘½ä»¤
OH_Drawing_RecordCmdUtilsFinishRecording(recorder, &amp;recordCmd);</code></pre>
<p><strong>ç‰¹ç‚¹</strong>ï¼š</p>
<ul>
<li>ç”± OHOS ç³»ç»Ÿç®¡ç†ç”Ÿå‘½å‘¨æœŸ</li>
<li>å¯è¢«å¤šæ¬¡å›æ”¾æ‰§è¡Œ</li>
<li>æ”¯æŒåµŒå¥—å›æ”¾ï¼ˆ<code>OH_Drawing_CanvasDrawRecordCmdNesting</code>ï¼‰</li>
</ul>
<h3><strong>2.2 OHRenderNodeï¼ˆæ¸²æŸ“èŠ‚ç‚¹ï¼‰</strong></h3>
<p><strong>å®šä½</strong>ï¼šæ¸²æŸ“èŠ‚ç‚¹ï¼Œç®¡ç†ç»˜åˆ¶å‘½ä»¤å’ŒèŠ‚ç‚¹æ ‘ç»“æ„</p>
<pre><code>class OHRenderNode {
// === æ ‡è¯† ===
int fNodeId; // èŠ‚ç‚¹å”¯ä¸€ ID
// === ç»˜åˆ¶åŒºåŸŸ ===
SkRect fNowFrame; // å½“å‰å¸§è¾¹ç•Œï¼ˆç”¨äºå¸ƒå±€ï¼‰
SkRect fRealFrame; // å®é™…ç»˜åˆ¶è¾¹ç•Œï¼ˆè„åŒºï¼‰
bool fNoLimitSize; // æ˜¯å¦æ— å°ºå¯¸é™åˆ¶
// === ç»˜åˆ¶å‘½ä»¤ ===
OH_Drawing_RecordCmd* fPictureCmd; // å½•åˆ¶çš„ç»˜åˆ¶å‘½ä»¤
// === èŠ‚ç‚¹æ ‘ç»“æ„ ===
std::shared_ptr&lt;OHRenderNode&gt; fParent; // çˆ¶èŠ‚ç‚¹
std::list&lt;std::shared_ptr&lt;OHRenderNode&gt;&gt; fChildList; // å­èŠ‚ç‚¹åˆ—è¡¨
// === å˜æ¢ä¸çŠ¶æ€ ===
SkMatrix fFatherMatrix; // ç›¸å¯¹çˆ¶èŠ‚ç‚¹çš„å˜æ¢çŸ©é˜µ
bool fDrawInPicture; // æ¨¡å¼æ ‡å¿—ï¼štrue=Pictureæ¨¡å¼, false=Nodeæ¨¡å¼
bool fVisible; // å¯è§æ€§
};</code></pre>
<p><strong>æ ¸å¿ƒæ–¹æ³•</strong>ï¼š</p>
<div class="doc-table-wrap"><table class="doc-table"><thead><tr><th>æ–¹æ³•</th><th>ä½œç”¨</th></tr></thead><tbody><tr><td>pictureDraw()</td><td>Picture æ¨¡å¼ä¸‹æ‰§è¡Œç»˜åˆ¶</td></tr><tr><td>nodeDraw()</td><td>Node æ¨¡å¼ä¸‹æ‰§è¡Œç»˜åˆ¶</td></tr><tr><td>appendChild()</td><td>æ·»åŠ å­èŠ‚ç‚¹</td></tr><tr><td>makeClone()</td><td>å…‹éš†èŠ‚ç‚¹ï¼ˆç”¨äºå¤šå®ä¾‹åœºæ™¯ï¼‰</td></tr></tbody></table></div>
<h3><strong>2.3 SkCanvasï¼ˆç»˜åˆ¶æ¥å£ï¼‰</strong></h3>
<p><strong>å®šä½</strong>ï¼šç»˜åˆ¶å‘½ä»¤çš„å½•åˆ¶æ¥å£ï¼Œæ˜¯ Skia ç»˜åˆ¶ API ä¸ OHOS OH_Drawing API ä¹‹é—´çš„<strong>æ ¸å¿ƒæ¡¥æ¥å±‚</strong></p>
<p><strong>æ ¸å¿ƒèŒè´£</strong>ï¼š</p>
<ol>
<li><strong>å‘½ä»¤è½¬æ¢</strong>ï¼šå°† Skia ç»˜åˆ¶è°ƒç”¨è½¬æ¢ä¸º OH_Drawing è°ƒç”¨</li>
<li><strong>è„åŒºè·Ÿè¸ª</strong>ï¼šåŠ¨æ€è®¡ç®—å®é™…ç»˜åˆ¶è¾¹ç•Œï¼Œç”¨äºä¼˜åŒ–æ¸²æŸ“</li>
<li><strong>çŠ¶æ€ç®¡ç†</strong>ï¼šç®¡ç†å˜æ¢çŸ©é˜µã€è£å‰ªåŒºåŸŸã€ç”»ç¬”çŠ¶æ€ç­‰</li>
<li><strong>åµŒå¥—æ”¯æŒ</strong>ï¼šæ”¯æŒ SubCanvas æœºåˆ¶å¤„ç†åµŒå¥— Layer</li>
</ol>
<pre><code>class SkCanvas {
// === åº•å±‚ç”»å¸ƒ ===
OH_Drawing_Canvas*; // OHOS åŸç”Ÿç”»å¸ƒï¼ˆå®é™…æ‰§è¡Œç»˜åˆ¶ï¼‰
// === å…³è”èŠ‚ç‚¹ ===
OHRenderNode* fOHNode; // å½“å‰å…³è”çš„æ¸²æŸ“èŠ‚ç‚¹
// === å˜æ¢çŠ¶æ€ ===
SkMatrix fInitMatrix; // åˆå§‹å˜æ¢çŸ©é˜µ
SkMatrix fTotalMatrix; // ç´¯ç§¯å˜æ¢çŸ©é˜µ
std::vector&lt;SkMatrix&gt; fMatrixStack; // çŸ©é˜µæ ˆï¼ˆsave/restoreï¼‰
// === è£å‰ªçŠ¶æ€ ===
SkRect fClipBounds; // å½“å‰è£å‰ªè¾¹ç•Œ
std::vector&lt;SkRect&gt; fClipStack; // è£å‰ªæ ˆ
// === è„åŒºè·Ÿè¸ª ===
SkRect fRecordCull; // å½•åˆ¶æ—¶æŒ‡å®šçš„è¾¹ç•Œ
SkRect fDrawBounds; // å®é™…ç»˜åˆ¶è¾¹ç•Œï¼ˆåŠ¨æ€è®¡ç®—ï¼‰
bool fHasDrawBounds; // æ˜¯å¦æœ‰æœ‰æ•ˆç»˜åˆ¶è¾¹ç•Œ
// === å­ç”»å¸ƒï¼ˆåµŒå¥—å½•åˆ¶ï¼‰ ===
SkCanvas* fSubCanvas; // å­ç”»å¸ƒï¼ˆåµŒå¥— Layer ä½¿ç”¨ï¼‰
SkPictureRecorder* fSubRecorder; // å­å½•åˆ¶å™¨
std::vector&lt;sk_sp&lt;SkPicture&gt;&gt; fSubPics; // å·²å®Œæˆçš„å­ Picture åˆ—è¡¨
// === çŠ¶æ€æ ‡å¿— ===
bool fIsPlayingBack; // æ˜¯å¦æ­£åœ¨å›æ”¾å­ Picture
bool fForceDrawInPicture; // æ˜¯å¦å¼ºåˆ¶ Picture æ¨¡å¼
int fSaveLayerDepth; // SaveLayer åµŒå¥—æ·±åº¦
};</code></pre>
<p><strong>æ ¸å¿ƒæ–¹æ³•</strong>ï¼š</p>
<div class="doc-table-wrap"><table class="doc-table"><thead><tr><th>æ–¹æ³•</th><th>ä½œç”¨</th></tr></thead><tbody><tr><td>save() / restore()</td><td>ä¿å­˜/æ¢å¤ç”»å¸ƒçŠ¶æ€ï¼ˆçŸ©é˜µã€è£å‰ªï¼‰</td></tr><tr><td>translate()</td><td>å¹³ç§»å˜æ¢</td></tr><tr><td>rotate()</td><td>æ—‹è½¬å˜æ¢</td></tr><tr><td>scale()</td><td>ç¼©æ”¾å˜æ¢</td></tr><tr><td>concat()</td><td>è¿æ¥å˜æ¢çŸ©é˜µ</td></tr><tr><td>clipRect()</td><td>çŸ©å½¢è£å‰ª</td></tr><tr><td>clipPath()</td><td>è·¯å¾„è£å‰ª</td></tr><tr><td>drawRect()</td><td>ç»˜åˆ¶çŸ©å½¢</td></tr><tr><td>drawPath()</td><td>ç»˜åˆ¶è·¯å¾„</td></tr><tr><td>drawImage()</td><td>ç»˜åˆ¶å›¾åƒ</td></tr><tr><td>drawText()</td><td>ç»˜åˆ¶æ–‡æœ¬</td></tr><tr><td>drawPicture()</td><td>ç»˜åˆ¶ Pictureï¼ˆè§¦å‘å›æ”¾ï¼‰</td></tr><tr><td>saveLayer()</td><td>åˆ›å»ºç¦»å±å›¾å±‚</td></tr><tr><td>beginSubCanvas()</td><td>åˆ›å»ºå­ç”»å¸ƒï¼ˆåµŒå¥—å½•åˆ¶ï¼‰</td></tr><tr><td>finishSubCanvas()</td><td>å®Œæˆå­ç”»å¸ƒå½•åˆ¶</td></tr><tr><td>getFinishDrawBounds()</td><td>è·å–æœ€ç»ˆè„åŒºè¾¹ç•Œ</td></tr><tr><td>getOHNode()</td><td>è·å–å…³è”çš„ OHRenderNode</td></tr></tbody></table></div>
<p><strong>ç»˜åˆ¶å‘½ä»¤è½¬æ¢ç¤ºä¾‹</strong>ï¼š</p>
<pre><code>// ç¤ºä¾‹ 1ï¼šç»˜åˆ¶çŸ©å½¢
void SkCanvas::drawRect(const SkRect&amp; rect, const SkPaint&amp; paint) {
// 1. è½¬æ¢ç”»ç¬”
OH_Drawing_Brush* brush = paint.asBrush();
OH_Drawing_Pen* pen = paint.asPen();
// 2. è®¾ç½®ç”»ç¬”åˆ° OH_Drawing_Canvas
if (brush) OH_Drawing_CanvasAttachBrush(fOHCanvas, brush);
if (pen) OH_Drawing_CanvasAttachPen(fOHCanvas, pen);
// 3. è½¬æ¢çŸ©å½¢å¹¶ç»˜åˆ¶
OH_Drawing_Rect* ohRect = toOHRect(rect);
OH_Drawing_CanvasDrawRect(fOHCanvas, ohRect);
// 4. æ›´æ–°è„åŒºè¾¹ç•Œ
updateDrawBounds(rect);
// 5. æ¸…ç†
OH_Drawing_RectDestroy(ohRect);
if (brush) OH_Drawing_CanvasDetachBrush(fOHCanvas);
if (pen) OH_Drawing_CanvasDetachPen(fOHCanvas);
}
â€‹
// ç¤ºä¾‹ 2ï¼šç»˜åˆ¶è·¯å¾„
void SkCanvas::drawPath(const SkPath&amp; path, const SkPaint&amp; paint) {
OH_Drawing_Path* ohPath = path.toOHPath();
OH_Drawing_CanvasDrawPath(fOHCanvas, ohPath);
// ä½¿ç”¨è·¯å¾„è¾¹ç•Œæ›´æ–°è„åŒº
updateDrawBounds(path.getBounds());
}
â€‹
// ç¤ºä¾‹ 3ï¼šç»˜åˆ¶å›¾åƒ
void SkCanvas::drawImage(const sk_sp&lt;SkImage&gt;&amp; image, SkScalar x, SkScalar y,
const SkPaint* paint) {
OH_Drawing_Image* ohImage = image-&gt;toOHImage();
OH_Drawing_CanvasDrawImage(fOHCanvas, ohImage, x, y, ...);
// è®¡ç®—å›¾åƒç»˜åˆ¶è¾¹ç•Œ
SkRect bounds = SkRect::MakeXYWH(x, y, image-&gt;width(), image-&gt;height());
updateDrawBounds(bounds);
}</code></pre>
<p><strong>è„åŒºè·Ÿè¸ªæœºåˆ¶</strong>ï¼š</p>
<pre><code>// æ¯æ¬¡ç»˜åˆ¶æ“ä½œéƒ½ä¼šæ›´æ–°è„åŒº
void SkCanvas::updateDrawBounds(const SkRect&amp; bounds) {
// å°†ç»˜åˆ¶åŒºåŸŸé€šè¿‡å½“å‰å˜æ¢çŸ©é˜µæ˜ å°„
SkRect mappedBounds;
fTotalMatrix.mapRect(&amp;mappedBounds, bounds);
// ä¸è£å‰ªåŒºåŸŸæ±‚äº¤
if (!mappedBounds.intersect(fClipBounds)) {
return; // è¢«å®Œå…¨è£å‰ªï¼Œä¸å½±å“è„åŒº
}
// åˆå¹¶åˆ°æ€»è„åŒº
if (fHasDrawBounds) {
fDrawBounds.join(mappedBounds);
} else {
fDrawBounds = mappedBounds;
fHasDrawBounds = true;
}
}
â€‹
// è·å–æœ€ç»ˆè„åŒºï¼ˆå½•åˆ¶ç»“æŸæ—¶è°ƒç”¨ï¼‰
std::optional&lt;SkRect&gt; SkCanvas::getFinishDrawBounds() {
if (!fHasDrawBounds) {
return std::nullopt; // æ— ç»˜åˆ¶å†…å®¹
}
// åå‘æ˜ å°„åˆ°å½•åˆ¶åæ ‡ç³»
SkMatrix inverse;
if (fInitMatrix.invert(&amp;inverse)) {
SkRect result;
inverse.mapRect(&amp;result, fDrawBounds);
return result;
}
return fDrawBounds;
}</code></pre>
<p>è„åŒºè·Ÿè¸ªçš„æ ¸å¿ƒåŸç†æ˜¯<strong>åŠ¨æ€è®°å½•æ‰€æœ‰ç»˜åˆ¶æ“ä½œå®é™…å½±å“çš„æœ‰æ•ˆåŒºåŸŸ</strong>ï¼Œé€šè¿‡ç»“åˆå˜æ¢çŸ©é˜µã€è£å‰ªåŒºåŸŸå’ŒåŒºåŸŸåˆå¹¶ç­–ç•¥ï¼Œæœ€ç»ˆç”Ÿæˆéœ€è¦æ›´æ–°æˆ–å¤„ç†çš„åŒºåŸŸé›†åˆã€‚ä»¥ä¸‹æ˜¯åŸºäºä»£ç çš„å…·ä½“å®ç°é€»è¾‘è§£æï¼š</p>
<p><strong>1. å•æ¬¡ç»˜åˆ¶æ“ä½œçš„è„åŒºæ›´æ–°ï¼ˆ</strong><strong><code>updateDrawBounds</code></strong><strong>ï¼‰</strong></p>
<p>æ¯æ¬¡ç»˜åˆ¶æ“ä½œï¼ˆå¦‚ç”»çº¿ã€å¡«å……å›¾å½¢ç­‰ï¼‰è§¦å‘æ­¤å‡½æ•°ï¼Œæ ¸å¿ƒæ­¥éª¤å¦‚ä¸‹ï¼š</p>
<ul>
<li><strong>å˜æ¢æ˜ å°„</strong>ï¼šå°†ç»˜åˆ¶çš„åŸå§‹è¾¹ç•Œ <code>bounds</code> é€šè¿‡å½“å‰æ€»å˜æ¢çŸ©é˜µ <code>fTotalMatrix</code> æ˜ å°„åˆ°ç›®æ ‡ç©ºé—´ï¼ˆä¾‹å¦‚ç”»å¸ƒå¯èƒ½ç»è¿‡å¹³ç§»ã€æ—‹è½¬ã€ç¼©æ”¾ç­‰å˜æ¢ï¼Œéœ€å°†ç»˜åˆ¶åŒºåŸŸè½¬æ¢åˆ°å®é™…ç”Ÿæ•ˆçš„åæ ‡ç³»ï¼‰ã€‚å¾—åˆ° <code>mappedBounds</code>ã€‚</li>
<li><strong>è£å‰ªè¿‡æ»¤</strong>ï¼šå°†æ˜ å°„åçš„åŒºåŸŸ <code>mappedBounds</code> ä¸å½“å‰ç”»å¸ƒçš„è£å‰ªåŒºåŸŸ <code>fClipBounds</code> æ±‚äº¤ã€‚è‹¥å®Œå…¨è¢«è£å‰ªï¼ˆæ— äº¤é›†ï¼‰ï¼Œåˆ™æ­¤æ¬¡ç»˜åˆ¶ä¸å½±å“è„åŒºï¼Œç›´æ¥è¿”å›ï¼›å¦åˆ™ä¿ç•™äº¤é›†éƒ¨åˆ†ï¼ˆå³å®é™…å¯è§çš„ç»˜åˆ¶åŒºåŸŸï¼‰ã€‚</li>
<li><strong>åˆå¹¶è„åŒº</strong>ï¼šå°†è¿‡æ»¤åçš„æœ‰æ•ˆåŒºåŸŸåˆå¹¶åˆ°æ€»è„åŒº <code>fDrawBounds</code> ä¸­ã€‚è‹¥æ€»è„åŒºå°šæœªåˆå§‹åŒ–ï¼ˆ<code>fHasDrawBounds</code> ä¸º <code>false</code>ï¼‰ï¼Œåˆ™ç›´æ¥èµ‹å€¼ï¼›å¦åˆ™é€šè¿‡ <code>join</code> æ“ä½œåˆå¹¶ä¸¤ä¸ªåŒºåŸŸï¼ˆå–å¹¶é›†ï¼‰ã€‚</li>
</ul>
<p><strong>2. æœ€ç»ˆè„åŒºçš„ç”Ÿæˆï¼ˆ</strong><strong><code>getFinishDrawBounds</code></strong><strong>ï¼‰</strong></p>
<p>ç»˜åˆ¶æ“ä½œå…¨éƒ¨å®Œæˆåï¼ˆå¦‚å½•åˆ¶ç»“æŸï¼‰ï¼Œè°ƒç”¨æ­¤å‡½æ•°è·å–æœ€ç»ˆè„åŒºï¼š</p>
<ul>
<li><strong>æ— ç»˜åˆ¶å†…å®¹åˆ¤æ–­</strong>ï¼šè‹¥æ€»è„åŒºæœªåˆå§‹åŒ–ï¼ˆ<code>fHasDrawBounds</code> ä¸º <code>false</code>ï¼‰ï¼Œè¿”å› <code>std::nullopt</code> è¡¨ç¤ºæ— æœ‰æ•ˆç»˜åˆ¶ã€‚</li>
<li><strong>åæ ‡ç³»åå‘æ˜ å°„</strong>ï¼šç”±äºè„åŒº <code>fDrawBounds</code> æ˜¯åœ¨ç»è¿‡åˆå§‹çŸ©é˜µ <code>fInitMatrix</code> å˜æ¢åçš„åæ ‡ç³»ä¸­è®°å½•çš„ï¼Œéœ€é€šè¿‡å…¶é€†çŸ©é˜µ <code>inverse</code> å°†è„åŒºåå‘æ˜ å°„å›åŸå§‹å½•åˆ¶åæ ‡ç³»ï¼ˆç¡®ä¿è„åŒºä¸ç”¨æˆ·æœ€åˆæ“ä½œçš„åæ ‡ç³»ä¸€è‡´ï¼‰ã€‚è‹¥é€†çŸ©é˜µä¸å­˜åœ¨ï¼ˆä¸å¯é€†ï¼‰ï¼Œåˆ™ç›´æ¥è¿”å›å½“å‰è„åŒºã€‚</li>
</ul>
<p><strong>å…³é”®è®¾è®¡æ€æƒ³</strong></p>
<ul>
<li><strong>å˜æ¢æ„ŸçŸ¥</strong>ï¼šè„åŒºå§‹ç»ˆè·Ÿè¸ªâ€œå®é™…ç”Ÿæ•ˆâ€çš„ç»˜åˆ¶åŒºåŸŸï¼Œè€ŒéåŸå§‹ç»˜åˆ¶æŒ‡ä»¤çš„è¾¹ç•Œã€‚ä¾‹å¦‚ï¼Œä¸€ä¸ªè¢«ç¼©æ”¾çš„åœ†å½¢ï¼Œå…¶è„åŒºä¼šæ˜¯ç¼©æ”¾åçš„æ¤­åœ†åŒºåŸŸã€‚</li>
<li><strong>è£å‰ªä¼˜åŒ–</strong>ï¼šä»…ä¿ç•™è¢«è£å‰ªåŒºåŸŸè¦†ç›–çš„éƒ¨åˆ†ï¼Œé¿å…æ— æ•ˆåŒºåŸŸçš„å†—ä½™è®°å½•ã€‚</li>
<li><strong>åŒºåŸŸåˆå¹¶</strong>ï¼šé€šè¿‡é€æ­¥åˆå¹¶æ¯æ¬¡ç»˜åˆ¶çš„æœ‰æ•ˆåŒºåŸŸï¼Œæœ€ç»ˆå¾—åˆ°æ‰€æœ‰éœ€è¦å¤„ç†çš„åŒºåŸŸçš„å¹¶é›†ï¼ˆæ€»è„åŒºï¼‰ã€‚</li>
<li><strong>åæ ‡ç³»ä¸€è‡´æ€§</strong>ï¼šæœ€ç»ˆè„åŒºåå‘æ˜ å°„å›åŸå§‹åæ ‡ç³»ï¼Œä¿è¯ç»“æœä¸ç”¨æˆ·è§†è§’ä¸€è‡´ï¼Œä¾¿äºåç»­å¤„ç†ï¼ˆå¦‚é‡ç»˜ã€ç¢°æ’æ£€æµ‹ç­‰ï¼‰ã€‚</li>
</ul>
<p><strong>æ€»ç»“</strong></p>
<p>è„åŒºè·Ÿè¸ªé€šè¿‡<strong>å˜æ¢æ˜ å°„â†’è£å‰ªè¿‡æ»¤â†’åŒºåŸŸåˆå¹¶</strong>çš„æµç¨‹ï¼ŒåŠ¨æ€ç»´æŠ¤æ‰€æœ‰ç»˜åˆ¶æ“ä½œçš„å®é™…æœ‰æ•ˆåŒºåŸŸï¼Œæœ€ç»ˆè¾“å‡ºä¸€ä¸ªç´§å‡‘çš„ã€åæ ‡å¯¹é½çš„åŒºåŸŸé›†åˆï¼Œç”¨äºé«˜æ•ˆå¤„ç†éœ€è¦æ›´æ–°çš„å†…å®¹ï¼ˆå¦‚ç•Œé¢é‡ç»˜ã€ç¦»å±æ¸²æŸ“ç­‰ï¼‰ã€‚</p>
<p><strong>çŠ¶æ€ä¿å­˜ä¸æ¢å¤</strong>ï¼š</p>
<pre><code>void SkCanvas::save() {
// ä¿å­˜å˜æ¢çŸ©é˜µ
fMatrixStack.push_back(fTotalMatrix);
// ä¿å­˜è£å‰ªåŒºåŸŸ
fClipStack.push_back(fClipBounds);
// è°ƒç”¨ OH_Drawing ä¿å­˜
OH_Drawing_CanvasSave(fOHCanvas);
}
â€‹
void SkCanvas::restore() {
// æ¢å¤å˜æ¢çŸ©é˜µ
if (!fMatrixStack.empty()) {
fTotalMatrix = fMatrixStack.back();
fMatrixStack.pop_back();
}
// æ¢å¤è£å‰ªåŒºåŸŸ
if (!fClipStack.empty()) {
fClipBounds = fClipStack.back();
fClipStack.pop_back();
}
// è°ƒç”¨ OH_Drawing æ¢å¤
OH_Drawing_CanvasRestore(fOHCanvas);
}</code></pre>
<h3><strong>2.4 SkPicture / SkOHPictureï¼ˆç»˜åˆ¶å‘½ä»¤å®¹å™¨ï¼‰</strong></h3>
<p><strong>å®šä½</strong>ï¼šä¸å¯å˜çš„ç»˜åˆ¶å‘½ä»¤å®¹å™¨ï¼Œæ”¯æŒå¤šæ¬¡å›æ”¾</p>
<pre><code>class SkOHPicture final : public SkPicture {
// === è¾¹ç•Œä¿¡æ¯ ===
SkRect fCull; // è£å‰ªè¾¹ç•Œï¼ˆè„åŒºï¼‰
bool fNoLimitDraw; // æ— é™åˆ¶ç»˜åˆ¶æ ‡å¿—
// === ç»˜åˆ¶å‘½ä»¤ ===
OHDrawingRecordCmdSPtr fOHRecordCmd; // OH ç»˜åˆ¶å‘½ä»¤ï¼ˆæ™ºèƒ½æŒ‡é’ˆï¼‰
// === èŠ‚ç‚¹ç®¡ç† ===
std::shared_ptr&lt;OHRenderNode&gt; fOriginNode; // åŸå§‹èŠ‚ç‚¹
mutable std::shared_ptr&lt;OHRenderNode&gt; fNowCacheNode;// å½“å‰ä½¿ç”¨çš„èŠ‚ç‚¹
// å…‹éš†èŠ‚ç‚¹ç¼“å­˜
mutable std::list&lt;std::shared_ptr&lt;OHRenderNode&gt;&gt; fCacheCloneNodes;
// æœªä½¿ç”¨èŠ‚ç‚¹æ± 
mutable std::list&lt;std::shared_ptr&lt;OHRenderNode&gt;&gt; fUnusedCloneNodes;
// === çŠ¶æ€æ ‡å¿— ===
mutable bool fPlaybackInNode; // æ˜¯å¦åœ¨ Node æ¨¡å¼å›æ”¾
bool fCanPlaybackInPicture; // æ˜¯å¦å¯ä»¥åœ¨ Picture æ¨¡å¼å›æ”¾
// === å­ Picture ===
std::vector&lt;sk_sp&lt;SkPicture&gt;&gt; fSubPics; // åµŒå¥—çš„å­ Picture
};</code></pre>
<p><strong>æ ¸å¿ƒæ–¹æ³•</strong>ï¼š</p>
<pre><code>// å›æ”¾æ–¹æ³• - æ ¸å¿ƒå†³ç­–é€»è¾‘æ‰€åœ¨
void playback(SkCanvas* canvas, AbortCallback* callback) const override;</code></pre>
<h3><strong>2.5 SkPictureRecorderï¼ˆå‘½ä»¤å½•åˆ¶å™¨ï¼‰</strong></h3>
<p><strong>å®šä½</strong>ï¼šç®¡ç† Canvas å’Œ OHRenderNode çš„åˆ›å»ºï¼Œç”Ÿæˆ SkOHPicture</p>
<pre><code>class SkPictureRecorder {
// === å½•åˆ¶å™¨ ===
OH_Drawing_RecordCmdUtils* fOHRecorder; // OHOS å½•åˆ¶å·¥å…·
// === å½“å‰å½•åˆ¶çŠ¶æ€ ===
SkCanvas* fRecordCanvas; // å½“å‰å½•åˆ¶ç”¨çš„ Canvas
bool fActivelyRecording; // æ˜¯å¦æ­£åœ¨å½•åˆ¶
SkRect fCullRect; // å½•åˆ¶è¾¹ç•Œ
// === èŠ‚ç‚¹ç®¡ç† ===
std::shared_ptr&lt;OHRenderNode&gt; fNowOHNode; // å½“å‰å…³è”çš„èŠ‚ç‚¹
};</code></pre>
<p><strong>æ ¸å¿ƒ API</strong>ï¼š</p>
<pre><code>// å¼€å§‹å½•åˆ¶ï¼Œè¿”å›å¯ç”¨äºç»˜åˆ¶çš„ Canvas
SkCanvas* beginRecording(const SkRect&amp; bounds);
â€‹
// ç»“æŸå½•åˆ¶ï¼Œç”Ÿæˆ Picture
sk_sp&lt;SkPicture&gt; finishRecordingAsPicture();</code></pre>
<h3><strong>2.6 OwnedLayer / RenderNodeLayerï¼ˆCompose å›¾å±‚ï¼‰</strong></h3>
<p><strong>å®šä½</strong>ï¼šCompose UI å±‚çš„<strong>å›¾å±‚æŠ½è±¡</strong>ï¼Œç®¡ç†å˜æ¢ã€è£å‰ªã€é€æ˜åº¦ç­‰å±æ€§</p>
<pre><code>internal class RenderNodeLayer(
private var density: Density,
private val invalidateParentLayer: () -&gt; Unit,
private val drawBlock: (Canvas) -&gt; Unit,
private val onDestroy: () -&gt; Unit = {}
) : OwnedLayer {
// === Picture å½•åˆ¶ ===
private val pictureRecorder = PictureRecorder()
private var picture: Picture? = null // ç¼“å­˜çš„ Picture
// === å›¾å±‚å±æ€§ ===
internal val matrix = Matrix() // å˜æ¢çŸ©é˜µ
private var transformOrigin: TransformOrigin
private var translationX/Y/Z: Float
private var rotationX/Y/Z: Float
private var scaleX/Y: Float
private var alpha: Float // é€æ˜åº¦
private var clip: Boolean // è£å‰ªå¼€å…³
private var shadowElevation: Float // é˜´å½±é«˜åº¦
// === æ ¸å¿ƒæ–¹æ³• ===
override fun drawLayer(canvas: Canvas) { ... }
override fun invalidate() { ... }
}</code></pre>
<h3><strong>2.7 æ ¸å¿ƒæ¦‚å¿µå…³ç³»å›¾</strong></h3>
<figure class="doc-figure"><img src="../knowledge-map-assets/module-10d487ca-d1b53e4ee8.png" alt="æŒ‡ä»¤å½•åˆ¶ä¸ç»˜åˆ¶æœºåˆ¶ å›¾ç¤º" /></figure>
<hr />
<h2><strong>ç¬¬ä¸‰éƒ¨åˆ†ï¼šå¯¹è±¡å…³ç³»</strong></h2>
<h3><strong>3.1 æ•°é‡å…³ç³»æ¦‚è¿°</strong></h3>
<div class="doc-table-wrap"><table class="doc-table"><thead><tr><th>æºå¯¹è±¡</th><th>ç›®æ ‡å¯¹è±¡</th><th>å…³ç³»</th><th>è¯´æ˜</th></tr></thead><tbody><tr><td>OwnedLayer</td><td>SkPictureRecorder</td><td>1:1</td><td>æ¯ä¸ª Layer æŒæœ‰ä¸€ä¸ª Recorder</td></tr><tr><td>OwnedLayer</td><td>SkOHPicture</td><td>1:0..1</td><td>ç¼“å­˜çš„ Pictureï¼Œinvalidate æ—¶æ¸…ç©º</td></tr><tr><td>SkOHPicture</td><td>OHRenderNode (Origin)</td><td>1:1</td><td>åˆ›å»ºæ—¶å…³è”çš„åŸå§‹èŠ‚ç‚¹</td></tr><tr><td>SkOHPicture</td><td>OHRenderNode (Cache)</td><td>1:N</td><td>å¤šæ¬¡ Node æ¨¡å¼å›æ”¾æ—¶åˆ›å»ºå…‹éš†</td></tr><tr><td>OHRenderNode</td><td>OHRenderNode (Child)</td><td>1:N</td><td>çˆ¶å­èŠ‚ç‚¹æ ‘ç»“æ„</td></tr></tbody></table></div>
<h3><strong>3.2 ç±»å›¾</strong></h3>
<figure class="doc-figure"><img src="../knowledge-map-assets/module-10d487ca-ec5ca256af.png" alt="æŒ‡ä»¤å½•åˆ¶ä¸ç»˜åˆ¶æœºåˆ¶ å›¾ç¤º" /></figure>
<p><strong>å›¾ä¾‹è¯´æ˜</strong>ï¼š</p>
<div class="doc-table-wrap"><table class="doc-table"><thead><tr><th>å±‚çº§</th><th>è¯­è¨€</th><th>è¯´æ˜</th></tr></thead><tbody><tr><td>CMP å±‚</td><td>Kotlin</td><td>Compose Multiplatform æ¡†æ¶å±‚ï¼Œå®šä¹‰å›¾å±‚æ¥å£å’Œç»˜åˆ¶é€»è¾‘</td></tr><tr><td>Skiko å±‚</td><td>Kotlin</td><td>Skia Kotlin ç»‘å®šå±‚ï¼Œæä¾›è·¨å¹³å° Canvas/Picture API</td></tr><tr><td>OHRender å±‚</td><td>C++</td><td>OHOS æ¸²æŸ“é€‚é…å±‚ï¼Œå®ç° Skia API åˆ° OH_Drawing API çš„è½¬æ¢</td></tr></tbody></table></div>
<p><strong>è·¨å±‚è°ƒç”¨å…³ç³»</strong>ï¼š</p>
<pre><code>RenderNodeLayer (Kotlin)
â”‚
â”‚ æŒæœ‰ Skiko å¯¹è±¡
â–¼
PictureRecorder / Canvas / Picture (Skiko Kotlin)
â”‚
â”‚ JNI è°ƒç”¨
â–¼
SkPictureRecorder / SkCanvas / SkOHPicture (C++)
â”‚
â”‚ API è½¬æ¢
â–¼
OH_Drawing_Canvas / OH_Drawing_RecordCmd (OHOS System)</code></pre>
<h3><strong>3.3 ä¸€ä¸ª OwnedLayer æ˜¯å¦ä¸€å®šå¯¹åº”ä¸€ä¸ª OHRenderNodeï¼Ÿ</strong></h3>
<p><strong>ç­”æ¡ˆï¼šæ˜¯çš„ï¼Œä½†ä¸æ˜¯ç®€å•çš„ 1:1</strong></p>
<p>æ¯ä¸ª <code>OwnedLayer</code>ï¼ˆå³ <code>RenderNodeLayer</code>ï¼‰åœ¨å½•åˆ¶æ—¶ä¼šï¼š</p>
<ol>
<li>å¿…å®šå…³è”ä¸€ä¸ª<strong>åŸå§‹èŠ‚ç‚¹</strong>ï¼ˆ<code>fOriginNode</code>ï¼‰</li>
<li>ä½†åœ¨å›æ”¾æ—¶å¯èƒ½åˆ›å»º<strong>å¤šä¸ªå…‹éš†èŠ‚ç‚¹</strong></li>
</ol>
<pre><code>OwnedLayer
â””â”€â”€ SkOHPicture
â”œâ”€â”€ fOriginNode â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’ OHRenderNode #1 (åŸå§‹)
â”œâ”€â”€ fCacheCloneNodes[0] â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’ OHRenderNode #2 (å…‹éš†)
â””â”€â”€ fCacheCloneNodes[1] â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’ OHRenderNode #3 (å…‹éš†)</code></pre>
<h3><strong>3.4 æ˜¯å¦ä¼šå­˜åœ¨å¤šä¸ª OwnedLayer ç»˜åˆ¶åœ¨åŒä¸€ä¸ª OHRenderNodeï¼Ÿ</strong></h3>
<p><strong>ç­”æ¡ˆï¼šä¼šçš„ï¼Œåœ¨ Picture æ¨¡å¼ä¸‹</strong></p>
<p>å½“å­ Layer é€‰æ‹© <strong>Picture æ¨¡å¼</strong> å›æ”¾æ—¶ï¼Œå…¶ç»˜åˆ¶å‘½ä»¤ä¼šè¢«èšåˆåˆ°çˆ¶èŠ‚ç‚¹çš„ <code>OH_Drawing_RecordCmd</code> ä¸­ï¼š</p>
<pre><code>Layer A (çˆ¶)
â”‚
â”œâ”€â”€ è‡ªèº«ç»˜åˆ¶å‘½ä»¤
â”‚
â””â”€â”€ Layer B (å­, Picture æ¨¡å¼)
â”‚
â””â”€â”€ ç»˜åˆ¶å‘½ä»¤ â”€â”€èšåˆâ”€â”€â†’ Layer A çš„ OHRenderNode</code></pre>
<p><strong>ç¤ºæ„å›¾</strong>ï¼š</p>
<figure class="doc-figure"><img src="../knowledge-map-assets/module-10d487ca-3f084cf770.png" alt="æŒ‡ä»¤å½•åˆ¶ä¸ç»˜åˆ¶æœºåˆ¶ å›¾ç¤º" /></figure>
<hr />
<h2><strong>ç¬¬å››éƒ¨åˆ†ï¼šå½•åˆ¶æµç¨‹</strong></h2>
<h3><strong>4.1 å½•åˆ¶æµç¨‹æ€»è§ˆ</strong></h3>
<figure class="doc-figure"><img src="../knowledge-map-assets/module-10d487ca-3c9bc24c36.png" alt="æŒ‡ä»¤å½•åˆ¶ä¸ç»˜åˆ¶æœºåˆ¶ å›¾ç¤º" /></figure>
<h3><strong>4.2 å½•åˆ¶å…¥å£ï¼š</strong><strong><code>RenderNodeLayer.drawLayer()</code></strong></h3>
<pre><code>// æ–‡ä»¶: RenderNodeLayer.skiko.kt
â€‹
override fun drawLayer(canvas: Canvas) {
// ğŸ¯ æ­¥éª¤ 1ï¼šæ£€æŸ¥ç¼“å­˜
if (picture == null) {
val bounds = size.toSize().toRect()
// ğŸ¯ æ­¥éª¤ 2ï¼šå¼€å§‹å½•åˆ¶
// ä½¿ç”¨æå¤§è¾¹ç•Œï¼Œå®é™…è„åŒºç”± C++ å±‚è®¡ç®—
val pictureCanvas = pictureRecorder.beginRecording(
org.jetbrains.skia.Rect.makeLTRB(
l = -(1 shl 30).toFloat(),
t = -(1 shl 30).toFloat(),
r = ((1 shl 30)-1).toFloat(),
b = ((1 shl 30)-1).toFloat()
)
)
// ğŸ¯ æ­¥éª¤ 3ï¼šæ‰§è¡Œç»˜åˆ¶
performDrawLayer(pictureCanvas.asComposeCanvas(), bounds)
// ğŸ¯ æ­¥éª¤ 4ï¼šå®Œæˆå½•åˆ¶
picture = pictureRecorder.finishRecordingAsPicture()
}
// ğŸ¯ æ­¥éª¤ 5ï¼šåº”ç”¨å˜æ¢å¹¶ç»˜åˆ¶ Picture
canvas.save()
canvas.concat(matrix)
canvas.translate(position.x.toFloat(), position.y.toFloat())
canvas.nativeCanvas.drawPicture(picture!!, null, null)
canvas.restore()
}</code></pre>
<h3><strong>4.3 Canvas åˆ›å»ºï¼š</strong><strong><code>beginRecording()</code></strong></h3>
<pre><code>// æ–‡ä»¶: SkPictureRecorder.cpp
â€‹
SkCanvas* SkPictureRecorder::beginRecording(const SkRect&amp; userCullRect,
sk_sp&lt;SkBBoxHierarchy&gt; bbh) {
const SkRect cullRect = userCullRect.isEmpty() ? SkRect::MakeEmpty() : userCullRect;
// é˜²æ­¢é‡å¤å½•åˆ¶
if (fRecordCanvas) {
return nullptr;
}
// ğŸ¯ æ­¥éª¤ 1ï¼šå¼€å§‹ OH_Drawing å½•åˆ¶
OH_Drawing_Canvas *ohCanvas = nullptr;
OH_Drawing_RecordCmdUtilsBeginRecording(fOHRecorder,
ullRect.width(),
cullRect.height(),
&amp;ohCanvas);
if (!ohCanvas) {
return nullptr;
}
â€‹
// ğŸ¯ æ­¥éª¤ 2ï¼šåˆ›å»ºæˆ–å¤ç”¨ OHRenderNode
if (fNowOHNode == nullptr || fNowOHNode-&gt;getPicture() != nullptr) {
fNowOHNode = OHRenderNode::CreateNormalNode();
}
// ğŸ¯ æ­¥éª¤ 3ï¼šåˆ›å»º SkCanvasï¼ˆåŒ…è£… OH_Drawing_Canvasï¼‰
fRecordCanvas = new SkCanvas(ohCanvas, fNowOHNode.get());
fRecordCanvas-&gt;setRecordCull(cullRect);
// ... æ›´å¤šåˆå§‹åŒ– ...
fActivelyRecording = true;
return fRecordCanvas;
}</code></pre>
<h3><strong>4.4 å‘½ä»¤è½¬æ¢ç¤ºä¾‹</strong></h3>
<pre><code>// æ–‡ä»¶: SkCanvas.cpp
â€‹
void SkCanvas::drawRect(const SkRect&amp; rect, const SkPaint&amp; paint) {
// è·å– OH_Drawing ç”»ç¬”
OH_Drawing_Brush* brush = paint.asBrush();
OH_Drawing_Pen* pen = paint.asPen();
// è®¾ç½®ç”»ç¬”
if (brush) OH_Drawing_CanvasAttachBrush(fOHCanvas, brush);
if (pen) OH_Drawing_CanvasAttachPen(fOHCanvas, pen);
// è½¬æ¢ä¸º OH_Drawing å‘½ä»¤
OH_Drawing_Rect* ohRect = OH_Drawing_RectCreate();
OH_Drawing_RectSetLeft(ohRect, rect.fLeft);
OH_Drawing_RectSetTop(ohRect, rect.fTop);
OH_Drawing_RectSetRight(ohRect, rect.fRight);
OH_Drawing_RectSetBottom(ohRect, rect.fBottom);
// æ‰§è¡Œç»˜åˆ¶
OH_Drawing_CanvasDrawRect(fOHCanvas, ohRect);
// ğŸ¯ æ›´æ–°è„åŒºè¾¹ç•Œ
updateDrawBounds(rect);
// æ¸…ç†
OH_Drawing_RectDestroy(ohRect);
if (brush) OH_Drawing_CanvasDetachBrush(fOHCanvas);
if (pen) OH_Drawing_CanvasDetachPen(fOHCanvas);
}</code></pre>
<h3><strong>4.5 è„åŒºè®¡ç®—ï¼š</strong><strong><code>getFinishDrawBounds()</code></strong></h3>
<pre><code>// æ–‡ä»¶: SkCanvas.cpp
std::optional&lt;SkRect&gt; SkCanvas::getFinishDrawBounds() {
if (!fHasDrawBounds) {
return std::nullopt; // æ— ç»˜åˆ¶å†…å®¹
}
// åº”ç”¨å½•åˆ¶æ—¶çš„å˜æ¢çŸ©é˜µï¼Œå°†è„åŒºæ˜ å°„åˆ°æ­£ç¡®åæ ‡ç³»
SkMatrix inverse;
if (fInitMatrix.invert(&amp;inverse)) {
SkRect mappedBounds;
inverse.mapRect(&amp;mappedBounds, fDrawBounds);
return mappedBounds;
}
return fDrawBounds;
}</code></pre>
<h3><strong>4.6 Picture ç”Ÿæˆï¼šfinishRecordingAsPicture()</strong></h3>
<pre><code>// æ–‡ä»¶: SkPictureRecorder.cpp
sk_sp&lt;SkPicture&gt; SkPictureRecorder::finishRecordingAsPicture() {
fActivelyRecording = false;
if (!fRecordCanvas) {
return nullptr;
}
// ğŸ¯ æ­¥éª¤ 1ï¼šå¤„ç†å­ Canvasï¼ˆåµŒå¥—å½•åˆ¶åœºæ™¯ï¼‰
if (fRecordCanvas-&gt;fSubCanvas) {
fRecordCanvas-&gt;finishSubCanvas();
}
if (fNowOHNode) {
fNowOHNode-&gt;finishChildAdd();
}
// ğŸ¯ æ­¥éª¤ 2ï¼šè·å–è„åŒºè¾¹ç•Œ
OH_Drawing_RecordCmd* recordCmd = nullptr;
auto paintArea = fRecordCanvas-&gt;getFinishDrawBounds();
bool noLimitDraw = false;
if (paintArea.has_value()) {
// æœ‰æ˜ç¡®ç»˜åˆ¶è¾¹ç•Œ
if (fNowOHNode) {
fNowOHNode-&gt;setRealFrame(paintArea.value(), false);
}
fCullRect = paintArea.value();
} else {
// æ— é™åˆ¶ç»˜åˆ¶ï¼ˆå¯èƒ½æ˜¯æ— ç»˜åˆ¶å†…å®¹æˆ–å…¨å±ç»˜åˆ¶ï¼‰
auto noLimitRect = SkRect::MakeWH(NODE_SIZE_ALIGNMENT, NODE_SIZE_ALIGNMENT);
if (fNowOHNode) {
fNowOHNode-&gt;setRealFrame(noLimitRect, true);
}
noLimitDraw = true;
}
// ğŸ¯ æ­¥éª¤ 3ï¼šå®Œæˆ OH_Drawing å½•åˆ¶
OH_Drawing_RecordCmdUtilsFinishRecording(fOHRecorder, &amp;recordCmd);
// ğŸ¯ æ­¥éª¤ 4ï¼šæ”¶é›†å­ Picture
auto subPics = fRecordCanvas-&gt;takeSubPics();
// ğŸ¯ æ­¥éª¤ 5ï¼šè®¡ç®—å†…å®¹å“ˆå¸Œï¼ˆç”¨äºç¼“å­˜å¤ç”¨ï¼‰
uint64_t pictureHash = calculateHash();
// ğŸ¯ æ­¥éª¤ 6ï¼šåˆ›å»º SkOHPicture
return sk_make_sp&lt;SkOHPicture&gt;(
fCullRect, // è„åŒºè¾¹ç•Œ
noLimitDraw, // æ— é™åˆ¶ç»˜åˆ¶æ ‡å¿—
recordCmd, // OH ç»˜åˆ¶å‘½ä»¤
fNowOHNode, // å…³è”èŠ‚ç‚¹
std::move(subPics), // å­ Picture åˆ—è¡¨
cost, // ç»˜åˆ¶æˆæœ¬
fDisableRecycleNode, // ç¦ç”¨èŠ‚ç‚¹å›æ”¶
pictureHash // å†…å®¹å“ˆå¸Œ
);
}</code></pre>
<hr />
<h2><strong>ç¬¬äº”éƒ¨åˆ†ï¼šå›æ”¾æµç¨‹ä¸æ¨¡å¼å†³ç­–</strong></h2>
<h3><strong>5.1 ä¸¤ç§æ¨¡å¼å¯¹æ¯”</strong></h3>
<div class="doc-table-wrap"><table class="doc-table"><thead><tr><th>ç‰¹æ€§</th><th>Picture æ¨¡å¼</th><th>Node æ¨¡å¼</th></tr></thead><tbody><tr><td>æ¸²æŸ“æ–¹å¼</td><td>ç›´æ¥åœ¨ Canvas ä¸Šæ‰§è¡Œå‘½ä»¤</td><td>ç‹¬ç«‹ RenderNode æŒ‚è½½</td></tr><tr><td>è„åŒºç®¡ç†</td><td>çˆ¶èŠ‚ç‚¹ç»Ÿä¸€ç®¡ç†</td><td>ç‹¬ç«‹è„åŒº</td></tr><tr><td>å˜æ¢æ”¯æŒ</td><td>ç»§æ‰¿çˆ¶èŠ‚ç‚¹å˜æ¢</td><td>ç‹¬ç«‹å˜æ¢çŸ©é˜µ</td></tr><tr><td>å†…å­˜å ç”¨</td><td>è¾ƒä½</td><td>è¾ƒé«˜ï¼ˆèŠ‚ç‚¹å¯¹è±¡å¼€é”€ï¼‰</td></tr><tr><td>é€‚ç”¨åœºæ™¯</td><td>é™æ€/ç®€å•å†…å®¹</td><td>åŠ¨æ€/å¤æ‚/é¢‘ç¹å˜åŒ–</td></tr><tr><td>æ˜¯å¦å¯é€†</td><td>å¯å›é€€åˆ° Node</td><td>ä¸å¯é€†ï¼Œä¸€æ—¦åˆ†è£‚æ— æ³•èšåˆ</td></tr></tbody></table></div>
<h3><strong>5.2 æ¨¡å¼å†³ç­–æµç¨‹å›¾</strong></h3>
<figure class="doc-figure"><img src="../knowledge-map-assets/module-10d487ca-821417061a.png" alt="æŒ‡ä»¤å½•åˆ¶ä¸ç»˜åˆ¶æœºåˆ¶ å›¾ç¤º" /></figure>
<h3><strong>5.3 å›æ”¾æ ¸å¿ƒä»£ç ï¼šplayback()</strong></h3>
<pre><code>// æ–‡ä»¶: SkPictureRecorder.cpp (SkOHPicture ç±»)
void playback(SkCanvas* canvas, AbortCallback* callback) const override {
// è·å–çˆ¶èŠ‚ç‚¹
auto canvas_node = canvas-&gt;getOHNode();
// === æ¨¡å¼å†³ç­– ===
bool should_paint_in_picture = false;
// æ¡ä»¶ 1ï¼šæ— çˆ¶èŠ‚ç‚¹æˆ–æ— åŸå§‹èŠ‚ç‚¹
if (!canvas_node || !fOriginNode) {
should_paint_in_picture = true;
}
// æ¡ä»¶ 2ï¼šå¼ºåˆ¶ Picture æ¨¡å¼
else if (canvas-&gt;isForceDrawInPicture()) {
should_paint_in_picture = true;
}
// æ¡ä»¶ 3ï¼šåœ¨ SaveLayer ä¸­ä¸”æ”¯æŒåµŒå¥—å‘½ä»¤
else if (canvas-&gt;isInSaveLayer() &amp;&amp;
OHDrawingAPI::support_OH_Drawing_CanvasDrawRecordCmdNesting) {
should_paint_in_picture = true;
}
// æ¡ä»¶ 4ï¼šæ— é™åˆ¶ç»˜åˆ¶ä¸”æ— å­èŠ‚ç‚¹
else if (fNoLimitDraw &amp;&amp; !fOriginNode-&gt;hasChildren()) {
should_paint_in_picture = true;
}
// æ¡ä»¶ 5ï¼šä¹‹å‰åœ¨ Picture æ¨¡å¼ï¼Œæ£€æŸ¥æ˜¯å¦éœ€è¦è½¬ä¸º Node æ¨¡å¼
else if (!fPlaybackInNode &amp;&amp; fCanPlaybackInPicture) {
// è®¡ç®—ç»˜åˆ¶åŒºåŸŸä¸çˆ¶èŠ‚ç‚¹çš„ç›¸äº¤æƒ…å†µ
SkRect drawArea = calculateDrawArea(canvas);
SkRect parentArea = canvas_node-&gt;getPaintArea();
// å¦‚æœä¸ç›¸äº¤ï¼Œå¯ä»¥ç»§ç»­ä½¿ç”¨ Picture æ¨¡å¼
if (!drawArea.intersects(parentArea)) {
should_paint_in_picture = true;
}
}
// === æ‰§è¡Œå›æ”¾ ===
if (should_paint_in_picture) {
// ğŸŸ¢ Picture æ¨¡å¼ï¼šç›´æ¥æ‰§è¡Œå‘½ä»¤
fNowCacheNode-&gt;pictureDraw(canvas-&gt;getOHCanvas(), true);
fPlaybackInNode = false;
} else {
// ğŸŸ  Node æ¨¡å¼ï¼šæŒ‚è½½ç‹¬ç«‹èŠ‚ç‚¹
if (!fNowCacheNode) {
fNowCacheNode = generateNewNode();
}
// è®¾ç½®çˆ¶å­å…³ç³»
fNowCacheNode-&gt;setParent(canvas_node);
fNowCacheNode-&gt;updateFatherMatrix(canvas-&gt;getTotalMatrix());
fNowCacheNode-&gt;setPaintArea(calculatePaintArea(canvas));
// æŒ‚è½½åˆ°çˆ¶èŠ‚ç‚¹
canvas_node-&gt;appendChild(fNowCacheNode);
fPlaybackInNode = true;
fNowCacheNode-&gt;setDrawInPicture(false); // æ ‡è®°ä¸º Node æ¨¡å¼
}
}</code></pre>
<h3><strong>5.4 åˆ†å¸§åˆ†è£‚ä¼˜åŒ–æœºåˆ¶</strong></h3>
<h4><strong>5.4.1 ä»€ä¹ˆæ˜¯åˆ†å¸§åˆ†è£‚ï¼Ÿ</strong></h4>
<p>åœ¨ OHRender ä¸­ï¼Œå½“ä¸€ä¸ª Picture ä» <strong>Picture æ¨¡å¼</strong>åˆ‡æ¢åˆ° <strong>Node æ¨¡å¼</strong>æ—¶ï¼Œè¿™ä¸ªè¿‡ç¨‹è¢«ç§°ä¸º"èŠ‚ç‚¹åˆ†è£‚"ã€‚ä¸ºäº†é¿å…ä¸€å¸§å†…åˆ›å»ºå¤§é‡èŠ‚ç‚¹å¯¼è‡´çš„æ€§èƒ½å°–å³°ï¼ŒOHRender é‡‡ç”¨äº†<strong>åˆ†å¸§åˆ†è£‚</strong>ç­–ç•¥ï¼š</p>
<p><strong>æ ¸å¿ƒæ€æƒ³</strong>ï¼šæ¯å¸§<strong>å°½å¯èƒ½</strong>åªåˆ†è£‚ä¸€ä¸ªèŠ‚ç‚¹ï¼Œå°†èŠ‚ç‚¹åˆ›å»ºçš„å¼€é”€åˆ†æ•£åˆ°å¤šå¸§ä¸­ï¼Œå®ç°æ¸è¿›å¼çš„èŠ‚ç‚¹æ ‘æ„å»ºã€‚</p>
<p><strong>é—®é¢˜åœºæ™¯</strong>ï¼š</p>
<pre><code>// å¤æ‚åµŒå¥—ç»“æ„
Box(Modifier.graphicsLayer { /* Layer A */ }) {
Column {
// 100 ä¸ªå­å…ƒç´ ï¼Œæ¯ä¸ªéƒ½æœ‰ graphicsLayer
repeat(100) { i -&gt;
Box(Modifier.graphicsLayer { /* Layer B-$i */ }) {
Text("Item $i")
}
}
}
}</code></pre>
<p><strong>é—®é¢˜</strong>ï¼šå¦‚æœåœ¨<strong>ä¸€å¸§å†…</strong>å°†æ‰€æœ‰ 100 ä¸ª Picture éƒ½åˆ†è£‚æˆ Nodeï¼Œä¼šå¯¼è‡´ï¼š</p>
<ul>
<li>CPU å³°å€¼ï¼šå¤§é‡èŠ‚ç‚¹å¯¹è±¡åˆ›å»ºå’Œå†…å­˜åˆ†é…</li>
<li>å¸§æ—¶é—´è¶…æ ‡ï¼šå¯èƒ½å¯¼è‡´æ‰å¸§</li>
<li>å†…å­˜å‹åŠ›ï¼šç¬é—´åˆ†é…å¤§é‡èŠ‚ç‚¹å¯¹è±¡</li>
</ul>
<p><strong>è§£å†³æ–¹æ¡ˆ</strong>ï¼šä½¿ç”¨ <code>needDelayChildAppend</code> æ ‡å¿—ï¼Œæ§åˆ¶èŠ‚ç‚¹åˆ†è£‚çš„é€Ÿåº¦ã€‚</p>
<h4><strong>5.4.2 åˆ†å¸§åˆ†è£‚çš„å·¥ä½œåŸç†</strong></h4>
<p><strong>æ ¸å¿ƒæ•°æ®ç»“æ„</strong>ï¼ˆ<code>OHRenderNode</code>ï¼‰ï¼š</p>
<pre><code>class OHRenderNode {
// === å­èŠ‚ç‚¹ç®¡ç† ===
std::list&lt;std::shared_ptr&lt;OHRenderNode&gt;&gt; fChildList; // æŒä¹…åŒ–å­˜å‚¨
std::list&lt;std::shared_ptr&lt;OHRenderNode&gt;&gt; fChildOrderList;// æœ¬æ¬¡å½•åˆ¶çš„ç»˜åˆ¶é¡ºåº
std::list&lt;std::shared_ptr&lt;OHRenderNode&gt;&gt; fChildAppend; // æœ¬æ¬¡æ–°æ·»åŠ çš„å­èŠ‚ç‚¹
// === åˆ†å¸§åˆ†è£‚æ§åˆ¶æ ‡å¿— ===
bool fNeedDelayChildAppend = true; // æœ¬å¸§æ˜¯å¦æœ‰æ–°å­èŠ‚ç‚¹æ’å…¥
};</code></pre>
<p><strong>ç”Ÿå‘½å‘¨æœŸæµç¨‹</strong>ï¼š</p>
<figure class="doc-figure"><img src="../knowledge-map-assets/module-10d487ca-cc69342b91.png" alt="æŒ‡ä»¤å½•åˆ¶ä¸ç»˜åˆ¶æœºåˆ¶ å›¾ç¤º" /></figure>
<h4><strong>5.4.3 å…³é”®ä»£ç å®ç°</strong></h4>
<p><strong>æ­¥éª¤ 1ï¼šå½•åˆ¶å¼€å§‹ï¼Œé‡ç½®æ ‡å¿—</strong></p>
<pre><code>// æ–‡ä»¶: OHRenderNode.cpp, L601-613
â€‹
void OHRenderNode::restartChildAdd() {
// ğŸ¯ é‡ç½®åˆ†å¸§åˆ†è£‚æ ‡å¿—
fNeedDelayChildAppend = false;
// æ¸…ç©ºæœ¬æ¬¡å½•åˆ¶çš„ä¸´æ—¶åˆ—è¡¨
fChildOrderList.clear();
fChildAppend.clear();
}</code></pre>
<p><strong>æ­¥éª¤ 2ï¼šæ·»åŠ å­èŠ‚ç‚¹ï¼Œè®¾ç½®æ ‡å¿—</strong></p>
<pre><code>// æ–‡ä»¶: OHRenderNode.cpp, L672-720
â€‹
void OHRenderNode::appendChild(std::shared_ptr&lt;OHRenderNode&gt; child) {
// ... å‰ç½®æ£€æŸ¥ ...
// ğŸ¯ è®°å½•åˆ°æœ¬æ¬¡ç»˜åˆ¶é¡ºåºåˆ—è¡¨
fChildOrderList.push_back(child);
// ğŸ¯ æ£€æŸ¥æ˜¯å¦æ˜¯æ–°æ’å…¥çš„å­èŠ‚ç‚¹
bool isNewChild =
(std::find(fChildList.begin(),
fChildList.end(),
child) == fChildList.end());
if (isNewChild) {
// ğŸ¯ è®°å½•åˆ°æ–°å¢åˆ—è¡¨
fChildAppend.push_back(child);
// ğŸ”¥ è®¾ç½®æ ‡å¿—ï¼šæœ¬å¸§æœ‰æ–°å­èŠ‚ç‚¹æ’å…¥ï¼
fNeedDelayChildAppend = true;
}
}</code></pre>
<p><strong>æ­¥éª¤ 3ï¼šå½•åˆ¶ç»“æŸï¼Œé‡æ’åº</strong></p>
<pre><code>// æ–‡ä»¶: OHRenderNode.cpp, L615-669
â€‹
void OHRenderNode::finishChildAdd() {
if (fChildOrderList.empty()) {
return;
}
// ğŸ¯ å°†æ–°å¢èŠ‚ç‚¹åˆå¹¶åˆ°æŒä¹…åŒ–åˆ—è¡¨
for (auto&amp; newChild : fChildAppend) {
fChildList.push_back(newChild);
}
// ğŸ¯ æ ¹æ®æœ¬æ¬¡ç»˜åˆ¶é¡ºåºé‡æ’å­èŠ‚ç‚¹
// ï¼ˆçœç•¥å¤æ‚çš„é‡æ’åºé€»è¾‘...ï¼‰
}</code></pre>
<p><strong>æ­¥éª¤ 4ï¼šå›æ”¾æ—¶æ£€æŸ¥æ ‡å¿—ï¼Œæ§åˆ¶åˆ†è£‚</strong></p>
<pre><code>// æ–‡ä»¶: SkPictureRecorder.cpp, L230-242 (SkOHPicture::playback)
â€‹
const auto refinePictureModeByHeuristics = [&amp;]() {
if (should_paint_in_picture) {
return; // å·²ç»å†³å®šç”¨ Picture æ¨¡å¼
}
if (!canvas_node || !fOriginNode || !fNowCacheNode) {
return;
}
if (!fCanPlaybackInPicture || fPlaybackInNode ||
!OHDrawingAPI::support_OH_Drawing_CanvasDrawRecordCmdNesting) {
return;
}
â€‹
auto father_paint_area = canvas_node-&gt;getPaintChildArea();
SkRect temp;
const bool node_can_draw_in_father =
(paint_area.has_value() &amp;&amp;
father_paint_area.has_value() &amp;&amp;
!(temp.intersect(father_paint_area.value(), paint_area.value()) &amp;&amp;
temp.width() &gt; 0.1f &amp;&amp;
temp.height() &gt; 0.1f));
â€‹
const bool matrix_changed =
fNowCacheNode-&gt;updateFatherMatrix(father_matrix);
const bool record_delta_changed =
(fOriginNode-&gt;updateDeltaChangedCnt(canvas_node-&gt;getRecordCnt()) &gt;= 3);
const bool prefer_playback_in_node = (matrix_changed ||
record_delta_changed ||
canvas_node-&gt;getAllNodeChildrenNum() &gt; 0);
â€‹
// åˆ†å¸§åˆ†è£‚æ§åˆ¶æ ¸å¿ƒé€»è¾‘ï¼š
// å½“çˆ¶èŠ‚ç‚¹æœ¬å¸§åˆšæ·»åŠ äº†æ–°å­èŠ‚ç‚¹æ—¶ï¼Œæˆ‘ä»¬æ­£å¤„äºåˆ†å¸§åˆ†è£‚çš„è¿‡ç¨‹ä¸­ï¼›
// å­èŠ‚ç‚¹é¡ºåºä»åœ¨ç¡®å®šä¸­ï¼Œæ‰€ä»¥ä»…å½“æ–°å­èŠ‚ç‚¹ä¸ä¸å…¶ä»–ç»˜åˆ¶å­èŠ‚ç‚¹é‡å æ—¶ï¼Œ
// æ‰å›é€€åˆ° Picture æ¨¡å¼ï¼ˆé¿å…åˆ›å»ºåˆä¸€ä¸ªèŠ‚ç‚¹ï¼‰ã€‚
if (!prefer_playback_in_node ||
(node_can_draw_in_father &amp;&amp; canvas_node-&gt;needDelayChildAppend())) {
should_paint_in_picture = true;
}
};</code></pre>
<h4><strong>5.4.4 åˆ†å¸§åˆ†è£‚çš„æ‰§è¡Œæµç¨‹å›¾</strong></h4>
<figure class="doc-figure"><img src="../knowledge-map-assets/module-10d487ca-19eade3b8a.png" alt="æŒ‡ä»¤å½•åˆ¶ä¸ç»˜åˆ¶æœºåˆ¶ å›¾ç¤º" /></figure>
<h4><strong>5.4.5 åˆ†å¸§åˆ†è£‚çš„æ•ˆæœå¯¹æ¯”</strong></h4>
<p><strong>åœºæ™¯</strong>ï¼šçˆ¶èŠ‚ç‚¹ä¸‹æœ‰ 10 ä¸ªå­ Pictureï¼Œé¦–æ¬¡æ¸²æŸ“æ—¶éœ€è¦å†³ç­–æ˜¯å¦åˆ†è£‚ã€‚</p>
<p><strong>æ— åˆ†å¸§åˆ†è£‚é™åˆ¶</strong>ï¼ˆå‡è®¾æ‰€æœ‰æ¡ä»¶éƒ½æ»¡è¶³ï¼‰ï¼š</p>
<pre><code>å¸§ 1:
Picture 1 â†’ Node 1 (åˆ†è£‚)
Picture 2 â†’ Node 2 (åˆ†è£‚)
Picture 3 â†’ Node 3 (åˆ†è£‚)
...
Picture 10 â†’ Node 10 (åˆ†è£‚)
ç»“æœ: ä¸€å¸§å†…åˆ›å»º 10 ä¸ªèŠ‚ç‚¹ï¼ŒCPU å³°å€¼ï¼</code></pre>
<p><strong>æœ‰åˆ†å¸§åˆ†è£‚æ§åˆ¶</strong>ï¼š</p>
<pre><code>å¸§ 1:
restartChildAdd() â†’ fNeedDelayChildAppend = false
Picture 1 â†’ Node 1 (åˆ†è£‚) âœ“
â””â”€ fNeedDelayChildAppend = true
Picture 2 â†’ Picture æ¨¡å¼ (å› ä¸º needDelayChildAppend = true)
Picture 3 â†’ Picture æ¨¡å¼ (å› ä¸º needDelayChildAppend = true)
...
Picture 10 â†’ Picture æ¨¡å¼
å¸§ 2:
restartChildAdd() â†’ fNeedDelayChildAppend = false
Picture 1 â†’ å·²åˆ†è£‚ï¼Œç›´æ¥æŒ‚è½½
Picture 2 â†’ Node 2 (åˆ†è£‚) âœ“
â””â”€ fNeedDelayChildAppend = true
Picture 3 â†’ Picture æ¨¡å¼ (å› ä¸º needDelayChildAppend = true)
...
å¸§ 3:
Picture 3 â†’ Node 3 (åˆ†è£‚) âœ“
...
ç»“æœ: æ¯å¸§åªåˆ†è£‚ 1 ä¸ªèŠ‚ç‚¹ï¼Œå¼€é”€å¹³æ»‘ï¼</code></pre>
<p><strong>æ€§èƒ½å¯¹æ¯”</strong>ï¼š</p>
<div class="doc-table-wrap"><table class="doc-table"><thead><tr><th>æŒ‡æ ‡</th><th>æ— åˆ†å¸§åˆ†è£‚é™åˆ¶</th><th>æœ‰åˆ†å¸§åˆ†è£‚æ§åˆ¶</th></tr></thead><tbody><tr><td>é¦–å¸§ CPU å³°å€¼</td><td>æé«˜ï¼ˆåˆ›å»º N ä¸ªèŠ‚ç‚¹ï¼‰</td><td>ä½ï¼ˆåˆ›å»º 1 ä¸ªèŠ‚ç‚¹ï¼‰</td></tr><tr><td>é¦–å¸§æ—¶é—´</td><td>å¯èƒ½æ‰å¸§ï¼ˆ&gt;16.6msï¼‰</td><td>æ­£å¸¸ï¼ˆ&lt;16.6msï¼‰</td></tr><tr><td>å®Œå…¨åˆ†è£‚æ—¶é—´</td><td>1 å¸§</td><td>N å¸§</td></tr><tr><td>ç”¨æˆ·ä½“éªŒ</td><td>å¡é¡¿ä¸€ä¸‹åæµç•…</td><td>å§‹ç»ˆæµç•…</td></tr><tr><td>å†…å­˜åˆ†é…æ›²çº¿</td><td>å°–å³°</td><td>å¹³æ»‘ä¸Šå‡</td></tr></tbody></table></div>
<h4><strong>5.4.6 ç‰¹æ®Šæƒ…å†µï¼šä¸é‡å å­èŠ‚ç‚¹çš„å¿«é€Ÿé€šé“</strong></h4>
<p>å³ä½¿ <code>needDelayChildAppend = true</code>ï¼Œå¦‚æœæ–°å­èŠ‚ç‚¹ä¸çˆ¶èŠ‚ç‚¹çš„å…¶ä»–ç»˜åˆ¶å­èŠ‚ç‚¹<strong>ä¸é‡å </strong>ï¼Œä¹Ÿå¯ä»¥ç«‹å³åˆ†è£‚ï¼š</p>
<pre><code>// æ ¸å¿ƒåˆ¤æ–­é€»è¾‘
const bool node_can_draw_in_father =
(paint_area.has_value() &amp;&amp; father_paint_area.has_value() &amp;&amp;
!(temp.intersect(father_paint_area.value(), paint_area.value()) &amp;&amp;
temp.width() &gt; 0.1f &amp;&amp; temp.height() &gt; 0.1f));
â€‹
// å¦‚æœä¸é‡å ï¼Œå³ä½¿ needDelayChildAppend = trueï¼Œä¹Ÿå¯ä»¥åˆ†è£‚
if (!prefer_playback_in_node ||
(node_can_draw_in_father &amp;&amp; canvas_node-&gt;needDelayChildAppend())) {
should_paint_in_picture = true;
} else {
// Node æ¨¡å¼åˆ†è£‚
}</code></pre>
<h4><strong>5.4.7 å‘½åè®¨è®ºä¸æ”¹è¿›å»ºè®®</strong></h4>
<p><strong>å½“å‰å‘½å</strong>ï¼š<code>fNeedDelayChildAppend</code></p>
<p><strong>é—®é¢˜</strong>ï¼š</p>
<ul>
<li>"Delay" å«ä¹‰ä¸æ˜ç¡®ï¼Œçœ‹èµ·æ¥åƒæ˜¯å»¶è¿Ÿæ·»åŠ å­èŠ‚ç‚¹</li>
<li>æ²¡æœ‰ä½“ç°"åˆ†å¸§åˆ†è£‚"çš„æ ¸å¿ƒæ„å›¾</li>
</ul>
<p><strong>å»ºè®®å‘½å</strong>ï¼š<code>fHasNewChildThisFrame</code> æˆ– <code>fChildOrderUnstable</code></p>
<p><strong>åŸå› </strong>ï¼š</p>
<ul>
<li>æ›´ç›´æ¥åœ°è¡¨è¾¾"æœ¬å¸§æœ‰æ–°å­èŠ‚ç‚¹"çš„è¯­ä¹‰</li>
<li>å¼ºè°ƒå­èŠ‚ç‚¹é¡ºåºå°šæœªç¨³å®šï¼Œéœ€è¦å»¶è¿Ÿå…¶ä»–èŠ‚ç‚¹çš„åˆ†è£‚</li>
</ul>
<p><strong>å¦‚æœé‡‡ç”¨æ–°å‘½åï¼Œä»£ç ä¼šæ›´æ˜“è¯»</strong>ï¼š</p>
<pre><code>// å½“å‰ä»£ç ï¼ˆè¯­ä¹‰æ¨¡ç³Šï¼‰
if (!prefer_playback_in_node ||
(node_can_draw_in_father &amp;&amp; canvas_node-&gt;needDelayChildAppend())) {
should_paint_in_picture = true;
}
â€‹
// æ”¹è¿›åï¼ˆè¯­ä¹‰æ¸…æ™°ï¼‰
if (!prefer_playback_in_node ||
(node_can_draw_in_father &amp;&amp; canvas_node-&gt;hasNewChildThisFrame())) {
should_paint_in_picture = true;
}</code></pre>
<h4><strong>5.4.8 æ€»ç»“</strong></h4>
<p>åˆ†å¸§åˆ†è£‚æœºåˆ¶æ˜¯ OHRender å®ç°é«˜æ€§èƒ½æ¸²æŸ“çš„å…³é”®ä¼˜åŒ–ï¼š</p>
<ol>
<li><strong>é—®é¢˜</strong>ï¼šä¸€å¸§å†…åˆ†è£‚å¤§é‡èŠ‚ç‚¹å¯¼è‡´æ€§èƒ½å°–å³°</li>
<li><strong>æ–¹æ¡ˆ</strong>ï¼šä½¿ç”¨ <code>needDelayChildAppend</code> æ ‡å¿—ï¼Œæ¯å¸§å°½é‡åªåˆ†è£‚ä¸€ä¸ªèŠ‚ç‚¹</li>
<li><strong>å®ç°</strong>ï¼š</li>
</ol>
<ul>
<li>å½•åˆ¶å¼€å§‹æ—¶é‡ç½®æ ‡å¿—ï¼ˆ<code>restartChildAdd</code>ï¼‰</li>
<li>æ·»åŠ å­èŠ‚ç‚¹æ—¶è®¾ç½®æ ‡å¿—ï¼ˆ<code>appendChild</code>ï¼‰</li>
<li>å›æ”¾æ—¶æ£€æŸ¥æ ‡å¿—ï¼Œæ§åˆ¶åˆ†è£‚é€Ÿåº¦ï¼ˆ<code>playback</code>ï¼‰</li>
<li>å½•åˆ¶ç»“æŸæ—¶åˆå¹¶æ–°å¢èŠ‚ç‚¹ï¼ˆ<code>finishChildAdd</code>ï¼‰</li>
</ul>
<ol>
<li><strong>æ•ˆæœ</strong>ï¼šå°†èŠ‚ç‚¹åˆ›å»ºå¼€é”€åˆ†æ•£åˆ°å¤šå¸§ï¼Œå®ç°æµç•…çš„æ¸²æŸ“ä½“éªŒ</li>
<li><strong>ç‰¹æ®Šæƒ…å†µ</strong>ï¼šä¸é‡å çš„å­èŠ‚ç‚¹å¯ä»¥å¿«é€Ÿé€šé“ï¼Œç«‹å³åˆ†è£‚</li>
</ol>
<h3><strong>5.5 ä¸ºä»€ä¹ˆèŠ‚ç‚¹åˆ†è£‚åæ— æ³•èšåˆï¼Ÿ</strong></h3>
<p><strong>æ ¸å¿ƒåŸå› </strong>ï¼šä¸€æ—¦èŠ‚ç‚¹è¿›å…¥ Node æ¨¡å¼ï¼ˆ<code>fDrawInPicture = false</code>ï¼‰ï¼Œåç»­å›æ”¾æ—¶ä¼š<strong>ä¼˜å…ˆä¿æŒ Node æ¨¡å¼</strong>ã€‚</p>
<p><strong>ä»£ç è¯æ®</strong>ï¼š</p>
<pre><code>// æ–‡ä»¶: OHRenderNode.h
// çŠ¶æ€æ ‡å¿—ï¼šåˆå§‹ä¸º trueï¼ˆå°è¯• Picture æ¨¡å¼ï¼‰
bool fDrawInPicture = true;
// åˆ¤æ–­æ˜¯å¦åœ¨ Node æ¨¡å¼
bool isInNode() { return !fDrawInPicture; }</code></pre>
<pre><code>// æ–‡ä»¶: SkPictureRecorder.cpp (SkOHPicture æ„é€ å‡½æ•°)
SkOHPicture(...) {
// æ„é€ æ—¶è®°å½•èŠ‚ç‚¹çš„åˆå§‹æ¨¡å¼çŠ¶æ€
fPlaybackInNode = node-&gt;isInNode();
// å¦‚æœèŠ‚ç‚¹å·²ç»åœ¨ Node æ¨¡å¼ï¼Œåˆ™ä¸å…è®¸å›é€€åˆ° Picture æ¨¡å¼
fCanPlaybackInPicture = !fPlaybackInNode;
}</code></pre>
<p><strong>ä¸å¯é€†çš„åŸå› </strong>ï¼š</p>
<ol>
<li><strong>çŠ¶æ€é”å®š</strong>ï¼šä¸€æ—¦ <code>fDrawInPicture = false</code>ï¼Œ<code>fCanPlaybackInPicture</code> ä¹Ÿä¼šè¢«è®¾ä¸º <code>false</code></li>
<li><strong>å­èŠ‚ç‚¹ä¾èµ–</strong>ï¼šNode æ¨¡å¼ä¸‹å¯èƒ½å·²åˆ›å»ºå­èŠ‚ç‚¹ï¼Œå›é€€ä¼šç ´åèŠ‚ç‚¹æ ‘ç»“æ„</li>
<li><strong>è®¾è®¡æ„å›¾</strong>ï¼šé¿å…é¢‘ç¹çš„æ¨¡å¼åˆ‡æ¢å¸¦æ¥çš„æ€§èƒ½æŠ–åŠ¨</li>
</ol>
<pre><code>æ—¶é—´è½´:
T1: Picture æ¨¡å¼ (fDrawInPicture = true)
â”‚
â–¼ è§¦å‘æ¡ä»¶æ»¡è¶³ï¼Œåˆ‡æ¢åˆ° Node æ¨¡å¼
T2: Node æ¨¡å¼ (fDrawInPicture = false)
â”‚
â•³ æ— æ³•å›é€€ï¼fCanPlaybackInPicture = false
T3: Node æ¨¡å¼ (fDrawInPicture = false)
â”‚
â–¼
T4: Node æ¨¡å¼ (æ°¸ä¹…ä¿æŒ)</code></pre>
<h3><strong>5.6 pictureDraw vs nodeDraw</strong></h3>
<pre><code>// Picture æ¨¡å¼ï¼šç›´æ¥æ‰§è¡Œç»˜åˆ¶å‘½ä»¤
uint64_t OHRenderNode::pictureDraw(OH_Drawing_Canvas *canvas, bool needCache) {
if (fPictureCmd) {
// ä½¿ç”¨ç¼“å­˜çš„å‘½ä»¤æ ‘ï¼ˆå¦‚æœæœ‰ï¼‰
if (fPictureTreeCmdCache) {
OHDrawingAPI::OH_Drawing_CanvasDrawRecordCmdNesting(
canvas, fPictureTreeCmdCache.get());
return fPictureTreeHash;
}
// æ‰§è¡Œè‡ªèº«å‘½ä»¤
OHDrawingAPI::OH_Drawing_CanvasDrawRecordCmdNesting(canvas,
fPictureCmd.get());
// é€’å½’å¤„ç†å­èŠ‚ç‚¹
for (auto&amp; child : fChildList) {
if (child-&gt;fVisible) {
OH_Drawing_CanvasSave(canvas);
OH_Drawing_CanvasConcatMatrix(canvas, child-&gt;fFatherMatrix);
child-&gt;pictureDraw(canvas, needCache);
OH_Drawing_CanvasRestore(canvas);
}
}
}
return 0;
}</code></pre>
<pre><code>// Node æ¨¡å¼ï¼šé€šè¿‡ NodeImpl æ‰§è¡Œç»˜åˆ¶
void OHRenderNode::nodeDraw(OH_Drawing_Canvas *oh_canvas) {
if (fNodeImpl) {
fNodeImpl-&gt;nodeDraw(oh_canvas, this);
}
}</code></pre>
<hr />
<h2><strong>ç¬¬å…­éƒ¨åˆ†ï¼šåµŒå¥—å½•åˆ¶æœºåˆ¶</strong></h2>
<h3><strong>6.1 åµŒå¥—åœºæ™¯è¯´æ˜</strong></h3>
<p>å½“ Compose UI ä¸­å­˜åœ¨åµŒå¥—çš„ <code>graphicsLayer</code> æ—¶ï¼Œä¼šäº§ç”Ÿ<strong>åµŒå¥—å½•åˆ¶</strong>ï¼š</p>
<pre><code>// Compose UI åµŒå¥—ç»“æ„ç¤ºä¾‹
Box(modifier = Modifier.graphicsLayer { /* Layer A */ }) {
Text("Header")
Box(modifier = Modifier.graphicsLayer { /* Layer B */ }) {
Image(...)
Box(modifier = Modifier.graphicsLayer { /* Layer C */ }) {
Text("Content")
}
}
Text("Footer")
}</code></pre>
<h3><strong>6.2 SubCanvas æœºåˆ¶</strong></h3>
<p>OHRender ä½¿ç”¨ <strong>SubCanvasï¼ˆå­ç”»å¸ƒï¼‰</strong> æœºåˆ¶å¤„ç†åµŒå¥—å½•åˆ¶ï¼š</p>
<figure class="doc-figure"><img src="../knowledge-map-assets/module-10d487ca-c4f3156183.png" alt="æŒ‡ä»¤å½•åˆ¶ä¸ç»˜åˆ¶æœºåˆ¶ å›¾ç¤º" /></figure>
<h3><strong>6.3 å…³é”®ä»£ç ï¼šbeginSubCanvas å’Œ finishSubCanvas</strong></h3>
<pre><code>// æ–‡ä»¶: SkCanvas.cpp
// åˆ›å»ºå­ç”»å¸ƒ
void SkCanvas::beginSubCanvas(const SkRect&amp; bounds) {
// ä¿å­˜å½“å‰çŠ¶æ€
save();
// åˆ›å»ºå­å½•åˆ¶å™¨
fSubRecorder = new SkPictureRecorder();
// å¼€å§‹å­å½•åˆ¶
fSubCanvas = fSubRecorder-&gt;beginRecording(bounds);
// ä¼ é€’å½“å‰å˜æ¢çŸ©é˜µåˆ°å­ç”»å¸ƒ
fSubCanvas-&gt;concat(getTotalMatrix());
}
// å®Œæˆå­ç”»å¸ƒå½•åˆ¶
void SkCanvas::finishSubCanvas() {
// 1. å®Œæˆå­å½•åˆ¶ï¼Œç”Ÿæˆ Picture
sk_sp&lt;SkPicture&gt; subPic = fSubRecorder-&gt;finishRecordingAsPicture();
// 2. ä¿å­˜åˆ°å­ Picture åˆ—è¡¨
fSubPics.push_back(subPic);
// æ¸…ç†å­ç”»å¸ƒ
fSubCanvas = nullptr;
fSubRecorder = nullptr;
// ğŸ”¥ 3. ç«‹å³å›æ”¾å­ Pictureï¼
fIsPlayingBack = true;
markSubPicPlayback(true);
this-&gt;drawPicture(subPic); // â† è§¦å‘ playback()
markSubPicPlayback(false);
fIsPlayingBack = false;
// 4. æ¢å¤çŠ¶æ€
restore();
}</code></pre>
<h3><strong>6.4 åµŒå¥—å½•åˆ¶çš„æ—¶åº</strong></h3>
<p><strong>å…³é”®ç‚¹</strong>ï¼šå­ Layer çš„ Picture åœ¨çˆ¶ Layer å½•åˆ¶å®Œæˆ<strong>ä¹‹å‰</strong>å°±å·²ç»å›æ”¾å®Œæˆã€‚</p>
<pre><code>æ—¶é—´è½´:
Layer A å½•åˆ¶
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ â”‚
T1 â”€â”€â”€â”€â”€â”€â–¶â”‚ beginRecording() â”‚
â”‚ draw("Header") â”‚
â”‚ â”‚
T2 â”€â”€â”€â”€â”€â”€â–¶â”‚ â”Œâ”€â”€â”€ Layer B å½•åˆ¶ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚ â”‚ beginRecording() â”‚ â”‚
â”‚ â”‚ draw(Image) â”‚ â”‚
â”‚ â”‚ finishRecording() â†’ Picture B â”‚ â”‚
T3 â”€â”€â”€â”€â”€â”€â–¶â”‚ â”‚ â”‚ â”‚
â”‚ â”‚ playback(Picture B) â† ç«‹å³å›æ”¾ï¼ â”‚ â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚ â”‚
T4 â”€â”€â”€â”€â”€â”€â–¶â”‚ draw("Footer") â”‚
â”‚ finishRecording() â†’ Picture A â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></pre>
<h3><strong>6.5 æ•°æ®ç»“æ„è½¬åŒ–</strong></h3>
<p>åµŒå¥—å½•åˆ¶è¿‡ç¨‹ä¸­ï¼Œæ•°æ®ç»“æ„çš„è½¬åŒ–å…³ç³»ï¼š</p>
<figure class="doc-figure"><img src="../knowledge-map-assets/module-10d487ca-597bf05f1b.png" alt="æŒ‡ä»¤å½•åˆ¶ä¸ç»˜åˆ¶æœºåˆ¶ å›¾ç¤º" /></figure>
<h3><strong>6.6 åµŒå¥—åœºæ™¯çš„æ¨¡å¼å†³ç­–</strong></h3>
<p>åœ¨åµŒå¥—åœºæ™¯ä¸­ï¼Œæ¨¡å¼å†³ç­–ä¼š<strong>é€å±‚ç‹¬ç«‹è¿›è¡Œ</strong>ï¼š</p>
<figure class="doc-figure"><img src="../knowledge-map-assets/module-10d487ca-f316fbb35c.png" alt="æŒ‡ä»¤å½•åˆ¶ä¸ç»˜åˆ¶æœºåˆ¶ å›¾ç¤º" /></figure>
<hr />
<h2><strong>ç¬¬ä¸ƒéƒ¨åˆ†ï¼šèŠ‚ç‚¹å…‹éš†ä¸å¤ç”¨</strong></h2>
<h3><strong>7.1 ä¸ºä»€ä¹ˆéœ€è¦èŠ‚ç‚¹å…‹éš†ï¼Ÿ</strong></h3>
<p>åœ¨ä»¥ä¸‹åœºæ™¯ä¸­ï¼Œä¸€ä¸ª Picture å¯èƒ½éœ€è¦å¤šä¸ª OHRenderNodeï¼š</p>
<ol>
<li><strong>è¿‡æ¸¡åŠ¨ç”»ï¼ˆCrossfadeï¼‰</strong>ï¼šæ–°æ—§å†…å®¹åŒæ—¶æ˜¾ç¤º</li>
<li><strong>LazyList å¤ç”¨</strong>ï¼šåŒä¸€æ¨¡æ¿æ¸²æŸ“å¤šä¸ª item</li>
<li><strong>å¹¶å‘å›æ”¾</strong>ï¼šå¤šä¸ªçº¿ç¨‹åŒæ—¶å›æ”¾åŒä¸€ Picture</li>
</ol>
<h3><strong>7.2 èŠ‚ç‚¹ç®¡ç†ç»“æ„</strong></h3>
<pre><code>class SkOHPicture {
// åŸå§‹èŠ‚ç‚¹ï¼ˆåˆ›å»ºæ—¶å…³è”ï¼‰
std::shared_ptr&lt;OHRenderNode&gt; fOriginNode;
// å½“å‰ä½¿ç”¨çš„èŠ‚ç‚¹ï¼ˆå›æ”¾æ—¶åŠ¨æ€è·å–ï¼‰
mutable std::shared_ptr&lt;OHRenderNode&gt; fNowCacheNode;
// æ‰€æœ‰å…‹éš†èŠ‚ç‚¹çš„ç¼“å­˜åˆ—è¡¨
mutable std::list&lt;std::shared_ptr&lt;OHRenderNode&gt;&gt; fCacheCloneNodes;
// æœªä½¿ç”¨çš„å…‹éš†èŠ‚ç‚¹åˆ—è¡¨ï¼ˆå¤ç”¨æ± ï¼‰
mutable std::list&lt;std::shared_ptr&lt;OHRenderNode&gt;&gt; fUnusedCloneNodes;
};</code></pre>
<h3><strong>7.3 èŠ‚ç‚¹è·å–é€»è¾‘ï¼šgenerateNewNode()</strong></h3>
<pre><code>// æ–‡ä»¶: SkPictureRecorder.cpp
â€‹
std::shared_ptr&lt;OHRenderNode&gt; SkOHPicture::generateNewNode() const {
// ğŸ¯ ä¼˜å…ˆçº§ 1ï¼šä»å¤ç”¨æ± è·å–
if (!fUnusedCloneNodes.empty()) {
auto node = fUnusedCloneNodes.front();
fUnusedCloneNodes.pop_front();
return node;
}
// ğŸ¯ ä¼˜å…ˆçº§ 2ï¼šä½¿ç”¨åŸå§‹èŠ‚ç‚¹ï¼ˆå¦‚æœæœªè¢«ä½¿ç”¨ï¼‰
if (fOriginNode &amp;&amp; !fOriginNode-&gt;isInUse()) {
fCacheCloneNodes.push_back(fOriginNode);
return fOriginNode;
}
// ğŸ¯ ä¼˜å…ˆçº§ 3ï¼šå…‹éš†æ–°èŠ‚ç‚¹
auto cloneNode = fOriginNode-&gt;makeClone();
fCacheCloneNodes.push_back(cloneNode);
return cloneNode;
}</code></pre>
<h3><strong>7.4 èŠ‚ç‚¹å…‹éš†å®ç°ï¼šmakeClone()</strong></h3>
<pre><code>// æ–‡ä»¶: OHRenderNode.cpp
â€‹
std::shared_ptr&lt;OHRenderNode&gt; OHRenderNode::makeClone() {
auto clone = std::make_shared&lt;OHRenderNode&gt;();
// å¤åˆ¶å…³é”®å±æ€§
clone-&gt;fRealFrame = this-&gt;fRealFrame;
clone-&gt;fNoLimitSize = this-&gt;fNoLimitSize;
// å…±äº«ç»˜åˆ¶å‘½ä»¤ï¼ˆåªè¯»ï¼Œä¸éœ€è¦å¤åˆ¶ï¼‰
clone-&gt;fPictureCmd = this-&gt;fPictureCmd;
// é€’å½’å…‹éš†å­èŠ‚ç‚¹
for (auto&amp; child : fChildList) {
auto childClone = child-&gt;makeClone();
clone-&gt;appendChild(childClone);
}
return clone;
}</code></pre>
<h3><strong>7.5 èŠ‚ç‚¹ç”Ÿå‘½å‘¨æœŸç®¡ç†</strong></h3>
<figure class="doc-figure"><img src="../knowledge-map-assets/module-10d487ca-aaa1148c25.png" alt="æŒ‡ä»¤å½•åˆ¶ä¸ç»˜åˆ¶æœºåˆ¶ å›¾ç¤º" /></figure>
<h3><strong>7.6 å®é™…åœºæ™¯ç¤ºä¾‹ï¼šCrossfade åŠ¨ç”»</strong></h3>
<pre><code>// Crossfade åŠ¨ç”»ä¼šåŒæ—¶æ˜¾ç¤ºæ–°æ—§å†…å®¹
Crossfade(targetState = currentScreen) { screen -&gt;
when (screen) {
Screen.A -&gt; ScreenA() // æ—§å†…å®¹
Screen.B -&gt; ScreenB() // æ–°å†…å®¹
}
}</code></pre>
<p><strong>å›æ”¾æ—¶çš„èŠ‚ç‚¹åˆ†é…</strong>ï¼š</p>
<pre><code>å¸§ N (è¿‡æ¸¡ä¸­):
Picture (ScreenA)
â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ â”‚ â”‚
fOriginNode fCacheClone[0] fCacheClone[1]
(alpha=0.7) (ä¸ä½¿ç”¨) (alpha=0.3)
â”‚ â”‚
â–¼ â–¼
æ—§å†…å®¹æ˜¾ç¤º æ–°å†…å®¹æ˜¾ç¤º</code></pre>
<hr />
<h2><strong>ç¬¬å…«éƒ¨åˆ†ï¼šå…³é”®ä»£ç ä½ç½®ç´¢å¼•</strong></h2>
<h3><strong>8.1 Kotlin å±‚ï¼ˆCompose UIï¼‰</strong></h3>
<div class="doc-table-wrap"><table class="doc-table"><thead><tr><th>ç±»/æ–¹æ³•</th><th>æ–‡ä»¶è·¯å¾„</th><th>è¯´æ˜</th></tr></thead><tbody><tr><td>RenderNodeLayer</td><td>compose/ui/ui/src/skikoMain/kotlin/androidx/compose/ui/platform/RenderNodeLayer.skiko.kt</td><td>å›¾å±‚æ¡¥æ¥ç±»</td></tr><tr><td>drawLayer()</td><td>åŒä¸Š</td><td>å›¾å±‚ç»˜åˆ¶å…¥å£</td></tr><tr><td>performDrawLayer()</td><td>åŒä¸Š</td><td>æ‰§è¡Œç»˜åˆ¶ï¼ˆé˜´å½±ã€è£å‰ªã€é€æ˜åº¦ï¼‰</td></tr><tr><td>invalidate()</td><td>åŒä¸Š</td><td>å¤±æ•ˆå¤„ç†ï¼Œæ¸…é™¤ç¼“å­˜</td></tr></tbody></table></div>
<h3><strong>8.2 C++ å±‚ï¼ˆOHRenderï¼‰</strong></h3>
<div class="doc-table-wrap"><table class="doc-table"><thead><tr><th>ç±»/æ–¹æ³•</th><th>æ–‡ä»¶è·¯å¾„</th><th>è¯´æ˜</th></tr></thead><tbody><tr><td>SkPictureRecorder</td><td>OHRender/src/core/SkPictureRecorder.cpp</td><td>å‘½ä»¤å½•åˆ¶å™¨</td></tr><tr><td>beginRecording()</td><td>åŒä¸Š</td><td>å¼€å§‹å½•åˆ¶</td></tr><tr><td>finishRecordingAsPicture()</td><td>åŒä¸Š</td><td>å®Œæˆå½•åˆ¶</td></tr><tr><td>SkOHPicture</td><td>åŒä¸Š</td><td>Picture å®¹å™¨</td></tr><tr><td>playback()</td><td>åŒä¸Š</td><td>å›æ”¾ä¸æ¨¡å¼å†³ç­–</td></tr><tr><td>generateNewNode()</td><td>åŒä¸Š</td><td>èŠ‚ç‚¹è·å–/å…‹éš†</td></tr><tr><td>SkCanvas</td><td>OHRender/src/core/SkCanvas.cpp</td><td>ç»˜åˆ¶æ¥å£</td></tr><tr><td>beginSubCanvas()</td><td>åŒä¸Š</td><td>åˆ›å»ºå­ç”»å¸ƒ</td></tr><tr><td>finishSubCanvas()</td><td>åŒä¸Š</td><td>å®Œæˆå­ç”»å¸ƒ</td></tr><tr><td>getFinishDrawBounds()</td><td>åŒä¸Š</td><td>è·å–è„åŒºè¾¹ç•Œ</td></tr><tr><td>OHRenderNode</td><td>OHRender/src/oh/OHRenderNode.cpp</td><td>æ¸²æŸ“èŠ‚ç‚¹</td></tr><tr><td>pictureDraw()</td><td>åŒä¸Š</td><td>Picture æ¨¡å¼ç»˜åˆ¶</td></tr><tr><td>nodeDraw()</td><td>åŒä¸Š</td><td>Node æ¨¡å¼ç»˜åˆ¶</td></tr><tr><td>makeClone()</td><td>åŒä¸Š</td><td>èŠ‚ç‚¹å…‹éš†</td></tr><tr><td>appendChild()</td><td>åŒä¸Š</td><td>æ·»åŠ å­èŠ‚ç‚¹</td></tr></tbody></table></div>
<h3><strong>8.3 å¤´æ–‡ä»¶</strong></h3>
<div class="doc-table-wrap"><table class="doc-table"><thead><tr><th>æ–‡ä»¶</th><th>è·¯å¾„</th><th>è¯´æ˜</th></tr></thead><tbody><tr><td>SkPictureRecorder.h</td><td>OHRender/include/core/SkPictureRecorder.h</td><td>å½•åˆ¶å™¨å¤´æ–‡ä»¶</td></tr><tr><td>SkCanvas.h</td><td>OHRender/include/core/SkCanvas.h</td><td>ç”»å¸ƒå¤´æ–‡ä»¶</td></tr><tr><td>SkPicture.h</td><td>OHRender/include/core/SkPicture.h</td><td>Picture å¤´æ–‡ä»¶</td></tr><tr><td>OHRenderNode.h</td><td>OHRender/include/oh/OHRenderNode.h</td><td>èŠ‚ç‚¹å¤´æ–‡ä»¶</td></tr></tbody></table></div>
<h3><strong>8.4 ArkTS å±‚</strong></h3>
<div class="doc-table-wrap"><table class="doc-table"><thead><tr><th>ç±»/æ–¹æ³•</th><th>æ–‡ä»¶è·¯å¾„</th><th>è¯´æ˜</th></tr></thead><tbody><tr><td>CanvasNodeController</td><td>ui-arkui/src/ohosArm64Main/cpp/compose/src/main/ets/compose/CanvasNode.ets</td><td>Canvas èŠ‚ç‚¹æ§åˆ¶å™¨</td></tr><tr><td>Compose ç»„ä»¶</td><td>åŒä¸Š</td><td>Compose æ ¹ç»„ä»¶</td></tr></tbody></table></div>
<hr />
<h2><strong>é™„å½•ï¼šæ ¸å¿ƒæ•°æ®ç»“æ„é€ŸæŸ¥</strong></h2>
<h3><strong>RenderNodeLayer (Kotlin)</strong></h3>
<pre><code>internal class RenderNodeLayer : OwnedLayer {
private val pictureRecorder = PictureRecorder()
private var picture: Picture? = null
internal val matrix = Matrix()
private var alpha: Float = 1f
private var clip: Boolean = false
private var shadowElevation: Float = 0f
}</code></pre>
<h3><strong>SkOHPicture (C++)</strong></h3>
<pre><code>class SkOHPicture final : public SkPicture {
SkRect fCull;
bool fNoLimitDraw;
bool fPlaybackInNode;
bool fCanPlaybackInPicture;
OHDrawingRecordCmdSPtr fOHRecordCmd;
std::shared_ptr&lt;OHRenderNode&gt; fOriginNode;
mutable std::shared_ptr&lt;OHRenderNode&gt; fNowCacheNode;
mutable std::list&lt;std::shared_ptr&lt;OHRenderNode&gt;&gt; fCacheCloneNodes;
std::vector&lt;sk_sp&lt;SkPicture&gt;&gt; fSubPics;
};</code></pre>
<h3><strong>OHRenderNode (C++)</strong></h3>
<pre><code>class OHRenderNode {
int fNodeId;
SkRect fRealFrame;
SkMatrix fFatherMatrix;
OH_Drawing_RecordCmd* fPictureCmd;
std::shared_ptr&lt;OHRenderNode&gt; fParent;
std::list&lt;std::shared_ptr&lt;OHRenderNode&gt;&gt; fChildList;
bool fDrawInPicture = true;
bool fVisible = true;
};</code></pre></div>
      </section>
  </main>
  </div>

  <div class="img-modal" id="img-modal" aria-hidden="true">
    <div class="img-modal-backdrop"></div>
    <div class="img-modal-toolbar">
      <button type="button" id="img-zoom-out" title="ç¼©å°">-</button>
      <button type="button" id="img-zoom-in" title="æ”¾å¤§">+</button>
      <button type="button" id="img-zoom-reset" title="é‡ç½®">100%</button>
      <span class="zoom-value" id="img-zoom-value">100%</span>
      <button type="button" id="img-modal-close" title="å…³é—­">å…³é—­</button>
    </div>
    <div class="img-modal-image-wrap">
      <img id="img-modal-img" alt="" />
    </div>
  </div>


  <script>
    (function () {
      const root = document.getElementById('zoom-root');
      if (!root) return;
      const valueEl = document.getElementById('zoom-value');
      const min = 0.6;
      const max = 2.4;
      const step = 0.1;
      const key = "km_detail_zoom";
      let scale = 1;

      try {
        const saved = parseFloat(localStorage.getItem(key) || "1");
        if (!Number.isNaN(saved)) scale = saved;
      } catch (_) {}

      const clamp = (n) => Math.min(max, Math.max(min, n));

      const apply = () => {
        scale = clamp(scale);
        if ("zoom" in root.style) {
          root.style.zoom = String(scale);
        } else {
          root.style.transform = `scale(${scale})`;
          root.style.transformOrigin = "top center";
        }
        if (valueEl) valueEl.textContent = `${Math.round(scale * 100)}%`;
        try {
          localStorage.setItem(key, String(scale));
        } catch (_) {}
      };

      document.querySelectorAll("[data-zoom]").forEach((btn) => {
        btn.addEventListener("click", () => {
          const action = btn.getAttribute("data-zoom");
          if (action === "in") scale += step;
          if (action === "out") scale -= step;
          if (action === "reset") scale = 1;
          apply();
        });
      });

      window.addEventListener(
        "wheel",
        (event) => {
          if (!(event.ctrlKey || event.metaKey)) return;
          if (document.body.classList.contains("img-modal-open")) return;
          event.preventDefault();
          scale += event.deltaY < 0 ? step : -step;
          apply();
        },
        { passive: false }
      );

      window.addEventListener("keydown", (event) => {
        if (!(event.ctrlKey || event.metaKey)) return;
        if (event.key === "+" || event.key === "=") {
          event.preventDefault();
          scale += step;
          apply();
        } else if (event.key === "-") {
          event.preventDefault();
          scale -= step;
          apply();
        } else if (event.key === "0") {
          event.preventDefault();
          scale = 1;
          apply();
        }
      });

      apply();
    })();
  </script>


  <script>
    (function () {
      const modal = document.getElementById("img-modal");
      if (!modal) return;
      const image = document.getElementById("img-modal-img");
      const imageWrap = modal.querySelector(".img-modal-image-wrap");
      const closeBtn = document.getElementById("img-modal-close");
      const zoomOutBtn = document.getElementById("img-zoom-out");
      const zoomInBtn = document.getElementById("img-zoom-in");
      const zoomResetBtn = document.getElementById("img-zoom-reset");
      const zoomValue = document.getElementById("img-zoom-value");
      if (!image || !imageWrap) return;

      let scale = 1;
      const min = 0.2;
      const max = 6;
      const step = 0.15;
      let isDragging = false;
      let dragPointerId = null;
      let lastX = 0;
      let lastY = 0;

      const apply = () => {
        scale = Math.min(max, Math.max(min, scale));
        image.style.transform = `scale(${scale})`;
        if (zoomValue) zoomValue.textContent = `${Math.round(scale * 100)}%`;
      };

      const open = (src, alt) => {
        image.src = src;
        image.alt = alt || "";
        scale = 1;
        apply();
        imageWrap.scrollLeft = 0;
        imageWrap.scrollTop = 0;
        modal.classList.add("open");
        document.body.classList.add("img-modal-open");
        document.body.style.overflow = "hidden";
      };

      const stopDragging = () => {
        isDragging = false;
        dragPointerId = null;
        imageWrap.classList.remove("dragging");
      };

      const close = () => {
        stopDragging();
        modal.classList.remove("open");
        document.body.classList.remove("img-modal-open");
        document.body.style.overflow = "";
        image.removeAttribute("src");
      };

      document.querySelectorAll(".doc-figure img").forEach((img) => {
        const figure = img.closest(".doc-figure");
        const originSrc = img.getAttribute("data-origin-src") || img.src;

        const markFailed = () => {
          if (!figure) return;
          figure.classList.add("img-load-failed");
          const link = figure.querySelector(".img-open-link");
          if (link && !link.getAttribute("href")) {
            link.setAttribute("href", originSrc);
          }
        };

        img.addEventListener("error", () => {
          if (img.dataset.retriedNoQuery !== "1") {
            const noQuery = originSrc.split("?")[0];
            if (noQuery && noQuery !== originSrc) {
              img.dataset.retriedNoQuery = "1";
              img.src = noQuery;
              return;
            }
          }
          markFailed();
        });

        if (img.complete && img.naturalWidth === 0) {
          markFailed();
        }

        img.addEventListener("click", () => {
          if (img.naturalWidth > 0) {
            open(img.currentSrc || img.src, img.alt);
            return;
          }
          if (originSrc && originSrc !== "#") {
            window.open(originSrc, "_blank", "noopener,noreferrer");
          }
        });
      });

      closeBtn?.addEventListener("click", close);
      modal.addEventListener("click", (event) => {
        if (event.target === modal || event.target.classList.contains("img-modal-backdrop")) {
          close();
        }
      });

      zoomInBtn?.addEventListener("click", () => { scale += step; apply(); });
      zoomOutBtn?.addEventListener("click", () => { scale -= step; apply(); });
      zoomResetBtn?.addEventListener("click", () => { scale = 1; apply(); });

      imageWrap.addEventListener("pointerdown", (event) => {
        if (!modal.classList.contains("open")) return;
        if (event.button !== 0) return;
        isDragging = true;
        dragPointerId = event.pointerId;
        lastX = event.clientX;
        lastY = event.clientY;
        imageWrap.classList.add("dragging");
        imageWrap.setPointerCapture?.(event.pointerId);
        event.preventDefault();
      });

      imageWrap.addEventListener("pointermove", (event) => {
        if (!isDragging || event.pointerId !== dragPointerId) return;
        const dx = event.clientX - lastX;
        const dy = event.clientY - lastY;
        imageWrap.scrollLeft -= dx;
        imageWrap.scrollTop -= dy;
        lastX = event.clientX;
        lastY = event.clientY;
      });

      const onPointerDone = (event) => {
        if (event.pointerId !== dragPointerId) return;
        imageWrap.releasePointerCapture?.(event.pointerId);
        stopDragging();
      };

      imageWrap.addEventListener("pointerup", onPointerDone);
      imageWrap.addEventListener("pointercancel", onPointerDone);

      modal.addEventListener(
        "wheel",
        (event) => {
          if (!modal.classList.contains("open")) return;
          event.preventDefault();
          scale += event.deltaY < 0 ? step : -step;
          apply();
        },
        { passive: false }
      );

      window.addEventListener("keydown", (event) => {
        if (!modal.classList.contains("open")) return;
        if (event.key === "Escape") {
          close();
        } else if (event.key === "+" || event.key === "=") {
          event.preventDefault();
          scale += step;
          apply();
        } else if (event.key === "-") {
          event.preventDefault();
          scale -= step;
          apply();
        } else if (event.key === "0") {
          event.preventDefault();
          scale = 1;
          apply();
        }
      });
    })();
  </script>


  <script>
    (function () {
      const roots = document.querySelectorAll(".content.rich");
      if (!roots.length) return;

      const h3Pattern = /^(?:[ä¸€äºŒä¸‰å››äº”å…­ä¸ƒå…«ä¹å]+[ã€.ï¼]|\d+[ã€.ï¼)])\s*/;
      const h4Pattern = /^\d+\.\d+\s*/;
      const shortTitlePattern = /(?:æµç¨‹|æ­¥éª¤|è¯´æ˜|é…ç½®|å‘½ä»¤|ç›®å½•|è¦æ±‚|æ¦‚è§ˆ)$/;
      const bulletPattern = /^[-*â€¢]\s+/;
      const numberItemPattern = /^\d+[.)ã€]\s+/;

      const commandPattern =
        /^(?:\$\s*)?(?:export|git|ohpm|npm|pnpm|yarn|npx|python|python3|java|javac|gradle|\.\/gradlew|\.\/|adb|hdc|cmake|make|brew|curl|wget|source|chmod|chown|cp|mv|ls|cat|echo)\b/i;
      const envAssignPattern = /^(?:[A-Z_][A-Z0-9_]*=|PATH=|JAVA_HOME=|ANDROID_HOME=)/;
      const pathLikePattern = /(?:^\/|^\.\/|https?:\/\/|[\w.-]+\/[\w./-]+)/;

      const esc = (value) => {
        const span = document.createElement("span");
        span.textContent = value;
        return span.innerHTML;
      };

      const isCommandLike = (text) => {
        const sample = text.trim();
        if (!sample) return false;
        if (sample.length > 220) return false;
        if (commandPattern.test(sample)) return true;
        if (envAssignPattern.test(sample)) return true;
        if (sample.includes(" && ") || sample.includes(" || ")) return true;
        if (pathLikePattern.test(sample) && /\b(?:build|publish|clone|install|run|export|gradle|script)\b/i.test(sample)) {
          return true;
        }
        return false;
      };

      roots.forEach((root) => {
        const children = Array.from(root.children);
        const rebuilt = [];
        let codeBuffer = [];

        const flushCode = () => {
          if (!codeBuffer.length) return;
          const pre = document.createElement("pre");
          pre.className = "auto-code";
          const code = document.createElement("code");
          code.textContent = codeBuffer.join("\n");
          pre.appendChild(code);
          rebuilt.push(pre);
          codeBuffer = [];
        };

        children.forEach((node) => {
          if (node.tagName !== "P") {
            flushCode();
            rebuilt.push(node);
            return;
          }

          const text = (node.textContent || "").replace(/\u00A0/g, " ").trim();
          if (!text) return;

          if (h3Pattern.test(text)) {
            flushCode();
            const h3 = document.createElement("h3");
            h3.className = "auto-h3";
            h3.textContent = text;
            rebuilt.push(h3);
            return;
          }

          if (h4Pattern.test(text) || (text.length <= 24 && shortTitlePattern.test(text))) {
            flushCode();
            const h4 = document.createElement("h4");
            h4.className = "auto-h4";
            h4.textContent = text;
            rebuilt.push(h4);
            return;
          }

          const keyValue = text.match(/^([^:ï¼š]{2,20}[ï¼š:])\s*(.+)$/);
          if (keyValue) {
            const key = keyValue[1].trim();
            const value = keyValue[2].trim();
            if (value && isCommandLike(value)) {
              flushCode();
              const row = document.createElement("p");
              row.className = "kv-row";
              row.innerHTML = `<span class="kv-key">${esc(key)}</span><code>${esc(value)}</code>`;
              rebuilt.push(row);
              return;
            }
            if (value && value.length <= 120) {
              flushCode();
              const row = document.createElement("p");
              row.className = "kv-row";
              row.innerHTML = `<span class="kv-key">${esc(key)}</span><span>${esc(value)}</span>`;
              rebuilt.push(row);
              return;
            }
          }

          if (isCommandLike(text)) {
            codeBuffer.push(text);
            return;
          }

          if (bulletPattern.test(text) || numberItemPattern.test(text)) {
            flushCode();
            rebuilt.push(node);
            return;
          }

          flushCode();
          rebuilt.push(node);
        });

        flushCode();
        root.replaceChildren(...rebuilt);
      });
    })();
  </script>

  <script>
    (() => {
      const back = document.getElementById("chapter-back-link");
      if (!back) return;
      const chapter = (new URLSearchParams(window.location.search).get("chapter") || "all").trim().toLowerCase();
      if (!/^[a-z0-9-]+$/.test(chapter) || chapter === "all") {
        back.href = "../knowledge-map-chapters.html";
        return;
      }
      back.href = `../knowledge-map-chapters-${chapter}.html`;
    })();
  </script>
</body>
</html>
