<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>SlotTable 与 Composition 完整详解</title>
  <style>
    :root {
      --bg: #f6f8f7;
      --card: #ffffff;
      --ink: #10231c;
      --muted: #4f6d66;
      --accent: #0f7668;
      --line: #d5e2de;
    }
    * { box-sizing: border-box; }
    body { margin: 0; font-family: "PingFang SC", "Noto Sans SC", sans-serif; background: var(--bg); color: var(--ink); }
    .wrap { max-width: 980px; margin: 0 auto; padding: 24px 18px 42px; }
    .top { display: flex; flex-wrap: wrap; gap: 10px; margin-bottom: 12px; }
    .back { color: var(--accent); text-decoration: none; font-size: 14px; }
    h1 { margin: 0 0 8px; font-size: 30px; }
    .meta { display: flex; flex-wrap: wrap; gap: 8px; margin-bottom: 12px; }
    .chip { background: #dff1ec; color: var(--accent); border-radius: 999px; padding: 4px 10px; font-size: 12px; }
    .section { background: var(--card); border: 1px solid var(--line); border-radius: 14px; padding: 14px; margin-top: 12px; box-shadow: 0 8px 24px rgba(16,35,28,.05); }
    .section-head { display: flex; justify-content: space-between; gap: 10px; align-items: baseline; }
    .section-head h2 { margin: 0; font-size: 20px; }
    .section-head span { color: var(--accent); font-size: 13px; }
    .summary { color: #48665f; margin: 8px 0; font-size: 15px; line-height: 1.65; }
    .points { margin: 0 0 8px; padding-left: 18px; color: #48665f; }
    .points li { line-height: 1.65; }
    .content { margin: 0; background: linear-gradient(180deg, #fbfefe 0%, #f7fbfa 100%); border: 1px solid var(--line); border-radius: 12px; padding: 14px; line-height: 1.7; font-size: 16px; color: #173029; }
    .content h1, .content h2, .content h3, .content h4 { margin: 14px 0 8px; line-height: 1.35; color: #0f3028; }
    .content h1:first-child, .content h2:first-child, .content h3:first-child, .content h4:first-child { margin-top: 0; }
    .content h2 { font-size: 24px; font-weight: 750; }
    .content h3 { font-size: 20px; font-weight: 700; }
    .content h4 { font-size: 17px; font-weight: 680; color: #1b4b40; }
    .content .auto-h3 { border-left: 4px solid #78b6a7; padding-left: 10px; }
    .content .auto-h4 { color: #205145; }
    .content p { margin: 0 0 9px; color: #1e3b34; }
    .content p:last-child { margin-bottom: 0; }
    .content ul, .content ol { margin: 0 0 10px; padding-left: 20px; }
    .content li + li { margin-top: 6px; }
    .content.xmind-outline { background: linear-gradient(180deg, #f8fcfb 0%, #f2f8f6 100%); }
    .content.xmind-outline ul, .content.xmind-outline ol {
      list-style: none;
      margin: 8px 0 0 0;
      padding-left: 22px;
      border-left: 1px solid #c7ddd6;
    }
    .content.xmind-outline > ul, .content.xmind-outline > ol {
      border-left: none;
      padding-left: 0;
      margin-top: 0;
    }
    .content.xmind-outline li {
      position: relative;
      margin: 8px 0;
      padding: 6px 10px;
      background: #ffffff;
      border: 1px solid #d6e7e2;
      border-radius: 10px;
      box-shadow: 0 1px 0 rgba(15, 87, 74, 0.06);
    }
    .content.xmind-outline li::before {
      content: "";
      position: absolute;
      left: -22px;
      top: 50%;
      width: 22px;
      border-top: 1px solid #c7ddd6;
      transform: translateY(-50%);
    }
    .content.xmind-outline > ul > li::before,
    .content.xmind-outline > ol > li::before { display: none; }
    .content.xmind-outline li > ul,
    .content.xmind-outline li > ol { margin-top: 8px; }
    .content blockquote { margin: 10px 0; padding: 8px 12px; border-left: 3px solid #99c6bb; background: #edf7f4; color: #375852; border-radius: 6px; }
    .content hr { border: none; border-top: 1px dashed #b8d2cb; margin: 12px 0; }
    .content a { color: #0b6d61; text-decoration: none; border-bottom: 1px dashed rgba(11,109,97,.35); }
    .content a:hover { border-bottom-style: solid; }
    .content code { font-family: "SFMono-Regular", Menlo, Consolas, monospace; }
    .content :not(pre) > code { background: #e6f2ef; color: #0f5f54; border-radius: 6px; padding: 2px 6px; }
    .content pre { margin: 10px 0; white-space: pre; overflow: auto; background: #122520; color: #e8f5f1; border-radius: 10px; padding: 12px; box-shadow: inset 0 0 0 1px rgba(124,196,178,.24); }
    .content pre code { background: transparent; color: inherit; padding: 0; border-radius: 0; }
    .content pre.auto-code { border-left: 4px solid #2ea78c; }
    .content .kv-row { display: flex; gap: 8px; align-items: baseline; flex-wrap: wrap; }
    .content .kv-key { color: #1b5e50; font-weight: 700; }
    .doc-table-wrap { overflow-x: auto; margin: 8px 0; }
    .doc-table { width: 100%; border-collapse: collapse; min-width: 640px; }
    .doc-table th, .doc-table td { border: 1px solid #c8d8d3; padding: 8px; text-align: left; vertical-align: top; }
    .doc-table th { background: #e8f4f0; }
    .doc-figure { margin: 10px 0; }
    .doc-figure img { max-width: 100%; height: auto; border: 1px solid #c8d8d3; border-radius: 8px; display: block; background: #f3f7f6; }
    .doc-figure.xmind-figure { margin: 6px 0; }
    .doc-figure.xmind-figure figcaption { margin-top: 8px; font-size: 13px; color: #496861; }
    .doc-figure .img-fallback { display: none; margin-top: 6px; font-size: 12px; color: #496861; }
    .doc-figure .img-fallback a { color: #0f7668; }
    .doc-figure.img-load-failed .img-fallback { display: block; }

    .view-controls { position: fixed; top: 12px; right: 12px; z-index: 3000; display: flex; align-items: center; gap: 6px; background: rgba(255,255,255,.94); border: 1px solid #d5e2de; border-radius: 999px; padding: 6px 8px; box-shadow: 0 6px 20px rgba(16,35,28,.12); }
    .view-controls button { border: 1px solid #c6d8d3; background: #f3faf8; color: #0f7668; border-radius: 999px; min-width: 30px; height: 30px; cursor: pointer; font-size: 14px; }
    .view-controls button:hover { background: #e3f2ee; }
    .view-controls .zoom-value { font-size: 12px; color: #3b5d56; min-width: 44px; text-align: center; }
    .zoom-root { transform-origin: top center; }
    

    .doc-figure img { cursor: zoom-in; }
    .img-modal { position: fixed; inset: 0; display: none; z-index: 4000; }
    .img-modal.open { display: block; }
    .img-modal-backdrop { position: absolute; inset: 0; background: rgba(10, 14, 18, .85); }
    .img-modal-toolbar { position: absolute; top: 12px; right: 12px; z-index: 2; display: flex; gap: 6px; align-items: center; background: rgba(255,255,255,.95); border-radius: 999px; padding: 6px 8px; }
    .img-modal-toolbar button { border: 1px solid #c6d8d3; background: #f3faf8; color: #0f7668; border-radius: 999px; min-width: 30px; height: 30px; cursor: pointer; }
    .img-modal-toolbar .zoom-value { min-width: 44px; text-align: center; font-size: 12px; color: #3b5d56; }
    .img-modal-image-wrap { position: absolute; inset: 64px 24px 24px; display: grid; place-items: center; overflow: auto; cursor: grab; user-select: none; touch-action: none; }
    .img-modal-image-wrap.dragging { cursor: grabbing; }
    .img-modal-image-wrap img { max-width: 100%; max-height: 100%; transform-origin: center center; pointer-events: none; -webkit-user-drag: none; user-select: none; }
    
  </style>
</head>
<body>
  
  <div class="view-controls" aria-label="页面缩放工具">
    <button type="button" data-zoom="out" title="缩小">-</button>
    <button type="button" data-zoom="in" title="放大">+</button>
    <button type="button" data-zoom="reset" title="重置">100%</button>
    <span class="zoom-value" id="zoom-value">100%</span>
  </div>

  <div class="zoom-root" id="zoom-root">
  <main class="wrap">
    <div class="top">
      <a class="back" href="../knowledge-map.html">返回入口</a>
      <a class="back" id="chapter-back-link" href="../knowledge-map-chapters.html">返回章节列表</a>
    </div>
    <h1>SlotTable 与 Composition 完整详解</h1>
    <div class="meta">
      <span class="chip">CMP框架知识地图</span>
      <span class="chip">69 分钟</span>
      <span class="chip">runtime-analysis/SlotTable 与 Composition 完整详解.docx</span>
    </div>

      <section class="section">
        <div class="section-head">
          <h2>SlotTable 与 Composition 完整详解</h2>
          <span>69 分钟</span>
        </div>
        <p class="summary">SlotTable 与 Composition 完整详解 目录 SlotTable 概述 为什么需要 SlotTable SlotTable 的核心结构 核心概念详解 Slo...</p>
        <ul class="points"><li>状态持久化</li><li>结构比较</li><li>增量更新</li><li>作用域管理</li></ul>
        <div class="content rich"><h1>SlotTable 与 Composition 完整详解</h1>
<h2><strong>目录</strong></h2>
<ol>
<li>SlotTable 概述</li>
<li>为什么需要 SlotTable</li>
<li>SlotTable 的核心结构</li>
<li>核心概念详解</li>
<li>SlotTable 与 LayoutNode 的关系</li>
<li>SlotTable 的使用方式</li>
<li>Composition 初始化流程</li>
<li>startRoot() 方法详解</li>
<li>实际应用示例</li>
</ol>
<hr />
<h2><strong>SlotTable 概述</strong></h2>
<p><code>SlotTable</code> 是 Compose 运行时的<strong>核心数据结构</strong>，用于在内存中存储整个 Composition Tree（组合树）的完整状态信息。它是 Compose 增量重组（Incremental Recomposition）机制的基础。</p>
<h3><strong>类比理解</strong></h3>
<p>可以将 <code>SlotTable</code> 理解为：</p>
<ul>
<li><strong>UI 树的内存快照</strong>：存储了当前 UI 的结构和所有状态</li>
<li><strong>状态管理器</strong>：管理每个 composable 的状态值（remember、mutableStateOf 等）</li>
<li><strong>差异比较器</strong>：通过对比新旧 SlotTable 找出需要重组的部分</li>
<li><strong>设计图纸</strong>：存储了 UI 的完整结构和状态，描述了每个组件的类型、参数、状态值</li>
</ul>
<hr />
<h2><strong>为什么需要 SlotTable</strong></h2>
<p>Compose 的增量重组机制需要解决以下问题：</p>
<h3><strong>1. 状态持久化</strong></h3>
<ul>
<li>需要在重组之间保存状态值</li>
<li>例如 <code>remember { mutableStateOf(0) }</code> 的值必须在重组后保持不变</li>
</ul>
<h3><strong>2. 结构比较</strong></h3>
<ul>
<li>需要比较新旧组合树的结构</li>
<li>识别哪些 composable 被添加、删除或修改</li>
</ul>
<h3><strong>3. 增量更新</strong></h3>
<ul>
<li>只重组真正变化的部分</li>
<li>避免全量重建带来的性能损失</li>
</ul>
<h3><strong>4. 作用域管理</strong></h3>
<ul>
<li>管理 CompositionLocal 的作用域</li>
<li>跟踪哪些 composable 需要访问哪些上下文值</li>
</ul>
<p><strong>SlotTable 就是解决这些问题的核心数据结构。</strong></p>
<hr />
<h2><strong>SlotTable 的核心结构</strong></h2>
<h3><strong>数据结构定义</strong></h3>
<pre><code>internal class SlotTable : CompositionData, Iterable&lt;CompositionGroup&gt; {
// 1. Groups 数组：存储"组"的元数据（类似树的节点信息）
var groups = IntArray(0)
var groupsSize = 0
// 2. Slots 数组：存储实际的数据值（状态值、参数等）
var slots = Array&lt;Any?&gt;(0) { null }
var slotsSize = 0
// 3. 读写控制
private var readers = 0 // 当前活跃的 Reader 数量
internal var writer = false // 是否有活跃的 Writer
// 4. 版本控制
internal var version = 0 // 用于检测并发修改
// 5. Anchor 管理
internal var anchors: ArrayList&lt;Anchor&gt; = arrayListOf()
}</code></pre>
<h3><strong>Groups 数组的结构</strong></h3>
<p>每个 Group 在 <code>groups</code> 数组中占用 <strong>5 个连续的整数</strong>：</p>
<pre><code>[Key, GroupInfo, ParentAnchor, Size, DataAnchor]</code></pre>
<h3><strong>理解：像"身份证信息"</strong></h3>
<p>想象每个 Group 就像一个人的身份证，需要存储 5 条信息：</p>
<pre><code>身份证：[姓名, 性别, 出生日期, 地址, 身份证号]
↑ ↑ ↑ ↑ ↑
信息1 信息2 信息3 信息4 信息5</code></pre>
<p><strong>在 groups 数组中：</strong></p>
<pre><code>groups 数组：[Key, GroupInfo, ParentAnchor, Size, DataAnchor]
↑ ↑ ↑ ↑ ↑
信息1 信息2 信息3 信息4 信息5</code></pre>
<h3><strong>具体例子：一个 Text 组</strong></h3>
<p>假设有一个 <code>Text("Hello")</code> 组，它在 groups 数组中占 5 个位置：</p>
<pre><code>groups 数组（IntArray）：
索引: 0 1 2 3 4 5 6 7 8 9 ...
值: [Key, Info, Parent, Size, Data, Key, Info, Parent, Size, Data, ...]
↑ ↑
Text组（5个整数） 下一个组（5个整数）</code></pre>
<h3><strong>为什么是 5 个整数？</strong></h3>
<p>这 5 个信息是 Group 的<strong>最小必需信息</strong>：</p>
<ol>
<li><strong>Key (Offset 0)</strong>：组的整数键值，用于识别 composable</li>
<li><strong>GroupInfo (Offset 1)</strong>：标志位，包含：</li>
</ol>
<ul>
<li>是否为 Node（UI 节点）</li>
<li>是否有 ObjectKey</li>
<li>是否有 Aux 数据</li>
<li>是否被标记（Mark）</li>
<li>节点数量（Node Count）</li>
</ul>
<ol>
<li><strong>ParentAnchor (Offset 2)</strong>：父组的锚点引用</li>
<li><strong>Size (Offset 3)</strong>：组的尺寸（包含自身和所有子组）</li>
<li><strong>DataAnchor (Offset 4)</strong>：指向 slots 数组的锚点</li>
</ol>
<p><strong>就像身份证必须有这 5 项信息才能完整描述一个人！</strong></p>
<h3><strong>如何访问 Group 的信息？</strong></h3>
<pre><code>// 假设 Group 从索引 startIndex 开始
fun getGroupKey(groups: IntArray, startIndex: Int): Int {
return groups[startIndex + 0] // Offset 0: Key
}
fun getGroupInfo(groups: IntArray, startIndex: Int): Int {
return groups[startIndex + 1] // Offset 1: GroupInfo
}
fun getParentAnchor(groups: IntArray, startIndex: Int): Int {
return groups[startIndex + 2] // Offset 2: ParentAnchor
}
fun getGroupSize(groups: IntArray, startIndex: Int): Int {
return groups[startIndex + 3] // Offset 3: Size
}
fun getDataAnchor(groups: IntArray, startIndex: Int): Int {
return groups[startIndex + 4] // Offset 4: DataAnchor
}</code></pre>
<h3><strong>实际例子：多个 Group</strong></h3>
<p>假设有 3 个 Group（Column、Text1、Text2）：</p>
<pre><code>// groups 数组（简化示例）
val groups = intArrayOf(
// Group 1: Column（索引 0-4）
100, // Key: Column 的 hash
0, // GroupInfo: 普通组
-1, // ParentAnchor: 没有父组
15, // Size: 占用 15 个整数（包含自己和子组）
0, // DataAnchor: 指向 slots[0]
// Group 2: Text1（索引 5-9）
200, // Key: Text 的 hash
1, // GroupInfo: Node 组
0, // ParentAnchor: 父组在索引 0（Column）
5, // Size: 占用 5 个整数
1, // DataAnchor: 指向 slots[1]
// Group 3: Text2（索引 10-14）
200, // Key: Text 的 hash（和 Text1 相同）
1, // GroupInfo: Node 组
0, // ParentAnchor: 父组在索引 0（Column）
5, // Size: 占用 5 个整数
2 // DataAnchor: 指向 slots[2]
)</code></pre>
<p><strong>访问 Text1 组的信息：</strong></p>
<pre><code>val text1StartIndex = 5
val key = groups[text1StartIndex + 0] // = 200
val info = groups[text1StartIndex + 1] // = 1
val parent = groups[text1StartIndex + 2] // = 0（指向 Column）
val size = groups[text1StartIndex + 3] // = 5
val dataAnchor = groups[text1StartIndex + 4] // = 1（指向 slots[1]）</code></pre>
<h3><strong>内存布局图示</strong></h3>
<pre><code>groups 数组（IntArray）：
┌─────────────────────────────────────────────────────────┐
│ 索引 │ 0 │ 1 │ 2 │ 3 │ 4 │ 5 │ 6 │ 7 │ ...
├─────────────────────────────────────────────────────────┤
│ 值 │ Key │Info │Parent│Size │Data │ Key │Info │Parent│ ...
│ │ 100 │ 0 │ -1 │ 15 │ 0 │ 200 │ 1 │ 0 │ ...
└─────────────────────────────────────────────────────────┘
↑ ↑ ↑
Column组（5个整数） Text1组（5个整数） Text2组（5个整数）
索引0-4 索引5-9 索引10-14</code></pre>
<h3><strong>为什么用连续整数而不是对象？</strong></h3>
<p><strong>性能优势：</strong></p>
<ol>
<li><strong>内存连续</strong>：5 个整数连续存储，CPU 缓存友好</li>
<li><strong>访问快速</strong>：直接通过索引访问，无需对象解引用</li>
<li><strong>内存紧凑</strong>：每个 Group 只占 20 字节（5 × 4 字节），比对象小得多</li>
<li><strong>批量操作</strong>：可以批量移动、复制整块数据</li>
</ol>
<p><strong>对比：</strong></p>
<pre><code>// 如果用对象（慢）：
class Group {
var key: Int
var info: Int
var parent: Int
var size: Int
var dataAnchor: Int
}
// 每个对象还有对象头（8-16 字节），总共约 40+ 字节
// 用 IntArray（快）：
groups[startIndex + 0] // 直接访问，20 字节</code></pre>
<h3><strong>Slots 数组的结构</strong></h3>
<p><code>slots</code> 数组存储每个组的实际数据：</p>
<ul>
<li>对于 Node 组：存储 <code>LayoutNode</code></li>
<li>对于普通组：存储参数值、lambda、状态值等</li>
<li>可选：ObjectKey、Aux 数据（如 CompositionLocal map）</li>
</ul>
<hr />
<h2><strong>核心概念详解</strong></h2>
<h3><strong>1. Group（组）</strong></h3>
<p><strong>Group</strong> 对应一个 composable 函数的调用，形成树形结构：</p>
<pre><code>Column { // Group 1 (根组)
Text("A") // Group 2 (Column 的子组)
Row { // Group 3 (Column 的子组)
Text("B") // Group 4 (Row 的子组)
}
}</code></pre>
<p>每个 Group 包含：</p>
<ul>
<li>结构信息：在树中的位置、父子关系</li>
<li>元数据：key、是否是节点、节点数量</li>
<li>数据引用：指向 slots 数组中实际数据的锚点</li>
</ul>
<h3><strong>2. Slot（插槽）</strong></h3>
<p><strong>Slot</strong> 是 <code>slots</code> 数组中的元素，存储实际的业务数据：</p>
<pre><code>@Composable
fun MyComposable(state: Int, onEvent: () -&gt; Unit) {
// state 和 onEvent 会存储在 slots 中
Text("Count: $state")
}</code></pre>
<p>不同类型的 Slot：</p>
<ul>
<li><strong>参数 Slot</strong>：存储函数参数值</li>
<li><strong>状态 Slot</strong>：存储 <code>remember</code>、<code>mutableStateOf</code> 的值</li>
<li><strong>Lambda Slot</strong>：存储回调函数</li>
<li><strong>Node Slot</strong>：存储 <code>LayoutNode</code> 或其他 UI 节点</li>
</ul>
<h3><strong>3. Anchor（锚点）</strong></h3>
<p><strong>Anchor 就像书签或者门牌号</strong>，用来记住"某个东西在哪里"。</p>
<h4><strong>生活化例子：图书馆的书架</strong></h4>
<p>想象你在图书馆管理书籍：</p>
<pre><code>书架：[书1][书2][书3][书4][书5]
↑ ↑ ↑ ↑ ↑
位置0 位置1 位置2 位置3 位置4</code></pre>
<p><strong>普通方式（容易出错）：</strong></p>
<ul>
<li>你记录："书3 在第 2 个位置"</li>
<li>但如果有人在位置 1 插入新书，书3 就变成位置 3 了，你的记录就错了！</li>
</ul>
<p><strong>使用 Anchor（智能定位）：</strong></p>
<ul>
<li>Anchor 有两种记录方式：</li>
</ul>
<ol>
<li><strong>正数</strong>：从左边数（"从开头数第几个"）</li>
<li><strong>负数</strong>：从右边数（"从末尾数第几个"）</li>
</ol>
<p><strong>举个例子：</strong></p>
<pre><code>数组：[A][B][C][D][E] (长度 5)
↑ ↑ ↑ ↑ ↑
0 1 2 3 4
假设有个"空隙"（gap）在位置 2：
[A][B][_][_][C][D][E]
↑ ↑ ↑↑ ↑ ↑ ↑
0 1 23 4 5 6
gap在这里</code></pre>
<ul>
<li><strong>书 A（位置 0）</strong>：Anchor = 0（从左边数）</li>
<li><strong>书 B（位置 1）</strong>：Anchor = 1（从左边数）</li>
<li><strong>书 C（位置 4）</strong>：Anchor = -3（从右边数：总共 7 个位置，C 是倒数第 3 个）</li>
<li><strong>书 D（位置 5）</strong>：Anchor = -2（从右边数：倒数第 2 个）</li>
<li><strong>书 E（位置 6）</strong>：Anchor = -1（从右边数：倒数第 1 个）</li>
</ul>
<p><strong>为什么这样设计？</strong></p>
<p>当 gap 移动时：</p>
<ul>
<li>如果 gap 在位置 2，只影响位置 2 附近的 Anchor</li>
<li>位置 0、1 的 Anchor 不变（它们用正数，从左边数）</li>
<li>位置 4、5、6 的 Anchor 不变（它们用负数，从右边数）</li>
<li><strong>只有跨越 gap 的 Anchor 才需要更新</strong></li>
</ul>
<h3><strong>4. Gap Buffer（间隙缓冲区）</strong></h3>
<p><strong>Gap Buffer 就像在数组中预留一个"空位"</strong>，方便快速插入和删除。</p>
<h4><strong>Gap 是否存在于 groups 数组中？</strong></h4>
<p><strong>答案：是的！</strong> Gap 确实存在于 <code>groups</code> 数组中，但它是<strong>未使用的空间</strong>，不是有效的 Group 数据。</p>
<p><strong>关键理解：</strong></p>
<ul>
<li>Gap 是数组中的<strong>空位</strong>（未初始化的位置或可覆盖的位置）</li>
<li>Gap 不是 Group，它只是<strong>预留的空间</strong></li>
<li>Gap 的位置会动态移动，用于优化插入/删除操作</li>
</ul>
<h4><strong>Gap 在 groups 数组中的存在方式</strong></h4>
<p><strong>方式 1：未初始化的位置</strong></p>
<pre><code>// groups 数组（初始状态，gap 在末尾）
val groups = IntArray(20) // 分配 20 个位置
// 假设已经存储了 3 个 Group（占用 15 个位置）
// [Group1(5个)][Group2(5个)][Group3(5个)][_][_][_][_][_]
// 索引0-4 索引5-9 索引10-14 15 16 17 18 19
// ↑
// gap 在这里</code></pre>
<p><strong>方式 2：可覆盖的位置</strong></p>
<pre><code>// 当 gap 移动到中间时
// [Group1][Group2][_][_][Group3]
// 0-4 5-9 10 11 12-16
// ↑↑
// gap 在这里（可以覆盖）
// 这些位置（索引 10-11）的值可能是：
// - 0（未初始化）
// - 之前 Group 的残留数据（会被覆盖）
// - 任意值（不重要，因为会被覆盖）</code></pre>
<h4><strong>Gap 的表示方式</strong></h4>
<p><strong>Gap 不是用特殊值标记的，而是通过位置范围来跟踪：</strong></p>
<pre><code>class SlotTable {
var groups = IntArray(0)
var groupsSize = 0 // 实际使用的 Group 数量
// Gap 的位置（内部维护）
private var gapStart = 0 // Gap 的起始位置
private var gapEnd = 0 // Gap 的结束位置
// Gap 的大小
fun gapSize(): Int = gapEnd - gapStart
}</code></pre>
<h4><strong>Gap 性能优化的原理</strong></h4>
<p><strong>关键理解：</strong></p>
<ul>
<li>Gap 确实只用<strong>两个值</strong>（<code>gapStart</code> 和 <code>gapEnd</code>）来标记一个<strong>连续的空位区域</strong></li>
<li>性能优化的关键在于：<strong>在 gap 位置的操作是 O(1)</strong>，而普通数组是 O(n)</li>
</ul>
<p><strong>性能对比：普通数组 vs Gap Buffer</strong></p>
<p><strong>场景：在位置 i 插入一个 Group（占用 5 个位置）</strong></p>
<p><strong>普通数组（慢）：</strong></p>
<pre><code>// 数组：[A][B][C][D][E]
// 0 1 2 3 4
// 想在位置 2 插入 [X][X][X][X][X]
// 需要移动后面的所有元素！
// 时间复杂度：O(n) // n 是后面元素的数量</code></pre>
<p><strong>Gap Buffer（快）：</strong></p>
<pre><code>// 数组：[A][B][_][_][_][_][_][C][D][E]
// 0 1 2 3 4 5 6 7 8 9
// ↑ ↑
// gapStart gapEnd
// 如果 gap 就在位置 2，直接插入！
// 时间复杂度：O(1) // 如果 gap 就在目标位置</code></pre>
<p><strong>关键优化点：</strong></p>
<ol>
<li><strong>在 Gap 位置操作是 O(1)</strong>：如果 gap 正好在要插入的位置，直接插入，无需移动任何元素！</li>
<li><strong>移动 Gap 的成本可以分摊</strong>：虽然移动 gap 需要 O(距离)，但这个成本可以分摊到多次操作中</li>
<li><strong>智能策略</strong>：Compose 使用批量操作和预测策略来最小化移动成本</li>
<li><strong>连续区域</strong>：gap 是一个连续的空位区域，两个值就足够描述</li>
</ol>
<p><strong>为什么只有两个值就够了？</strong></p>
<p><strong>答案：因为 gap 是一个连续的区域！</strong></p>
<pre><code>// Gap 的结构
gapStart = 10 // Gap 的起始位置
gapEnd = 20 // Gap 的结束位置
// Gap 的大小
gapSize = gapEnd - gapStart // = 10
// Gap 覆盖的区域
// [有效数据][_][_][_][_][_][_][_][_][_][有效数据]
// ↑ ↑
// gapStart gapEnd
// (索引 10) (索引 20)</code></pre>
<p><strong>关键点：</strong></p>
<ul>
<li><strong>一个连续区域</strong>：gap 是一个连续的空位，不是多个分散的空位</li>
<li><strong>两个值足够</strong>：只需要 <code>gapStart</code> 和 <code>gapEnd</code> 就能完全描述这个区域</li>
<li><strong>简单高效</strong>：两个值的维护成本很低，但带来的性能提升很大</li>
</ul>
<h3><strong>5. GroupInfo 详解</strong></h3>
<p><strong>GroupInfo</strong> 是一个整数，用<strong>二进制位（bit）</strong>存储多个布尔标志，就像开关一样。</p>
<p><strong>类比理解：</strong></p>
<p>就像房间里的多个开关：</p>
<ul>
<li>开关1：灯是否亮（是/否）</li>
<li>开关2：空调是否开（是/否）</li>
<li>开关3：窗户是否开（是/否）</li>
<li>…</li>
</ul>
<p>GroupInfo 用一个整数存储多个这样的开关状态！</p>
<h4><strong>GroupInfo 存储哪些信息？</strong></h4>
<p>GroupInfo 的每个二进制位代表一个标志：</p>
<pre><code>位位置（从右到左）：
位 0: 是否为 Node（UI 节点）
位 1: 是否有 ObjectKey
位 2: 是否有 Aux 数据
位 3: 是否被标记（Mark）
位 4-31: 节点数量（Node Count）</code></pre>
<p><strong>示例：</strong></p>
<pre><code>// 假设 GroupInfo = 0b00000001
// 二进制：00000000 00000000 00000000 00000001
// ↑ ↑
// 高位 低位（位0）
// = 1（是 Node）</code></pre>
<h4><strong>GroupInfo 有什么用？</strong></h4>
<p><strong>作用 1：快速判断 Group 的类型</strong></p>
<pre><code>// 检查是否是 Node 组
fun isNodeGroup(groupInfo: Int): Boolean {
return (groupInfo and 0b1) != 0 // 检查位 0
}
// 检查是否有 ObjectKey
fun hasObjectKey(groupInfo: Int): Boolean {
return (groupInfo and 0b10) != 0 // 检查位 1
}
// 检查是否有 Aux 数据
fun hasAuxData(groupInfo: Int): Boolean {
return (groupInfo and 0b100) != 0 // 检查位 2
}</code></pre>
<p><strong>作用 2：存储节点数量</strong></p>
<pre><code>// 获取节点数量（位 4-31）
fun getNodeCount(groupInfo: Int): Int {
return groupInfo shr 4 // 右移 4 位，获取高位
}
// 设置节点数量
fun setNodeCount(groupInfo: Int, count: Int): Int {
val flags = groupInfo and 0b1111 // 保留低 4 位（标志位）
return flags or (count shl 4) // 设置高位（节点数量）
}</code></pre>
<p><strong>作用 3：标记状态</strong></p>
<pre><code>// 检查是否被标记
fun isMarked(groupInfo: Int): Boolean {
return (groupInfo and 0b1000) != 0 // 检查位 3
}
// 设置标记
fun markGroup(groupInfo: Int): Int {
return groupInfo or 0b1000 // 设置位 3 为 1
}</code></pre>
<h4><strong>使用场景</strong></h4>
<p><strong>使用场景 1：判断是否需要创建 LayoutNode</strong></p>
<pre><code>fun processGroup(groups: IntArray, startIndex: Int) {
val groupInfo = groups[startIndex + 1] // 获取 GroupInfo
// 检查是否是 Node 组
if (isNodeGroup(groupInfo)) {
// 是 Node 组，需要创建 LayoutNode
val layoutNode = createLayoutNode()
// 存储到 slots 数组
val dataAnchor = groups[startIndex + 4]
slots[dataAnchor] = layoutNode
} else {
// 不是 Node 组，只是容器（如 Column、Row）
// 不需要创建 LayoutNode
}
}</code></pre>
<hr />
<h2><strong>SlotTable 与 LayoutNode 的关系</strong></h2>
<h3><strong>概述</strong></h3>
<p><code>SlotTable</code> 和 <code>LayoutNode</code> 是 Compose 架构中两个核心组件，它们分别属于不同的层次：</p>
<ul>
<li><strong>SlotTable</strong>：Compose Runtime 层的数据结构，存储组合树（Composition Tree）的完整状态</li>
<li><strong>LayoutNode</strong>：Compose UI 层的节点，代表一个可布局和可绘制的 UI 元素</li>
</ul>
<p>它们通过 <strong>Composer</strong> 和 <strong>Applier</strong> 机制连接在一起。</p>
<h3><strong>1. 核心关系</strong></h3>
<h4><strong>1.1 存储关系</strong></h4>
<p><strong>LayoutNode 存储在 SlotTable 的 </strong><strong><code>slots</code></strong><strong> 数组中</strong></p>
<pre><code>// SlotTable.kt 注释说明（第 63-65 行）
// Node - a value of a node group that can be set independently of the slots of the group.
// This is, for example, where the LayoutNode is stored by the slot table when
// emitting using the UIEmitter.</code></pre>
<p><strong>关键点：</strong></p>
<ul>
<li>当 Group 的 <code>GroupInfo</code> 标记为 <code>isNode = true</code> 时，对应的 <code>LayoutNode</code> 存储在 <code>slots</code> 数组中</li>
<li>存储位置由 Group 的 <code>DataAnchor</code> 指向</li>
<li>通过 <code>groups.nodeIndex(index)</code> 可以获取 LayoutNode 在 slots 数组中的索引</li>
</ul>
<h4><strong>1.2 数据结构映射</strong></h4>
<pre><code>SlotTable (Runtime 层)
├── groups 数组
│ └── Group (5个整数)
│ ├── Key
│ ├── GroupInfo (包含 isNode 标志)
│ ├── ParentAnchor
│ ├── Size
│ └── DataAnchor → 指向 slots 数组
│
└── slots 数组
└── [index] = LayoutNode (当 isNode = true 时)</code></pre>
<h3><strong>2. 创建流程</strong></h3>
<h4><strong>2.1 Composer 创建 LayoutNode</strong></h4>
<p>当 Composable 函数调用 <code>Layout</code> 或 <code>ComposeNode</code> 时：</p>
<pre><code>// Composer.kt 第 1670-1677 行
override fun &lt;T&gt; createNode(factory: () -&gt; T) {
validateNodeExpected()
runtimeCheck(inserting) { "createNode() can only be called when inserting" }
val insertIndex = nodeIndexStack.peek()
val groupAnchor = writer.anchor(writer.parent)
groupNodeCount++
insertFixups.createAndInsertNode(factory, insertIndex, groupAnchor)
}</code></pre>
<p><strong>流程：</strong></p>
<ol>
<li><code>createNode</code> 被调用，传入 <code>factory: () -&gt; LayoutNode</code></li>
<li>创建一个新的 Group，标记 <code>isNode = true</code></li>
<li>调用 <code>factory()</code> 创建 <code>LayoutNode</code> 实例</li>
<li>将 <code>LayoutNode</code> 存储到 <code>slots</code> 数组中</li>
<li>通过 <code>DataAnchor</code> 建立 Group 和 LayoutNode 的关联</li>
</ol>
<h4><strong>2.2 实际代码示例</strong></h4>
<pre><code>// Layout.kt 中的 Column 实现
@Composable
fun Column(
modifier: Modifier = Modifier,
content: @Composable ColumnScope.() -&gt; Unit
) {
ReusableComposeNode&lt;ComposeUiNode, Applier&lt;Any&gt;&gt;(
factory = { LayoutNode() }, // ← 创建 LayoutNode
update = { /* ... */ },
content = content
)
}</code></pre>
<p><strong>执行流程：</strong></p>
<pre><code>1. Column() 被调用
↓
2. ReusableComposeNode 调用 Composer.createNode { LayoutNode() }
↓
3. Composer 创建 Group，设置 isNode = true
↓
4. 调用 factory() 创建 LayoutNode 实例
↓
5. 将 LayoutNode 存储到 slots[DataAnchor]
↓
6. Group 的 DataAnchor 指向 slots 数组中的 LayoutNode</code></pre>
<h3><strong>3. 访问机制</strong></h3>
<h4><strong>3.1 从 SlotTable 读取 LayoutNode</strong></h4>
<pre><code>// SlotTable.kt 第 1229-1231 行
private fun IntArray.node(index: Int) = if (isNode(index)) {
slots[nodeIndex(index)] // ← 从 slots 数组获取 LayoutNode
} else Composer.Empty</code></pre>
<p><strong>关键方法：</strong></p>
<ul>
<li><code>groups.isNode(index)</code>：检查 Group 是否为 Node 组</li>
<li><code>groups.nodeIndex(index)</code>：获取 LayoutNode 在 slots 数组中的索引</li>
<li><code>slots[nodeIndex]</code>：获取实际的 LayoutNode 实例</li>
</ul>
<h4><strong>3.2 从 LayoutNode 反向查找 SlotTable</strong></h4>
<p>LayoutNode 本身不直接存储对 SlotTable 的引用，但可以通过以下方式关联：</p>
<ol>
<li><strong>通过 Composition 上下文</strong>：LayoutNode 属于某个 Composition，而 Composition 持有 SlotTable</li>
<li><strong>通过 Applier</strong>：Applier 维护 LayoutNode 树，同时知道对应的 SlotTable</li>
</ol>
<h3><strong>4. 生命周期关系</strong></h3>
<h4><strong>4.1 创建阶段</strong></h4>
<pre><code>Composition 初始化
↓
SlotTable 创建（空）
↓
Composer 执行 Composable 函数
↓
遇到 Layout/ComposeNode
↓
创建 Group (isNode = true)
↓
创建 LayoutNode 实例
↓
存储到 slots 数组
↓
Applier 将 LayoutNode 添加到树中</code></pre>
<h4><strong>4.2 重组阶段</strong></h4>
<pre><code>状态变化触发重组
↓
Composer 比较新旧 SlotTable
↓
发现 Group 需要更新
↓
从 slots 数组读取现有 LayoutNode
↓
调用 update 回调更新 LayoutNode
↓
LayoutNode 标记为需要重新测量/布局</code></pre>
<h4><strong>4.3 删除阶段</strong></h4>
<pre><code>Composable 被移除
↓
SlotTable 删除对应的 Group
↓
从 slots 数组移除 LayoutNode 引用
↓
Applier 从树中移除 LayoutNode
↓
LayoutNode 被回收</code></pre>
<h3><strong>5. 数据同步机制</strong></h3>
<h4><strong>5.1 状态同步</strong></h4>
<p><strong>SlotTable 存储的状态 → LayoutNode 的属性</strong></p>
<pre><code>// 示例：Modifier 更新
@Composable
fun MyComposable(modifier: Modifier) {
Layout(content = {}) { measurables, constraints -&gt;
// ...
}
}
// 重组时：
// 1. SlotTable 中存储的 modifier 值变化
// 2. Composer 检测到变化
// 3. 调用 update 回调
// 4. LayoutNode.modifier 被更新</code></pre>
<h4><strong>5.2 结构同步</strong></h4>
<p><strong>SlotTable 的 Group 树 ↔ LayoutNode 树</strong></p>
<pre><code>SlotTable Groups 树 LayoutNode 树
┌─────────────────┐ ┌──────────────┐
│ Group (Column) │ ←──→ │ LayoutNode │
│ ├─ Group (T1)│ ←──→ │ ├─ LayoutNode│
│ └─ Group (T2)│ ←──→ │ └─ LayoutNode│
└─────────────────┘ └──────────────┘</code></pre>
<p><strong>同步机制：</strong></p>
<ul>
<li>Applier 负责维护两棵树的一致性</li>
<li>当 SlotTable 变化时，Applier 更新 LayoutNode 树</li>
<li>通过 <code>Applier.insert</code>、<code>Applier.remove</code>、<code>Applier.move</code> 等方法</li>
</ul>
<h3><strong>6. 关键代码位置</strong></h3>
<h4><strong>6.1 SlotTable 相关</strong></h4>
<ul>
<li><strong>定义</strong>：<code>compose/runtime/runtime/src/commonMain/kotlin/androidx/compose/runtime/SlotTable.kt</code></li>
<li><strong>Node 存储</strong>：第 1229-1231 行（<code>node()</code> 方法）</li>
<li><strong>Node 索引</strong>：<code>groups.nodeIndex(index)</code> 方法</li>
</ul>
<h4><strong>6.2 LayoutNode 相关</strong></h4>
<ul>
<li><strong>定义</strong>：<code>compose/ui/ui/src/commonMain/kotlin/androidx/compose/ui/node/LayoutNode.kt</code></li>
<li><strong>实现 ComposeNodeLifecycleCallback</strong>：第 88 行</li>
</ul>
<h4><strong>6.3 连接点</strong></h4>
<ul>
<li><strong>Composer.createNode</strong>：<code>compose/runtime/runtime/src/commonMain/kotlin/androidx/compose/runtime/Composer.kt</code> 第 1670 行</li>
<li><strong>Applier</strong>：负责将 SlotTable 的变化应用到 LayoutNode 树</li>
</ul>
<h3><strong>7. 总结</strong></h3>
<h4><strong>7.1 核心关系</strong></h4>
<ol>
<li><strong>存储关系</strong>：LayoutNode 存储在 SlotTable 的 <code>slots</code> 数组中</li>
<li><strong>创建关系</strong>：Composer 通过 <code>createNode</code> 创建 LayoutNode 并存储到 SlotTable</li>
<li><strong>访问关系</strong>：通过 Group 的 <code>DataAnchor</code> 和 <code>nodeIndex</code> 访问 LayoutNode</li>
<li><strong>同步关系</strong>：Applier 负责保持 SlotTable 和 LayoutNode 树的一致性</li>
</ol>
<h4><strong>7.2 设计优势</strong></h4>
<ol>
<li><strong>分离关注点</strong>：</li>
</ol>
<ul>
<li>SlotTable 专注于状态管理和结构存储</li>
<li>LayoutNode 专注于布局和绘制</li>
</ul>
<ol>
<li><strong>性能优化</strong>：</li>
</ol>
<ul>
<li>SlotTable 使用紧凑的数组结构</li>
<li>LayoutNode 只在需要时才创建</li>
</ul>
<ol>
<li><strong>增量更新</strong>：</li>
</ol>
<ul>
<li>通过比较 SlotTable 找出变化</li>
<li>只更新受影响的 LayoutNode</li>
</ul>
<h4><strong>7.3 类比理解</strong></h4>
<p><strong>SlotTable 就像"设计图纸"</strong>：</p>
<ul>
<li>存储了 UI 的完整结构和状态</li>
<li>描述了每个组件的类型、参数、状态值</li>
</ul>
<p><strong>LayoutNode 就像"实际建筑"</strong>：</p>
<ul>
<li>根据设计图纸建造的实际 UI 元素</li>
<li>负责实际的布局、测量、绘制</li>
</ul>
<p><strong>Composer 就像"建筑师"</strong>：</p>
<ul>
<li>根据设计图纸（SlotTable）建造建筑（LayoutNode）</li>
<li>当图纸变化时，更新或重建建筑</li>
</ul>
<hr />
<h2><strong>SlotTable 的使用方式</strong></h2>
<h3><strong>基本使用模式</strong></h3>
<p>虽然开发者通常不直接使用 SlotTable，但了解其使用模式有助于理解 Compose 的工作原理：</p>
<h3><strong>1. 读取模式（Reader）</strong></h3>
<pre><code>slotTable.read { reader -&gt;
// 遍历组合树
reader.startGroup()
// 读取当前组的数据
val oldValue = reader.next() // 读取第一个 slot
val lambda = reader.next() // 读取第二个 slot
// 处理子组
while (!reader.isGroupEnd) {
// 递归处理子组...
}
reader.endGroup()
}</code></pre>
<p><strong>特点：</strong></p>
<ul>
<li>支持多个 Reader 同时读取</li>
<li>不能在有 Writer 时读取</li>
<li>使用期间不能写入</li>
</ul>
<h3><strong>2. 写入模式（Writer）</strong></h3>
<pre><code>// 写入新的组合树状态
slotTable.write { writer -&gt;
writer.startGroup(key = composableKey)
// 写入/更新数据
writer.update(newValue) // 更新第一个 slot
writer.update(newLambda) // 更新第二个 slot
// 处理子组
// ...
writer.endGroup()
}</code></pre>
<p><strong>特点：</strong></p>
<ul>
<li>只能有一个 Writer 同时写入</li>
<li>写入时不能有 Reader</li>
<li>写入完成后，Gap 会被移动到末尾</li>
</ul>
<h3><strong>3. 完整的重组流程</strong></h3>
<pre><code>// 1. 读取旧状态
slotTable.read { reader -&gt;
// 比较结构，识别变化
}
// 2. 写入新状态
slotTable.write { writer -&gt;
// 更新变化的部分
if (hasChanges) {
writer.update(newValue)
} else {
writer.skip() // 跳过未变化的部分
}
}</code></pre>
<hr />
<h2><strong>Composition 初始化流程</strong></h2>
<h3><strong>整体流程</strong></h3>
<p>当调用 <code>setContent { ... }</code> 时，Compose 会执行以下步骤：</p>
<pre><code>1. 创建 Composition
└─&gt; 创建 SlotTable（如果首次）
└─&gt; 创建 Composer
2. 开始 Composition
└─&gt; startRoot() ← 这是我们要重点分析的
3. 执行 Composable 函数
└─&gt; 构建组合树
└─&gt; 填充 SlotTable
4. 结束 Composition
└─&gt; endRoot()
└─&gt; 应用变化到 UI</code></pre>
<h3><strong>startRoot() 的位置</strong></h3>
<p><code>startRoot()</code> 是 Composition 的<strong>入口方法</strong>，在每个 Composition 开始时都会被调用一次。</p>
<hr />
<h2><strong>startRoot() 方法详解</strong></h2>
<h3><strong>完整代码</strong></h3>
<pre><code>@OptIn(InternalComposeApi::class)
private fun startRoot() {
OhosTrace.traceSync("Composer startRoot", {
// 1. 打开 SlotTable Reader
reader = slotTable.openReader()
// 2. 开始根组
startGroup(rootKey)
// 3. 父上下文管理
parentContext.startComposing()
parentProvider = parentContext.getCompositionLocalScope()
providersInvalidStack.push(providersInvalid.asInt())
providersInvalid = changed(parentProvider)
providerCache = null
// 4. 调试信息收集
if (!forceRecomposeScopes) {
forceRecomposeScopes = parentContext.collectingParameterInformation
}
// 5. 源码信息收集
if (!sourceInformationEnabled) {
sourceInformationEnabled = parentContext.collectingSourceInformation
}
// 6. 检查表注册
parentProvider.read(LocalInspectionTables)?.let {
it.add(slotTable)
parentContext.recordInspectionTable(it)
}
// 7. 开始父上下文组
startGroup(parentContext.compoundHashKey)
})
}</code></pre>
<h3><strong>逐步解析</strong></h3>
<h4><strong>步骤 1: 打开 SlotTable Reader</strong></h4>
<pre><code>reader = slotTable.openReader()</code></pre>
<p><strong>作用：</strong></p>
<ul>
<li>打开 SlotTable 的读取通道</li>
<li>准备读取现有的组合树状态</li>
<li>如果这是首次组合，SlotTable 可能是空的</li>
</ul>
<p><strong>要点：</strong></p>
<ul>
<li>Reader 用于读取之前保存的状态</li>
<li>在重组时，可以通过 Reader 比较新旧结构</li>
</ul>
<h4><strong>步骤 2: 开始根组</strong></h4>
<pre><code>startGroup(rootKey)</code></pre>
<p><strong>作用：</strong></p>
<ul>
<li>在 SlotTable 中创建一个根组（Root Group）</li>
<li><code>rootKey</code> 是一个特殊的键值，标识这是整个 Composition 的根</li>
</ul>
<p><strong>结构示意：</strong></p>
<pre><code>SlotTable:
Group(rootKey) ← 根组开始
└─&gt; [后续所有 composable 组都会是这个组的子组]</code></pre>
<h4><strong>步骤 3: 父上下文管理</strong></h4>
<pre><code>parentContext.startComposing()
parentProvider = parentContext.getCompositionLocalScope()
providersInvalidStack.push(providersInvalid.asInt())
providersInvalid = changed(parentProvider)
providerCache = null</code></pre>
<p><strong>详细解释：</strong></p>
<ol>
<li><strong><code>parentContext.startComposing()</code></strong></li>
</ol>
<ul>
<li>通知父上下文开始组合</li>
<li>用于嵌套 Composition 的场景</li>
</ul>
<ol>
<li><strong><code>parentProvider = parentContext.getCompositionLocalScope()</code></strong></li>
</ol>
<ul>
<li>获取父级的 <code>CompositionLocal</code> 作用域</li>
<li>CompositionLocal 用于向下传递上下文值（类似 Context in Android）</li>
<li>例如：<code>LocalContext</code>、<code>LocalConfiguration</code> 等</li>
</ul>
<ol>
<li><strong><code>providersInvalidStack.push(...)</code></strong><strong> 和 </strong><strong><code>providersInvalid = changed(...)</code></strong></li>
</ol>
<ul>
<li><strong>作用：</strong> 检查 CompositionLocal 是否变化</li>
<li><strong>机制：</strong></li>
<li>将旧的 <code>providersInvalid</code> 状态压栈保存</li>
<li>检查新的 <code>parentProvider</code> 是否有变化</li>
<li>如果有变化，<code>providersInvalid</code> 会被标记，触发相关 composable 重组</li>
<li><strong>为什么需要栈？</strong> 支持嵌套的 CompositionLocal 作用域</li>
</ul>
<ol>
<li><strong><code>providerCache = null</code></strong></li>
</ol>
<ul>
<li>清空 CompositionLocal 的缓存</li>
<li>确保使用最新的上下文值</li>
</ul>
<h4><strong>步骤 4: 调试信息收集</strong></h4>
<pre><code>if (!forceRecomposeScopes) {
forceRecomposeScopes = parentContext.collectingParameterInformation
}</code></pre>
<p><strong>作用：</strong></p>
<ul>
<li>如果父上下文正在收集参数信息（用于调试工具），启用强制重组范围</li>
<li>用于 Android Studio 的 Compose 调试功能</li>
<li>可以显示哪些 composable 的参数发生了变化</li>
</ul>
<p><strong>使用场景：</strong></p>
<ul>
<li>Layout Inspector</li>
<li>Recomposition Count 调试</li>
<li>Parameter Tracking</li>
</ul>
<h4><strong>步骤 5: 源码信息收集</strong></h4>
<pre><code>if (!sourceInformationEnabled) {
sourceInformationEnabled = parentContext.collectingSourceInformation
}</code></pre>
<p><strong>作用：</strong></p>
<ul>
<li>启用源码信息收集功能</li>
<li>用于在调试时显示 composable 的来源位置（文件名、行号等）</li>
<li>存储在 <code>GroupSourceInformation</code> 中</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code>// 调试工具可以显示：
// MyComposable.kt:42 ← 这个 composable 定义在哪个文件的哪一行</code></pre>
<h4><strong>步骤 6: 检查表注册</strong></h4>
<pre><code>parentProvider.read(LocalInspectionTables)?.let {
it.add(slotTable)
parentContext.recordInspectionTable(it)
}</code></pre>
<p><strong>作用：</strong></p>
<ul>
<li>将当前 SlotTable 注册到检查表（Inspection Table）</li>
<li>用于 Android Studio 的 <strong>Composition Inspector</strong></li>
<li>允许开发工具实时查看组合树的结构</li>
</ul>
<p><strong>检查表的作用：</strong></p>
<ul>
<li>显示当前 Composition 的完整树结构</li>
<li>显示每个 composable 的状态值</li>
<li>显示重组次数和原因</li>
</ul>
<h4><strong>步骤 7: 开始父上下文组</strong></h4>
<pre><code>startGroup(parentContext.compoundHashKey)</code></pre>
<p><strong>作用：</strong></p>
<ul>
<li>开始一个用于管理父上下文的作用域组</li>
<li><code>compoundHashKey</code> 是父上下文的唯一标识</li>
<li>这个组用于隔离不同嵌套层级的 CompositionLocal 值</li>
</ul>
<p><strong>结构示意：</strong></p>
<pre><code>SlotTable:
Group(rootKey) ← 步骤 2 创建的根组
Group(parentContextKey) ← 步骤 7 创建的父上下文组
└─&gt; [实际的 UI composable 组]</code></pre>
<p><strong>为什么需要这个组？</strong></p>
<ul>
<li>管理 CompositionLocal 的层级作用域</li>
<li>确保每个层级有独立的上下文值</li>
<li>支持嵌套的 <code>CompositionLocalProvider</code></li>
</ul>
<hr />
<h2><strong>实际应用示例</strong></h2>
<h3><strong>示例 1: 首次组合</strong></h3>
<pre><code>// 用户代码
setContent {
Column {
Text("Hello")
Button(onClick = {}) {
Text("Click")
}
}
}</code></pre>
<p><strong>执行流程：</strong></p>
<ol>
<li><strong>startRoot()</strong> 被调用</li>
</ol>
<ul>
<li>创建根组和父上下文组</li>
<li>初始化 CompositionLocal 作用域</li>
</ul>
<ol>
<li><strong>Column { … }</strong> 被调用</li>
</ol>
<ul>
<li>创建 Column 组（key = Column 的 hash）</li>
<li>在 slots 中存储 Column 的参数（content lambda）</li>
</ul>
<ol>
<li><strong>Text("Hello")</strong> 被调用</li>
</ol>
<ul>
<li>创建 Text 组（key = Text 的 hash）</li>
<li>在 slots 中存储参数（"Hello"）</li>
<li>创建 LayoutNode 用于渲染</li>
</ul>
<ol>
<li><strong>Button { … }</strong> 被调用</li>
</ol>
<ul>
<li>创建 Button 组</li>
<li>存储 onClick lambda 和 content lambda</li>
</ul>
<ol>
<li><strong>endRoot()</strong> 被调用</li>
</ol>
<ul>
<li>关闭 Reader</li>
<li>应用变化到 UI 层</li>
</ul>
<h3><strong>示例 2: 重组场景</strong></h3>
<pre><code>var count by remember { mutableStateOf(0) }
Column {
Text("Count: $count") // 当 count 变化时，这个 Text 需要重组
Button(onClick = { count++ }) {
Text("Increment")
}
}</code></pre>
<p><strong>重组流程：</strong></p>
<ol>
<li><strong>startRoot()</strong> 被调用</li>
</ol>
<ul>
<li>打开 Reader，读取现有的 SlotTable</li>
</ul>
<ol>
<li><strong>Column { … }</strong> 被比较</li>
</ol>
<ul>
<li>Reader 找到 Column 组</li>
<li>比较 key 是否匹配 → 匹配，继续</li>
</ul>
<ol>
<li><strong>Text("Count: $count")</strong> 被比较</li>
</ol>
<ul>
<li>Reader 找到 Text 组</li>
<li>读取旧的 count 值（存储在 slot 中）</li>
<li>比较新旧 count 值 → <strong>不匹配！</strong></li>
<li>标记该组需要重组</li>
</ul>
<ol>
<li><strong>重组执行</strong></li>
</ol>
<ul>
<li>Writer 更新 Text 组的 slot</li>
<li>新的 count 值被写入</li>
</ul>
<ol>
<li><strong>Button { … }</strong> 被比较</li>
</ol>
<ul>
<li>没有变化，跳过</li>
</ul>
<h3><strong>示例 3: CompositionLocal 使用</strong></h3>
<pre><code>// 提供上下文值
CompositionLocalProvider(LocalContentAlpha provides 0.5f) {
Column {
Text("Alpha: ${LocalContentAlpha.current}") // 使用上下文值
}
}</code></pre>
<p><strong>startRoot() 中的处理：</strong></p>
<ol>
<li><strong>获取父上下文</strong></li>
</ol>
<pre><code>parentProvider = parentContext.getCompositionLocalScope()</code></pre>
<ul>
<li>获取包含 <code>LocalContentAlpha = 0.5f</code> 的作用域</li>
</ul>
<ol>
<li><strong>检查变化</strong></li>
</ol>
<pre><code>providersInvalid = changed(parentProvider)</code></pre>
<ul>
<li>如果 <code>LocalContentAlpha</code> 的值变化，标记需要重组</li>
</ul>
<ol>
<li><strong>创建作用域组</strong></li>
</ol>
<pre><code>startGroup(parentContext.compoundHashKey)</code></pre>
<ul>
<li>创建一个组来管理这个 CompositionLocal 作用域</li>
</ul>
<h3><strong>示例 4: 重组优化</strong></h3>
<pre><code>@Composable
fun MyScreen() {
var count by remember { mutableStateOf(0) }
Column {
Text("Count: $count") // ← 只有这个会重组
Button(onClick = { count++ }) {
Text("Increment")
}
}
}</code></pre>
<p><strong>执行流程：</strong></p>
<ol>
<li>状态变化：<code>count</code> 从 0 变为 1</li>
<li>SlotTable 比较：发现 Text 的 Group 需要更新</li>
<li>读取 LayoutNode：从 <code>slots[nodeIndex]</code> 获取 Text 的 LayoutNode</li>
<li>更新内容：调用 <code>update</code> 回调更新 Text 的文本</li>
<li>标记重绘：LayoutNode 标记为需要重绘</li>
</ol>
<h3><strong>示例 5: 节点复用</strong></h3>
<pre><code>@Composable
fun List(items: List&lt;Item&gt;) {
items.forEach { item -&gt;
ItemRow(item) // ← 相同的 key 会复用 LayoutNode
}
}</code></pre>
<p><strong>执行流程：</strong></p>
<ol>
<li>第一次组合：为每个 item 创建 Group 和 LayoutNode</li>
<li>列表变化：添加/删除 item</li>
<li>SlotTable 比较：通过 key 匹配新旧 Group</li>
<li>复用 LayoutNode：如果 key 匹配，复用现有的 LayoutNode</li>
<li>更新内容：只更新变化的部分</li>
</ol>
<hr />
<h2><strong>调试技巧</strong></h2>
<h3><strong>1. 查看 SlotTable 内容</strong></h3>
<pre><code>// 在调试器中
composition.slotTable.groups // 查看 groups 数组
composition.slotTable.slots // 查看 slots 数组（包含 LayoutNode）</code></pre>
<h3><strong>2. 查看 LayoutNode 树</strong></h3>
<pre><code>// 从 Composition 获取根 LayoutNode
val rootNode = (composition as? ControlledComposition)?.root
rootNode?.forEach { node -&gt;
println("LayoutNode: ${node.javaClass.simpleName}")
}</code></pre>
<h3><strong>3. 验证关联关系</strong></h3>
<pre><code>// 验证 SlotTable 中的 LayoutNode 和实际的 LayoutNode 树是否一致
val slotTableNodes = composition.slotTable.slots.filterIsInstance&lt;LayoutNode&gt;()
val layoutTreeNodes = rootNode?.collectAllNodes() ?: emptyList()
// 比较两个列表是否一致</code></pre>
<hr />
<h2><strong>常见问题</strong></h2>
<h3><strong>Q1: 为什么 LayoutNode 不直接存储在 Group 中？</strong></h3>
<p><strong>A:</strong> 性能考虑。使用数组存储可以：</p>
<ul>
<li>减少内存碎片</li>
<li>提高缓存局部性</li>
<li>支持批量操作</li>
</ul>
<h3><strong>Q2: SlotTable 和 LayoutNode 树是否总是同步？</strong></h3>
<p><strong>A:</strong> 在正常流程中是的，但存在短暂的异步窗口：</p>
<ul>
<li>SlotTable 先更新（重组阶段）</li>
<li>然后通过 Applier 应用到 LayoutNode 树（应用阶段）</li>
</ul>
<h3><strong>Q3: 如何知道一个 LayoutNode 对应哪个 Group？</strong></h3>
<p><strong>A:</strong> 通过 Applier 维护的映射关系，或者遍历 SlotTable 查找 <code>slots[nodeIndex] == layoutNode</code> 的 Group。</p>
<h3><strong>Q4: Gap 是否存在于 groups 数组中？</strong></h3>
<p><strong>A:</strong> 是的！Gap 确实存在于 <code>groups</code> 数组中，但它是<strong>未使用的空间</strong>，不是有效的 Group 数据。</p>
<p><strong>关键点：</strong></p>
<ol>
<li><strong>Gap 是数组中的空位</strong>：未使用的空间，不是有效的 Group 数据</li>
<li><strong>Gap 的位置会动态移动</strong>：根据插入/删除操作的需要移动</li>
<li><strong>Gap 中的值不重要</strong>：可能是 0、未初始化值或残留数据</li>
<li><strong>通过位置范围跟踪</strong>：使用 <code>gapStart</code> 和 <code>gapEnd</code> 来标记 gap 的位置</li>
<li><strong>两个数组都有 gap</strong>：<code>groups</code> 数组和 <code>slots</code> 数组都有各自的 gap</li>
<li><strong>性能优化</strong>：在 gap 位置操作是 O(1)，移动成本可以分摊，实际性能更好</li>
</ol>
<hr />
<h2><strong>总结</strong></h2>
<h3><strong>SlotTable 的作用</strong></h3>
<ol>
<li><strong>状态存储</strong>：保存所有 composable 的状态值</li>
<li><strong>结构管理</strong>：维护组合树的完整结构</li>
<li><strong>差异检测</strong>：通过比较实现增量重组</li>
<li><strong>性能优化</strong>：使用 Gap Buffer 优化更新性能</li>
</ol>
<h3><strong>startRoot() 的作用</strong></h3>
<ol>
<li><strong>初始化组合</strong>：创建根组和父上下文组</li>
<li><strong>上下文管理</strong>：设置 CompositionLocal 作用域</li>
<li><strong>调试支持</strong>：启用调试工具所需的信息收集</li>
<li><strong>检查工具</strong>：注册 SlotTable 供开发工具使用</li>
</ol>
<h3><strong>SlotTable 与 LayoutNode 的关系</strong></h3>
<ol>
<li><strong>存储关系</strong>：LayoutNode 存储在 SlotTable 的 <code>slots</code> 数组中</li>
<li><strong>创建关系</strong>：Composer 通过 <code>createNode</code> 创建 LayoutNode 并存储到 SlotTable</li>
<li><strong>访问关系</strong>：通过 Group 的 <code>DataAnchor</code> 和 <code>nodeIndex</code> 访问 LayoutNode</li>
<li><strong>同步关系</strong>：Applier 负责保持 SlotTable 和 LayoutNode 树的一致性</li>
</ol>
<h3><strong>关键要点</strong></h3>
<ul>
<li><strong>SlotTable 是 Compose 的核心</strong>：几乎所有 Compose 特性都依赖于它</li>
<li><strong>增量重组的基础</strong>：通过 SlotTable 的比较实现高效的 UI 更新</li>
<li><strong>状态管理的关键</strong>：所有状态都存储在 SlotTable 的 slots 中</li>
<li><strong>开发工具的支撑</strong>：Composition Inspector 等工具依赖 SlotTable</li>
<li><strong>设计图纸与建筑</strong>：SlotTable 是设计图纸，LayoutNode 是实际建筑，Composer 是建筑师</li>
</ul>
<p>理解 SlotTable、LayoutNode 和 startRoot() 的工作原理，有助于：</p>
<ul>
<li>更好地理解 Compose 的重组机制</li>
<li>优化性能（避免不必要的重组）</li>
<li>调试 Compose 相关问题</li>
<li>深入理解 Compose 的设计哲学</li>
</ul>
<hr />
<h2><strong>参考资料</strong></h2>
<ol>
<li>SlotTable.kt - Compose Runtime 核心数据结构</li>
<li>LayoutNode.kt - Compose UI 布局节点</li>
<li>Composer.kt - 组合执行器</li>
<li>Applier.kt - 应用器，负责同步 SlotTable 和 LayoutNode 树</li>
<li>Compose 官方文档：重组</li>
</ol>
<p><strong>目录</strong></p>
<figure class="doc-figure"><img src="../knowledge-map-assets/slottable-composition-8939c899-20aaff7a36.png" alt="SlotTable 与 Composition 完整详解 图示" /></figure></div>
      </section>
  </main>
  </div>

  <div class="img-modal" id="img-modal" aria-hidden="true">
    <div class="img-modal-backdrop"></div>
    <div class="img-modal-toolbar">
      <button type="button" id="img-zoom-out" title="缩小">-</button>
      <button type="button" id="img-zoom-in" title="放大">+</button>
      <button type="button" id="img-zoom-reset" title="重置">100%</button>
      <span class="zoom-value" id="img-zoom-value">100%</span>
      <button type="button" id="img-modal-close" title="关闭">关闭</button>
    </div>
    <div class="img-modal-image-wrap">
      <img id="img-modal-img" alt="" />
    </div>
  </div>


  <script>
    (function () {
      const root = document.getElementById('zoom-root');
      if (!root) return;
      const valueEl = document.getElementById('zoom-value');
      const min = 0.6;
      const max = 2.4;
      const step = 0.1;
      const key = "km_detail_zoom";
      let scale = 1;

      try {
        const saved = parseFloat(localStorage.getItem(key) || "1");
        if (!Number.isNaN(saved)) scale = saved;
      } catch (_) {}

      const clamp = (n) => Math.min(max, Math.max(min, n));

      const apply = () => {
        scale = clamp(scale);
        if ("zoom" in root.style) {
          root.style.zoom = String(scale);
        } else {
          root.style.transform = `scale(${scale})`;
          root.style.transformOrigin = "top center";
        }
        if (valueEl) valueEl.textContent = `${Math.round(scale * 100)}%`;
        try {
          localStorage.setItem(key, String(scale));
        } catch (_) {}
      };

      document.querySelectorAll("[data-zoom]").forEach((btn) => {
        btn.addEventListener("click", () => {
          const action = btn.getAttribute("data-zoom");
          if (action === "in") scale += step;
          if (action === "out") scale -= step;
          if (action === "reset") scale = 1;
          apply();
        });
      });

      window.addEventListener(
        "wheel",
        (event) => {
          if (!(event.ctrlKey || event.metaKey)) return;
          if (document.body.classList.contains("img-modal-open")) return;
          event.preventDefault();
          scale += event.deltaY < 0 ? step : -step;
          apply();
        },
        { passive: false }
      );

      window.addEventListener("keydown", (event) => {
        if (!(event.ctrlKey || event.metaKey)) return;
        if (event.key === "+" || event.key === "=") {
          event.preventDefault();
          scale += step;
          apply();
        } else if (event.key === "-") {
          event.preventDefault();
          scale -= step;
          apply();
        } else if (event.key === "0") {
          event.preventDefault();
          scale = 1;
          apply();
        }
      });

      apply();
    })();
  </script>


  <script>
    (function () {
      const modal = document.getElementById("img-modal");
      if (!modal) return;
      const image = document.getElementById("img-modal-img");
      const imageWrap = modal.querySelector(".img-modal-image-wrap");
      const closeBtn = document.getElementById("img-modal-close");
      const zoomOutBtn = document.getElementById("img-zoom-out");
      const zoomInBtn = document.getElementById("img-zoom-in");
      const zoomResetBtn = document.getElementById("img-zoom-reset");
      const zoomValue = document.getElementById("img-zoom-value");
      if (!image || !imageWrap) return;

      let scale = 1;
      const min = 0.2;
      const max = 6;
      const step = 0.15;
      let isDragging = false;
      let dragPointerId = null;
      let lastX = 0;
      let lastY = 0;

      const apply = () => {
        scale = Math.min(max, Math.max(min, scale));
        image.style.transform = `scale(${scale})`;
        if (zoomValue) zoomValue.textContent = `${Math.round(scale * 100)}%`;
      };

      const open = (src, alt) => {
        image.src = src;
        image.alt = alt || "";
        scale = 1;
        apply();
        imageWrap.scrollLeft = 0;
        imageWrap.scrollTop = 0;
        modal.classList.add("open");
        document.body.classList.add("img-modal-open");
        document.body.style.overflow = "hidden";
      };

      const stopDragging = () => {
        isDragging = false;
        dragPointerId = null;
        imageWrap.classList.remove("dragging");
      };

      const close = () => {
        stopDragging();
        modal.classList.remove("open");
        document.body.classList.remove("img-modal-open");
        document.body.style.overflow = "";
        image.removeAttribute("src");
      };

      document.querySelectorAll(".doc-figure img").forEach((img) => {
        const figure = img.closest(".doc-figure");
        const originSrc = img.getAttribute("data-origin-src") || img.src;

        const markFailed = () => {
          if (!figure) return;
          figure.classList.add("img-load-failed");
          const link = figure.querySelector(".img-open-link");
          if (link && !link.getAttribute("href")) {
            link.setAttribute("href", originSrc);
          }
        };

        img.addEventListener("error", () => {
          if (img.dataset.retriedNoQuery !== "1") {
            const noQuery = originSrc.split("?")[0];
            if (noQuery && noQuery !== originSrc) {
              img.dataset.retriedNoQuery = "1";
              img.src = noQuery;
              return;
            }
          }
          markFailed();
        });

        if (img.complete && img.naturalWidth === 0) {
          markFailed();
        }

        img.addEventListener("click", () => {
          if (img.naturalWidth > 0) {
            open(img.currentSrc || img.src, img.alt);
            return;
          }
          if (originSrc && originSrc !== "#") {
            window.open(originSrc, "_blank", "noopener,noreferrer");
          }
        });
      });

      closeBtn?.addEventListener("click", close);
      modal.addEventListener("click", (event) => {
        if (event.target === modal || event.target.classList.contains("img-modal-backdrop")) {
          close();
        }
      });

      zoomInBtn?.addEventListener("click", () => { scale += step; apply(); });
      zoomOutBtn?.addEventListener("click", () => { scale -= step; apply(); });
      zoomResetBtn?.addEventListener("click", () => { scale = 1; apply(); });

      imageWrap.addEventListener("pointerdown", (event) => {
        if (!modal.classList.contains("open")) return;
        if (event.button !== 0) return;
        isDragging = true;
        dragPointerId = event.pointerId;
        lastX = event.clientX;
        lastY = event.clientY;
        imageWrap.classList.add("dragging");
        imageWrap.setPointerCapture?.(event.pointerId);
        event.preventDefault();
      });

      imageWrap.addEventListener("pointermove", (event) => {
        if (!isDragging || event.pointerId !== dragPointerId) return;
        const dx = event.clientX - lastX;
        const dy = event.clientY - lastY;
        imageWrap.scrollLeft -= dx;
        imageWrap.scrollTop -= dy;
        lastX = event.clientX;
        lastY = event.clientY;
      });

      const onPointerDone = (event) => {
        if (event.pointerId !== dragPointerId) return;
        imageWrap.releasePointerCapture?.(event.pointerId);
        stopDragging();
      };

      imageWrap.addEventListener("pointerup", onPointerDone);
      imageWrap.addEventListener("pointercancel", onPointerDone);

      modal.addEventListener(
        "wheel",
        (event) => {
          if (!modal.classList.contains("open")) return;
          event.preventDefault();
          scale += event.deltaY < 0 ? step : -step;
          apply();
        },
        { passive: false }
      );

      window.addEventListener("keydown", (event) => {
        if (!modal.classList.contains("open")) return;
        if (event.key === "Escape") {
          close();
        } else if (event.key === "+" || event.key === "=") {
          event.preventDefault();
          scale += step;
          apply();
        } else if (event.key === "-") {
          event.preventDefault();
          scale -= step;
          apply();
        } else if (event.key === "0") {
          event.preventDefault();
          scale = 1;
          apply();
        }
      });
    })();
  </script>


  <script>
    (function () {
      const roots = document.querySelectorAll(".content.rich");
      if (!roots.length) return;

      const h3Pattern = /^(?:[一二三四五六七八九十]+[、.．]|\d+[、.．)])\s*/;
      const h4Pattern = /^\d+\.\d+\s*/;
      const shortTitlePattern = /(?:流程|步骤|说明|配置|命令|目录|要求|概览)$/;
      const bulletPattern = /^[-*•]\s+/;
      const numberItemPattern = /^\d+[.)、]\s+/;

      const commandPattern =
        /^(?:\$\s*)?(?:export|git|ohpm|npm|pnpm|yarn|npx|python|python3|java|javac|gradle|\.\/gradlew|\.\/|adb|hdc|cmake|make|brew|curl|wget|source|chmod|chown|cp|mv|ls|cat|echo)\b/i;
      const envAssignPattern = /^(?:[A-Z_][A-Z0-9_]*=|PATH=|JAVA_HOME=|ANDROID_HOME=)/;
      const pathLikePattern = /(?:^\/|^\.\/|https?:\/\/|[\w.-]+\/[\w./-]+)/;

      const esc = (value) => {
        const span = document.createElement("span");
        span.textContent = value;
        return span.innerHTML;
      };

      const isCommandLike = (text) => {
        const sample = text.trim();
        if (!sample) return false;
        if (sample.length > 220) return false;
        if (commandPattern.test(sample)) return true;
        if (envAssignPattern.test(sample)) return true;
        if (sample.includes(" && ") || sample.includes(" || ")) return true;
        if (pathLikePattern.test(sample) && /\b(?:build|publish|clone|install|run|export|gradle|script)\b/i.test(sample)) {
          return true;
        }
        return false;
      };

      roots.forEach((root) => {
        const children = Array.from(root.children);
        const rebuilt = [];
        let codeBuffer = [];

        const flushCode = () => {
          if (!codeBuffer.length) return;
          const pre = document.createElement("pre");
          pre.className = "auto-code";
          const code = document.createElement("code");
          code.textContent = codeBuffer.join("\n");
          pre.appendChild(code);
          rebuilt.push(pre);
          codeBuffer = [];
        };

        children.forEach((node) => {
          if (node.tagName !== "P") {
            flushCode();
            rebuilt.push(node);
            return;
          }

          const text = (node.textContent || "").replace(/\u00A0/g, " ").trim();
          if (!text) return;

          if (h3Pattern.test(text)) {
            flushCode();
            const h3 = document.createElement("h3");
            h3.className = "auto-h3";
            h3.textContent = text;
            rebuilt.push(h3);
            return;
          }

          if (h4Pattern.test(text) || (text.length <= 24 && shortTitlePattern.test(text))) {
            flushCode();
            const h4 = document.createElement("h4");
            h4.className = "auto-h4";
            h4.textContent = text;
            rebuilt.push(h4);
            return;
          }

          const keyValue = text.match(/^([^:：]{2,20}[：:])\s*(.+)$/);
          if (keyValue) {
            const key = keyValue[1].trim();
            const value = keyValue[2].trim();
            if (value && isCommandLike(value)) {
              flushCode();
              const row = document.createElement("p");
              row.className = "kv-row";
              row.innerHTML = `<span class="kv-key">${esc(key)}</span><code>${esc(value)}</code>`;
              rebuilt.push(row);
              return;
            }
            if (value && value.length <= 120) {
              flushCode();
              const row = document.createElement("p");
              row.className = "kv-row";
              row.innerHTML = `<span class="kv-key">${esc(key)}</span><span>${esc(value)}</span>`;
              rebuilt.push(row);
              return;
            }
          }

          if (isCommandLike(text)) {
            codeBuffer.push(text);
            return;
          }

          if (bulletPattern.test(text) || numberItemPattern.test(text)) {
            flushCode();
            rebuilt.push(node);
            return;
          }

          flushCode();
          rebuilt.push(node);
        });

        flushCode();
        root.replaceChildren(...rebuilt);
      });
    })();
  </script>

  <script>
    (() => {
      const back = document.getElementById("chapter-back-link");
      if (!back) return;
      const chapter = (new URLSearchParams(window.location.search).get("chapter") || "all").trim().toLowerCase();
      if (!/^[a-z0-9-]+$/.test(chapter) || chapter === "all") {
        back.href = "../knowledge-map-chapters.html";
        return;
      }
      back.href = `../knowledge-map-chapters-${chapter}.html`;
    })();
  </script>
</body>
</html>
